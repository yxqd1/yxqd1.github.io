<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>字符串</title>
      <link href="/2024/05/16/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2024/05/16/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="一、子串，回文，字符串hash"><a href="#一、子串，回文，字符串hash" class="headerlink" title="一、子串，回文，字符串hash"></a>一、子串，回文，字符串hash</h2><p><a href="https://codeforces.com/gym/104095/problem/K">Problem - K - Codeforces</a></p><p>注意初始化</p><p>回文串&#x3D;》正着和反着进行hash，p排列数组不用多来，p数组表示的是排列之间的差距</p><p>翻转&#x3D;》利用hash减去旧的新添新的，注意p数组的补位（减就行）</p><p>哪里翻转&#x3D;》暴力第一个不同的位置，同的不用管</p><h2 id="二、子串，贪心，双指针，全排列"><a href="#二、子串，贪心，双指针，全排列" class="headerlink" title="二、子串，贪心，双指针，全排列"></a>二、子串，贪心，双指针，全排列</h2><p><a href="https://codeforces.com/contest/1793/problem/C">Problem - C - Codeforces</a></p><p>左右端点值和最大最小有关&#x3D;》子串可以通过删除得到，双指针</p><p>左右端点是最大最小值，则需要进行更更改，不是的话满足题意</p><h2 id="三、指针，递推，全排列数，子串"><a href="#三、指针，递推，全排列数，子串" class="headerlink" title="三、指针，递推，全排列数，子串"></a>三、指针，递推，全排列数，子串</h2><p><a href="https://codeforces.com/contest/1793/problem/D">Problem - D - Codeforces</a></p><p>上下两个串未出现的最小&#x3D;》令其为x，那么1–x-1就都得出现，令L,R为其中满足条件的位置</p><p>需要特判1&#x3D;》分开1的位置，计算其他位置的情况数，cnt*（cnt+1）&#x2F;2；完整区间，所以是等差数列求和</p><p>合适的位置&#x3D;》在【max(p+1,q+1),L）,(R,min(q-1,p-1)】,两个合适区间做乘法累加</p><p>最后加1，不太清楚</p><h2 id="四、反向构造马拉车字符串"><a href="#四、反向构造马拉车字符串" class="headerlink" title="四、反向构造马拉车字符串"></a>四、反向构造马拉车字符串</h2><p><a href="https://codeforces.com/group/Aokqa6Haao/contest/445660/problem/F">Problem - F - Codeforces</a></p><p>理应的右边界，和当前的右边界</p><p>一些特判，外加正确的对称位置</p><h2 id="五、子串、字典序、对于相对位置和原来坐标的利用"><a href="#五、子串、字典序、对于相对位置和原来坐标的利用" class="headerlink" title="五、子串、字典序、对于相对位置和原来坐标的利用"></a>五、子串、字典序、对于相对位置和原来坐标的利用</h2><p><a href="https://codeforces.com/contest/1847/problem/D">Problem - D - Codeforces</a></p><h2 id="六、对于子序列和子串的理解"><a href="#六、对于子序列和子串的理解" class="headerlink" title="六、对于子序列和子串的理解"></a>六、对于子序列和子串的理解</h2><p>从后往前，子序列不可能重复出现，累加每个数造成的影响，任意两个数的开始和结尾都是子序列无法重复子串的</p><p>开始想的大都是对的，但是对于细节的处理还是不太够</p><p><a href="https://codeforces.com/contest/1883/problem/F">Problem - F - Codeforces</a></p><h2 id="七、马拉车优化判回文串（双hash也行）"><a href="#七、马拉车优化判回文串（双hash也行）" class="headerlink" title="七、马拉车优化判回文串（双hash也行）"></a>七、马拉车优化判回文串（双hash也行）</h2><p>找特例判结论，用算法优化过程</p><p><a href="https://codeforces.com/contest/1944/problem/D">Problem - D - Codeforces</a></p><p>思路、结论、马拉车找回文串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxj = <span class="number">2e5</span> + <span class="number">100</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">char</span> a[maxj], b[maxj &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> p[maxj &lt;&lt; <span class="number">1</span>], f1[maxj &lt;&lt; <span class="number">1</span>], f2[maxj &lt;&lt; <span class="number">1</span>]; <span class="comment">// 记录每个对应位置的回文半径，注意是变换后的串,半径减1是回文长度</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="comment">// int l[maxj&lt;&lt;1],r[maxj]</span></span><br><span class="line"><span class="comment">// 将长度变换成奇数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    b[k++] = <span class="string">&#x27;$&#x27;</span>;</span><br><span class="line">    b[k++] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        b[k++] = a[i];</span><br><span class="line">        b[k++] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    b[k++] = <span class="string">&#x27;^&#x27;</span>;</span><br><span class="line">    n = k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        f1[i] = f2[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行马拉车算法,可以求最长回文长度，</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">manacher</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 右边界都采用开区间,所以是mr-i</span></span><br><span class="line">    <span class="type">int</span> mr = <span class="number">0</span>, mid;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 根据分析，最长回文内部选最小</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; mr)</span><br><span class="line">            p[i] = <span class="built_in">min</span>(p[<span class="number">2</span> * mid - i], mr - i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p[i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行扩展，算自己了</span></span><br><span class="line">        <span class="keyword">while</span> (b[i - p[i]] == b[i + p[i]])</span><br><span class="line">            p[i]++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新最大回文区间</span></span><br><span class="line">        <span class="keyword">if</span> (i + p[i] &gt; mr)</span><br><span class="line">        &#123;</span><br><span class="line">            mr = i + p[i];</span><br><span class="line">            mid = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m,nn;</span><br><span class="line">    cin &gt;&gt; nn &gt;&gt; m;</span><br><span class="line">    cin &gt;&gt; a;</span><br><span class="line">    n = <span class="built_in">strlen</span>(a);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">manacher</span>();</span><br><span class="line">    n -= <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// for(int i=0;i&lt;=n;++i)cout&lt;&lt;b[i]&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">    <span class="comment">// cout&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">    <span class="comment">// 结论的寻找，代码的继承</span></span><br><span class="line">    <span class="comment">// 让下标都从0开始,从后往前</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=nn<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">        <span class="comment">// 奇偶位不一样</span></span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">1</span>&lt;nn&amp;&amp;a[i]==a[i+<span class="number">1</span>])f1[i]=f1[i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> f1[i]=i+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 奇偶位一样</span></span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">2</span>&lt;nn&amp;&amp;a[i]==a[i+<span class="number">2</span>])f2[i]=f2[i+<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">else</span> f2[i]=i+<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for(int i=0;i&lt;nn;++i)&#123;</span></span><br><span class="line">    <span class="comment">//     cout&lt;&lt;f2[i]&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// cout&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">    <span class="comment">// 每一次的遍历</span></span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> l,r;cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        l--;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>,len=r-l;</span><br><span class="line">        <span class="comment">// 判断奇偶位不同时的全部情况=&gt;偶数长度</span></span><br><span class="line">        <span class="keyword">if</span>(f1[l]&lt;r)&#123;</span><br><span class="line">            <span class="type">int</span> te=(len<span class="number">-1</span>-(len<span class="number">-1</span>)%<span class="number">2</span>);</span><br><span class="line">            <span class="comment">// 偶数个不行的子集也都不行</span></span><br><span class="line">            <span class="keyword">if</span>(te&gt;=<span class="number">2</span>)ans=ans+(te+<span class="number">2</span>)*((te<span class="number">-2</span>)/<span class="number">2</span>+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;ans&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">        <span class="comment">// 判断奇偶位相同的全部情况</span></span><br><span class="line">        <span class="keyword">if</span>(f2[l]&lt;r||f2[l+<span class="number">1</span>]&lt;r)&#123;</span><br><span class="line">            <span class="type">int</span> te=(len<span class="number">-1</span>-(len)%<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>(te&gt;=<span class="number">3</span>)ans=ans+(te+<span class="number">3</span>)*((te<span class="number">-3</span>)/<span class="number">2</span>+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不轴对称，补上最长的</span></span><br><span class="line">        <span class="comment">// cout&lt;&lt;ans&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">        <span class="keyword">if</span>(p[l+r+<span class="number">1</span>]&lt;len)ans+=len;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二进制问题</title>
      <link href="/2024/05/16/%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%97%AE%E9%A2%98/"/>
      <url>/2024/05/16/%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="二进制问题"><a href="#二进制问题" class="headerlink" title="二进制问题"></a>二进制问题</h1><p>涉及知识点：数位dp</p><p>题目链接：[P8764 <a href="https://www.luogu.com.cn/problem/P8764">蓝桥杯 2021 国 BC] 二进制问题 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>小蓝最近在学习二进制。他想知道 1 到 N 中有多少个数满足其二进制表示中恰好有 K 个 <code>1</code>。你能帮助他吗?</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入一行包含两个整数 N 和 K。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数表示答案。</p><h3 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h3><p>输入 #1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7 2</span><br></pre></td></tr></table></figure><p>输出 #1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p>###说明&#x2F;提示</p><p>对于 30% 的评测用例, 1≤N≤106,1≤K≤10 。</p><p>对于60% 的评测用例, 1≤N≤2×109,1≤K≤30 。</p><p>对于所有评测用例,1≤N≤1018,1≤K≤50 。</p><p>蓝桥杯 2021 国赛 B 组 H 题（C 组 J 题）。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>参考：<a href="https://blog.csdn.net/qq_46117575/article/details/125081583">蓝桥杯2021年第十二届国赛真题-二进制问题_Nie同学的博客-CSDN博客_蓝桥杯国赛题目</a></p><p>非常明显这道题目是典型的数位DP的题目，题干说到在某个区间，求满足某种条件的数的个数，即这道题可以用数位DP过掉，再分析一下时间复杂度，其数据范围在10 ^18<br> 上，从这里可以推断出时间复杂度大概率应该控制在O(log(n))，此时数位DP正好可以将此题AC掉！还需注意的一点是此题会爆int，应该用long。</p><p>首先分析一下此题的数位DP的逻辑，如下图所示：<br><img src="C:\Users\30279\Desktop\个人acm题解\分散题解\二进制问题，dp逻辑.png" alt="二进制问题，dp逻辑" style="zoom:50%;" /></p><p>先预处理一下组合数，根据递推式：<br><img src="C:\Users\30279\Desktop\个人acm题解\分散题解\二进制问题，组合数求解.png" alt="二进制问题，组合数求解" style="zoom:50%;" /></p><h2 id="个人理解："><a href="#个人理解：" class="headerlink" title="个人理解："></a>个人理解：</h2><h3 id="内容"><a href="#内容" class="headerlink" title="内容:"></a>内容:</h3><p>运用数位dp，从高位到低位，若当前位选0，小的位可以选k-已选1的个数；若当前位选1，则已选1的个数++；</p><p>数组记录答案。</p><h3 id="数位dp"><a href="#数位dp" class="headerlink" title="数位dp"></a>数位dp</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;<span class="comment">//记载答案</span></span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;<span class="comment">//记载已选1的个数</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;ve;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;<span class="comment">//变位二进制位</span></span><br><span class="line">        ve.<span class="built_in">emplace_back</span>(n%<span class="number">2</span>);</span><br><span class="line">        n/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=ve.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ve[i])&#123;</span><br><span class="line">            ans+=f[i][k-cnt];<span class="comment">//左树已经预处理过</span></span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span>(cnt&gt;k)<span class="keyword">break</span>;<span class="comment">//用1太多了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;cnt==k)ans++;<span class="comment">//别漏情况</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> f[<span class="number">100</span>][<span class="number">100</span>];<span class="comment">//要开long long</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">60</span>;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=i;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!j)f[i][j]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> f[i][j]=f[i<span class="number">-1</span>][j<span class="number">-1</span>]+f[i<span class="number">-1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总体代码："><a href="#总体代码：" class="headerlink" title="总体代码："></a>总体代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> f[<span class="number">100</span>][<span class="number">100</span>];<span class="comment">//要开long long</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">60</span>;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=i;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!j)f[i][j]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> f[i][j]=f[i<span class="number">-1</span>][j<span class="number">-1</span>]+f[i<span class="number">-1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;<span class="comment">//记载答案</span></span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;<span class="comment">//记载已选1的个数</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;ve;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;<span class="comment">//变位二进制位</span></span><br><span class="line">        ve.<span class="built_in">emplace_back</span>(n%<span class="number">2</span>);</span><br><span class="line">        n/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=ve.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ve[i])&#123;</span><br><span class="line">            ans+=f[i][k-cnt];<span class="comment">//左树已经预处理过</span></span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span>(cnt&gt;k)<span class="keyword">break</span>;<span class="comment">//用1太多了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;cnt==k)ans++;<span class="comment">//别漏情况</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//数位DP</span></span><br><span class="line">    <span class="type">int</span> n,k;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    cout&lt;&lt;<span class="built_in">dp</span>(n,k)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h2 id="数位DP"><a href="#数位DP" class="headerlink" title="数位DP"></a>数位DP</h2><h3 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h3><p><a href="https://blog.csdn.net/hzf0701/article/details/116717851">数位DP学习整理（数位DP看完这篇你就会了）_unique_pursuit的博客-CSDN博客_数位dp</a></p><p><a href="https://oi-wiki.org/dp/number/">数位 DP - OI Wiki (oi-wiki.org)</a></p><h3 id="适用情况："><a href="#适用情况：" class="headerlink" title="适用情况："></a>适用情况：</h3><p>一般具有这几个特征：</p><ol><li>要求统计满足一定条件的数的数量（即，最终目的为计数）；</li><li>这些条件经过转化后可以使用「数位」的思想去理解和判断；</li><li>输入会提供一个数字区间（有时也只提供上界）来作为统计的限制；</li><li>上界很大（比如 ），暴力枚举验证会超时。</li></ol><h3 id="基本思路："><a href="#基本思路：" class="headerlink" title="基本思路："></a>基本思路：</h3><p>考虑人类计数的方式，最朴素的计数就是从小到大开始依次加一。但我们发现对于位数比较多的数，这样的过程中有许多重复的部分。例如，从 7000 数到 7999、从 8000 数到 8999、和从 9000 数到 9999 的过程非常相似，它们都是后三位从 000 变到 999，不一样的地方只有千位这一位，所以我们可以把这些过程归并起来，将这些过程中产生的计数答案也都存在一个通用的数组里。<strong>此数组根据题目具体要求设置状态，用递推或 DP 的方式进行状态转移。</strong></p><p>数位 DP 中<strong>通常会利用常规计数问题技巧</strong>，比如把一个区间内的答案拆成两部分相减（即 </p><img src="C:\Users\30279\Desktop\个人acm题解\分散题解\数位dp1.png" alt="数位dp1" style="zoom:150%;" /><p>那么有了通用答案数组，接下来就是统计答案。<strong>统计答案可以选择记忆化搜索，也可以选择循环迭代递推。</strong>为了不重不漏地统计所有不超过上限的答案，<strong>要从高到低枚举每一位，再考虑每一位都可以填哪些数字，最后利用通用答案数组统计答案。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统八股文</title>
      <link href="/2024/05/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%AB%E8%82%A1%E6%96%87/"/>
      <url>/2024/05/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%AB%E8%82%A1%E6%96%87/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h4 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h4><p>进程是系统中正在运行的一个程序，程序一旦运行就是进程。</p><p>进程可以看成程序执行的一个实例。进程是系统资源分配的独立实体，每个进程都拥有独立的地址空间。一个进程无法访问另一个进程的变量和数据结构，如果想让一个进程访问另一个进程的资源，需要使用进程间通信，比如管道，文件，套接字等。</p><h4 id="为什么需要进程"><a href="#为什么需要进程" class="headerlink" title="为什么需要进程"></a>为什么需要进程</h4><p><img src="C:\Users\21016\AppData\Roaming\Typora\typora-user-images\image-20230127180753524.png" alt="image-20230127180753524"></p><h4 id="同步-异步-阻塞-非阻塞"><a href="#同步-异步-阻塞-非阻塞" class="headerlink" title="同步 异步 阻塞 非阻塞"></a>同步 异步 阻塞 非阻塞</h4><p>同步，异步，是指两个线程之间的关系，如果线程A对线程B发起请求，A要一直到等B的结果返回了才能继续往下运行，A和B就是同步关系。</p><p>如果线程A对线程B发起请求之后，不在原地等结果，直接干别的事情去了，等B有结果了再通知A，A和B的关系就是异步关系。</p><p>阻塞，非阻塞，是指单个线程的状态，如果线程A对线程B发起请求，A线程要等B线程的结果，A在等的过程中不干别的，线程挂起，休眠，就是阻塞状态；如果A线程不用等B的结果，直接干别的去了，那么就是非阻塞状态。</p><p><img src="C:\Users\21016\AppData\Roaming\Typora\typora-user-images\image-20230127202458397.png" alt="image-20230127202458397"></p><h2 id="1、进程、线程和协程的区别和联系"><a href="#1、进程、线程和协程的区别和联系" class="headerlink" title="1、进程、线程和协程的区别和联系"></a>1、进程、线程和协程的区别和联系</h2><table><thead><tr><th></th><th>进程</th><th>线程</th><th>协程</th></tr></thead><tbody><tr><td>定义</td><td>资源分配和拥有的基本单位</td><td>程序执行的基本单位</td><td>用户态的轻量级线程，线程内部调度的基本单位</td></tr><tr><td>切换情况</td><td>进程CPU环境(栈、寄存器、页表和文件句柄等)的保存以及新调度的进程CPU环境的设置</td><td>保存和设置程序计数器、少量寄存器和栈的内容</td><td>先将寄存器上下文和栈保存，等切换回来的时候再进行恢复</td></tr><tr><td>切换者</td><td>操作系统</td><td>操作系统</td><td>用户</td></tr><tr><td>切换过程</td><td>用户态-&gt;内核态-&gt;用户态</td><td>用户态-&gt;内核态-&gt;用户态</td><td>用户态(没有陷入内核)</td></tr><tr><td>调用栈</td><td>内核栈</td><td>内核栈</td><td>用户栈</td></tr><tr><td>拥有资源</td><td>CPU资源、内存资源、文件资源和句柄等</td><td>程序计数器、寄存器、栈和状态字</td><td>拥有自己的寄存器上下文和栈</td></tr><tr><td>并发性</td><td>不同进程之间切换实现并发，各自占有CPU实现并行</td><td>一个进程内部的多个线程并发执行</td><td>同一时间只能执行一个协程，而其他协程处于休眠状态，适合对任务进行分时处理</td></tr><tr><td>系统开销</td><td>切换虚拟地址空间，切换内核栈和硬件上下文，CPU高速缓存失效、页表切换，开销很大</td><td>切换时只需保存和设置少量寄存器内容，因此开销很小</td><td>直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快</td></tr><tr><td>通信方面</td><td>进程间通信需要借助操作系统</td><td>线程间可以直接读写进程数据段(如全局变量)来进行通信</td><td>共享内存、消息队列</td></tr></tbody></table><p>1、进程是资源调度的基本单位，运行一个可执行程序会创建一个或多个进程，进程就是运行起来的可执行程序</p><p>2、线程是程序执行的基本单位，是轻量级的进程。每个进程中都有唯一的主线程，且只能有一个，主线程和进程是相互依存的关系，主线程结束进程也会结束。多提一句：协程是用户态的轻量级线程，线程内部调度的基本单位</p><p>线程具有许多传统进程所具有的特征，故又称为轻型进程(Light—Weight Process)或进程元；而把传统的进程称为重型进程(Heavy—Weight Process)，它相当于只有一个线程的任务。在引入了线程的操作系统中，通常一个进程都有若干个线程，至少包含一个线程。</p><p>根本区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位</p><p>资源开销：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</p><p>包含关系：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</p><p>内存分配：同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的</p><p>影响关系：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</p><p>执行过程：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行</p><h2 id="2、线程与进程的比较"><a href="#2、线程与进程的比较" class="headerlink" title="#2、线程与进程的比较"></a><a href="https://interviewguide.cn/notes/03-hunting_job/02-interview/02-01-os.html#_2%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%AF%94%E8%BE%83">#</a>2、线程与进程的比较</h2><p>1、线程启动速度快，轻量级</p><p>2、线程的系统开销小</p><p>3、线程使用有一定难度，需要处理数据一致性问题</p><p>4、同一线程共享的有堆、全局变量、静态变量、指针，引用、文件等，而独自占有栈</p><h2 id="2-2、补充另一种问法"><a href="#2-2、补充另一种问法" class="headerlink" title="#2.2、补充另一种问法"></a><a href="https://interviewguide.cn/notes/03-hunting_job/02-interview/02-01-os.html#_2-2%E3%80%81%E8%A1%A5%E5%85%85%E5%8F%A6%E4%B8%80%E7%A7%8D%E9%97%AE%E6%B3%95">#</a>2.2、补充另一种问法</h2><p><strong>线程和进程的区别？</strong></p><ul><li>调度：线程是调度的基本单位（PC，状态码，通用寄存器，线程栈及栈指针）；进程是拥有资源的基本单位（打开文件，堆，静态区，代码段等）。</li><li>并发性：一个进程内多个线程可以并发（最好和CPU核数相等）；多个进程可以并发。</li><li>拥有资源：线程不拥有系统资源，但一个进程的多个线程可以共享隶属进程的资源；进程是拥有资源的独立单位。</li><li>系统开销：线程创建销毁只需要处理PC值，状态码，通用寄存器值，线程栈及栈指针即可；进程创建和销毁需要重新分配及销毁task_struct结构。</li></ul><h2 id="3、一个进程可以创建多少线程，和什么有关？"><a href="#3、一个进程可以创建多少线程，和什么有关？" class="headerlink" title="#3、一个进程可以创建多少线程，和什么有关？"></a><a href="https://interviewguide.cn/notes/03-hunting_job/02-interview/02-01-os.html#_3%E3%80%81%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%8F%AF%E4%BB%A5%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%B0%91%E7%BA%BF%E7%A8%8B-%E5%92%8C%E4%BB%80%E4%B9%88%E6%9C%89%E5%85%B3">#</a>3、一个进程可以创建多少线程，和什么有关？</h2><p>这个要分不同系统去看：</p><ul><li>如果是32 位系统，用户态的虚拟空间只有 3G，如果创建线程时分配的栈空间是 10M，那么一个进程最多只能创建 300 个左右的线程。</li><li>如果是64 位系统，用户态的虚拟空间大到有 128T，理论上不会受虚拟内存大小的限制，而会受系统的参数或性能限制。</li></ul><p>顺便多说一句，过多的线程将会导致大量的时间浪费在线程切换上，给程序运行效率带来负面影响，无用线程要及时销毁</p><h3 id="用户态的应用程序可以通过三种方式来访问内核态的资源："><a href="#用户态的应用程序可以通过三种方式来访问内核态的资源：" class="headerlink" title="用户态的应用程序可以通过三种方式来访问内核态的资源："></a>用户态的应用程序可以通过三种方式来访问内核态的资源：</h3><ul><li>1）系统调用</li><li>2）库函数</li><li>3）Shell脚本</li></ul><h2 id="从用户态到内核态切换可以通过三种方式："><a href="#从用户态到内核态切换可以通过三种方式：" class="headerlink" title="从用户态到内核态切换可以通过三种方式："></a>从用户态到内核态切换可以通过三种方式：</h2><p><strong>系统调用</strong>：其实系统调用本身就是中断，但是软件中断，跟硬中断不同。<br><strong>异常中断</strong>： 当CPU正在执行运行在用户态的程序时，突然发生某些预先不可知的异常事件，这个时候就会触发从当前用户态执行的进程转向内核态执行相关的异常事件，典型的如缺页异常。<br><strong>外围设备中断</strong>：当外围设备完成用户的请求操作后，会像CPU发出中断信号，此时，CPU就会暂停执行下一条即将要执行的指令，转而去执行中断信号对应的处理程序，如果先前执行的指令是在用户态下，则自然就发生从用户态到内核态的转换。</p><h2 id="虚拟技术你了解吗？"><a href="#虚拟技术你了解吗？" class="headerlink" title="虚拟技术你了解吗？"></a>虚拟技术你了解吗？</h2><p>虚拟技术把一个物理实体转换为多个逻辑实体。</p><p>主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。</p><p>多进程与多线程：多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。</p><p>虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。</p><h2 id="Linux下进程间通信方式？"><a href="#Linux下进程间通信方式？" class="headerlink" title="Linux下进程间通信方式？"></a>Linux下进程间通信方式？</h2><ul><li>管道：<ul><li>无名管道（内存文件）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程之间使用。进程的亲缘关系通常是指父子进程关系。</li><li>有名管道（FIFO文件，借助文件系统）：有名管道也是半双工的通信方式，但是允许在没有亲缘关系的进程之间使用，管道是先进先出的通信方式。</li></ul></li><li>共享内存：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的IPC方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与信号量，配合使用来实现进程间的同步和通信。</li><li>消息队列：消息队列是有消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li><li>套接字：适用于不同机器间进程通信，在本地也可作为两个进程通信的方式。</li><li>信号：用于通知接收进程某个事件已经发生，比如按下ctrl + C就是信号。</li><li>信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，实现进程、线程的对临界区的同步及互斥访问。</li></ul><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p><strong>两个线程都在等待对方释放锁</strong>，死锁只有<strong>同时满足</strong>以下四个条件才会发生：</p><ul><li><strong>互斥条件</strong>：进程对所需求的资源具有排他性，若有其他进程请求该资源，请求进程只能等待。</li><li><strong>不剥夺条件</strong>：进程在所获得的资源未释放前，不能被其他进程强行夺走，只能自己释放。</li><li><strong>请求和保持条件</strong>：进程当前所拥有的资源在进程请求其他新资源时，由该进程继续占有。</li><li><strong>循环等待条件</strong>：存在一种进程资源循环等待链，链中每个进程已获得的资源同时被链中下一个进程所请求。</li></ul><h2 id="孤儿进程，僵尸进程-及解决方法-，守护进程讲解"><a href="#孤儿进程，僵尸进程-及解决方法-，守护进程讲解" class="headerlink" title="孤儿进程，僵尸进程(及解决方法)，守护进程讲解"></a>孤儿进程，僵尸进程(及解决方法)，守护进程讲解</h2><p>孤儿进程：</p><p>父进程如果不等待子进程退出，在子进程之前就结束了自己的“生命”此时的子进程叫做孤儿进程。&#x3D;&#x3D;&#x3D;&#x3D;爹没了。<br>Linux避免系统存在过多的孤儿进程，init进程收留孤儿进程，变成孤儿进程的父进程。&#x3D;&#x3D;&#x3D;&#x3D;init养父</p><p>僵尸进程：</p><p>创建子进程后，子进程退出状态不被收集，变成僵尸进程。爹不要它了<br>除非爹死后变孤儿init养父接收。如果父进程是死循环，那么该僵尸进程就变成游魂野鬼消耗空间。</p><p>守护进程：</p><p>守护进程（Daemon）是在一类脱离终端在后台执行的程序, 通常以 d 结尾, 随系统启动, 其父进程 (ppid) 通常是init 进程。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络八股文</title>
      <link href="/2024/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB%E8%82%A1%E6%96%87/"/>
      <url>/2024/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB%E8%82%A1%E6%96%87/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><p>OSI七层模型：                                                                 TCP&#x2F;IP四层模型：</p><p>应用层：为计算机用户提供接口和服务</p><p>表示层：数据处理（编码解码，加密解密等）</p><p>会话层：管理（建立，维护，重连）通信会话                      应用层HTTP  FTP</p><p>传输层：管理端到端的通信连接                                             传输层TCP UDP</p><p>网络层：数据路由（决定数据在网络中的路径）  网络层IP ICMP</p><p>数据链路层：管理相邻节点之间的数据通信                         </p><p>物理层：数据通信的光电物理特性                                         网络接口层Ethernet ARP RARP</p><img src="C:\Users\21016\AppData\Roaming\Typora\typora-user-images\image-20230125175002251.png" alt="image-20230125175002251" style="zoom:50%;" /><img src="C:\Users\21016\AppData\Roaming\Typora\typora-user-images\image-20230125175206133.png" alt="image-20230125175206133" style="zoom:50%;" /><img src="C:\Users\21016\AppData\Roaming\Typora\typora-user-images\image-20230125175351888.png" alt="image-20230125175351888" style="zoom:50%;" /><h4 id="HTTP-Keep-Alive："><a href="#HTTP-Keep-Alive：" class="headerlink" title="HTTP Keep-Alive："></a>HTTP Keep-Alive：</h4><p>HTTP协议的Keep-Alive意图在于短时间内连接复用，希望可以短时间内在同一个连接上进行多次请求&#x2F;响应。</p><p>普通的http连接是客户端连接上服务端，然后结束请求后，由客户端或者服务端进行http连接的关闭。下次再发送请求的时候，客户端再发起一个连接，传送数据，关闭连接。这么个流程反复。但是一旦客户端发送connection:keep-alive头给服务端，且服务端也接受这个keep-alive的话，两边对上暗号，这个连接就可以复用了，一个http处理完之后，另外一个http数据直接从这个连接走了。减少新建和断开TCP连接的消耗。</p><h4 id="HTTP-2-0特性："><a href="#HTTP-2-0特性：" class="headerlink" title="HTTP&#x2F;2.0特性："></a>HTTP&#x2F;2.0特性：</h4><img src="C:\Users\21016\AppData\Roaming\Typora\typora-user-images\image-20230126111003731.png" alt="image-20230126111003731" style="zoom:50%;" /><p><img src="C:\Users\21016\AppData\Roaming\Typora\typora-user-images\image-20230126111024286.png" alt="image-20230126111024286"></p><img src="C:\Users\21016\AppData\Roaming\Typora\typora-user-images\image-20230126111251877.png" alt="image-20230126111251877" style="zoom:50%;" /><h4 id="HTTP请求报文结构："><a href="#HTTP请求报文结构：" class="headerlink" title="HTTP请求报文结构："></a>HTTP请求报文结构：</h4><ul><li><p>请求行：Request Line     [][][请求方法] [请求地址] [HTTP版本]</p></li><li><p>请求头：Request Headers</p></li><li><p>请求体：Request Body</p></li><li><p>状态行：Status Line       [HTTP版本] [状态码] [状态解释]</p></li><li><p>响应头：Response Headers</p></li><li><p>响应体：Response Body</p></li></ul><p>GET HEAD  幂等</p><p>这里的幂等性：幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一URL的多个请求应该返回同样的结果。</p><h2 id="HTTP请求方法你知道多少？"><a href="#HTTP请求方法你知道多少？" class="headerlink" title="HTTP请求方法你知道多少？"></a>HTTP请求方法你知道多少？</h2><p>客户端发送的 <strong>请求报文</strong> 第一行为请求行，包含了方法字段。</p><p>根据 HTTP 标准，HTTP 请求可以使用多种请求方法。</p><p>HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法。</p><p>HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。</p><table><thead><tr><th align="left">序 号</th><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">GET</td><td align="left">请求指定的页面信息，并返回实体主体。</td></tr><tr><td align="left">2</td><td align="left">HEAD</td><td align="left">类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头</td></tr><tr><td align="left">3</td><td align="left">POST</td><td align="left">向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和&#x2F;或已有资源的修改。</td></tr><tr><td align="left">4</td><td align="left">PUT</td><td align="left">从客户端向服务器传送的数据取代指定的文档的内容。</td></tr><tr><td align="left">5</td><td align="left">DELETE</td><td align="left">请求服务器删除指定的页面。</td></tr><tr><td align="left">6</td><td align="left">CONNECT</td><td align="left">HTTP&#x2F;1.1 协议中预留给能够将连接改为管道方式的代理服务器。</td></tr><tr><td align="left">7</td><td align="left">OPTIONS</td><td align="left">允许客户端查看服务器的性能。</td></tr><tr><td align="left">8</td><td align="left">TRACE</td><td align="left">回显服务器收到的请求，主要用于测试或诊断。</td></tr><tr><td align="left">9</td><td align="left">PATCH</td><td align="left">是对 PUT 方法的补充，用来对已知资源进行局部更新 。</td></tr></tbody></table><h2 id="GET-和-POST-的区别，你知道哪些？"><a href="#GET-和-POST-的区别，你知道哪些？" class="headerlink" title="GET 和 POST 的区别，你知道哪些？"></a>GET 和 POST 的区别，你知道哪些？</h2><ol><li>get是获取数据，post是修改数据</li><li>get把请求的数据放在url上， 以?分割URL和传输数据，参数之间以&amp;相连，所以get不太安全。而post把数据放在HTTP的包体内（request body 相对安全）</li><li>get提交的数据最大是2k（ 限制实际上取决于浏览器）， post理论上没有限制。</li><li>GET产生一个TCP数据包，浏览器会把http header和data一并发送出去，服务器响应200(返回数据); POST产生两个TCP数据包，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。</li><li>GET请求会被浏览器主动缓存，而POST不会，除非手动设置。</li><li>本质区别：GET是幂等的，而POST不是幂等的</li></ol><p><img src="C:\Users\21016\AppData\Roaming\Typora\typora-user-images\image-20230126133816105.png" alt="image-20230126133816105"></p><img src="C:\Users\21016\AppData\Roaming\Typora\typora-user-images\image-20230126150753793.png" alt="image-20230126150753793" style="zoom:50%;" /><ul><li>根据相同随机数1,2,3和相同算法生成对称秘钥，双方使用对称秘钥进行加密通信。</li></ul><h4 id="DNS服务"><a href="#DNS服务" class="headerlink" title="DNS服务"></a>DNS服务</h4><p><img src="C:\Users\21016\AppData\Roaming\Typora\typora-user-images\image-20230126152305199.png" alt="image-20230126152305199"></p><h4 id="DNS攻击-DNS劫持-DNS欺骗（伪权威域名服务器）-DDoS攻击（服务器宕机）"><a href="#DNS攻击-DNS劫持-DNS欺骗（伪权威域名服务器）-DDoS攻击（服务器宕机）" class="headerlink" title="DNS攻击  DNS劫持   DNS欺骗（伪权威域名服务器）    DDoS攻击（服务器宕机）"></a>DNS攻击  DNS劫持   DNS欺骗（伪权威域名服务器）    DDoS攻击（服务器宕机）</h4><h3 id="UDP的特点有哪些（附赠TCP的特点）？"><a href="#UDP的特点有哪些（附赠TCP的特点）？" class="headerlink" title="UDP的特点有哪些（附赠TCP的特点）？"></a>UDP的特点有哪些（附赠TCP的特点）？</h3><ul><li>UDP是<strong>无连接的</strong>；</li><li>UDP使用<strong>尽最大努力交付</strong>，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）；</li><li>UDP是<strong>面向报文</strong>的；</li><li>UDP<strong>没有拥塞控制</strong>，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）；</li><li>UDP<strong>支持一对一、一对多、多对一和多对多</strong>的交互通信；</li><li>UDP的<strong>首部开销小</strong>，只有8个字节，比TCP的20个字节的首部要短。</li></ul><p>那么，再说一次TCP的特点：</p><ul><li><strong>TCP是面向连接的</strong>。（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）；</li><li>每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的（<strong>一对一</strong>）；</li><li>TCP<strong>提供可靠交付的服务</strong>。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达；</li><li>TCP<strong>提供全双工通信</strong>。TCP允许通信双方的应用进程在任何时候都能发送数据。TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据；</li><li><strong>面向字节流</strong>。TCP中的“流”（stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。</li></ul><h2 id="tcp如何保证可靠传输"><a href="#tcp如何保证可靠传输" class="headerlink" title="tcp如何保证可靠传输"></a>tcp如何保证可靠传输</h2><ul><li><strong>确认和重传</strong>：接收方收到报文就会确认，发送方发送一段时间后没有收到确认就会重传。</li><li><strong>数据校验</strong>：TCP报文头有校验和，用于校验报文是否损坏。</li><li><strong>数据合理分片和排序</strong>：tcp会按最大传输单元(MTU)合理分片，接收方会缓存未按序到达的数据，重新排序后交给应用层。而UDP：IP数据报大于1500字节，大于MTU。这个时候发送方的IP层就需要分片，把数据报分成若干片，是的每一片都小于MTU。而接收方IP层则需要进行数据报的重组。由于UDP的特性，某一片数据丢失时，接收方便无法重组数据报，导致丢弃整个UDP数据报。</li><li><strong>流量控制</strong>：当接收方来不及处理发送方的数据，能通过滑动窗口，提示发送方降低发送的速率，防止包丢失。</li><li><strong>拥塞控制</strong>：当网络拥塞时，通过拥塞窗口，减少数据的发送，防止包丢失。</li></ul><h2 id="55、三次握手相关内容"><a href="#55、三次握手相关内容" class="headerlink" title="55、三次握手相关内容"></a>55、三次握手相关内容</h2><p><img src="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205072301822.png" alt="img"></p><p>三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换<code>TCP窗口大小</code>信息。</p><h3 id="第0种回答"><a href="#第0种回答" class="headerlink" title="第0种回答"></a>第0种回答</h3><ul><li>一开始，客户端和服务端都处于 <code>CLOSED</code> 状态。先是服务端主动监听某个端口，处于 <code>LISTEN</code> 状态。</li><li>然后客户端主动发起连接 <code>SYN</code>，之后处于 <code>SYN-SENT</code> 状态。</li><li>服务端收到发起的连接，返回 <code>SYN</code>，并且 <code>ACK</code> 客户端的 <code>SYN</code>，之后处于 <code>SYN-RCVD</code> 状态。</li><li>客户端收到服务端发送的 <code>SYN</code> 和 <code>ACK</code> 之后，发送对 <code>SYN</code> 确认的 <code>ACK</code>，之后处于 <code>ESTABLISHED</code> 状态，因为它一发一收成功了。</li><li>服务端收到 <code>ACK</code> 的 <code>ACK</code> 之后，处于 <code>ESTABLISHED</code> 状态，因为它也一发一收了。</li></ul><p>所以三次握手目的是<strong>保证双方都有发送和接收的能力</strong>。</p><h3 id="第一种回答"><a href="#第一种回答" class="headerlink" title="#第一种回答"></a><a href="https://interviewguide.cn/notes/03-hunting_job/02-interview/03-03-net.html#%E7%AC%AC%E4%B8%80%E7%A7%8D%E5%9B%9E%E7%AD%94">#</a>第一种回答</h3><p>刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态，进行三次握手：</p><ul><li><p>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 <code>SYN_SEND</code> 状态。</p><p>首部的同步位SYN&#x3D;1，初始序号seq&#x3D;x，SYN&#x3D;1的报文段不能携带数据，但要消耗掉一个序号。</p></li><li><p>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 <code>SYN_RCVD</code> 的状态。</p><p>在确认报文段中SYN&#x3D;1，ACK&#x3D;1，确认号ack&#x3D;x+1，初始序号seq&#x3D;y。</p></li><li><p>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 <code>ESTABLISHED</code> 状态。服务器收到 ACK 报文之后，也处于 <code>ESTABLISHED</code> 状态，此时，双方已建立起了连接。</p><p>确认报文段ACK&#x3D;1，确认号ack&#x3D;y+1，序号seq&#x3D;x+1（初始为seq&#x3D;x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。</p></li></ul><p>发送第一个SYN的一端将执行主动打开（active open），接收这个SYN并发回下一个SYN的另一端执行被动打开（passive open）。</p><p>在socket编程中，客户端执行connect()时，将触发三次握手。</p><h3 id="第二种回答"><a href="#第二种回答" class="headerlink" title="#第二种回答"></a><a href="https://interviewguide.cn/notes/03-hunting_job/02-interview/03-03-net.html#%E7%AC%AC%E4%BA%8C%E7%A7%8D%E5%9B%9E%E7%AD%94">#</a>第二种回答</h3><ul><li><strong>初始状态</strong>：客户端处于 <code>closed(关闭)</code>状态，服务器处于 <code>listen(监听)</code> 状态。</li><li><strong>第一次握手</strong>：客户端发送请求报文将 <code>SYN = 1</code>同步序列号和初始化序列号<code>seq = x</code>发送给服务端，发送完之后客户端处于<code>SYN_Send</code>状态。（验证了客户端的发送能力和服务端的接收能力）</li><li><strong>第二次握手</strong>：服务端受到 <code>SYN</code> 请求报文之后，如果同意连接，会以自己的同步序列号<code>SYN(服务端) = 1</code>、初始化序列号 <code>seq = y</code>和确认序列号（期望下次收到的数据包）<code>ack = x+ 1</code> 以及确认号<code>ACK = 1</code>报文作为应答，服务器为<code>SYN_Receive</code>状态。（问题来了，两次握手之后，站在客户端角度上思考：我发送和接收都ok，服务端的发送和接收也都ok。但是站在服务端的角度思考：哎呀，我服务端接收ok，但是我不清楚我的发送ok不ok呀，而且我还不知道你接受能力如何呢？所以老哥，你需要给我三次握手来传个话告诉我一声。你要是不告诉我，万一我认为你跑了，然后我可能出于安全性的考虑继续给你发一次，看看你回不回我。）</li><li><strong>第三次握手</strong>： 客户端接收到服务端的 <code>SYN + ACK</code>之后，知道可以下次可以发送了下一序列的数据包了，然后发送同步序列号 <code>ack = y + 1</code>和数据包的序列号 <code>seq = x + 1</code>以及确认号<code>ACK = 1</code>确认包作为应答，客户端转为<code>established</code>状态。（分别站在双方的角度上思考，各自ok）</li></ul><h2 id="56、为什么需要三次握手，两次不行吗？"><a href="#56、为什么需要三次握手，两次不行吗？" class="headerlink" title="#56、为什么需要三次握手，两次不行吗？"></a><a href="https://interviewguide.cn/notes/03-hunting_job/02-interview/03-03-net.html#_56%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-%E4%B8%A4%E6%AC%A1%E4%B8%8D%E8%A1%8C%E5%90%97">#</a>56、为什么需要三次握手，两次不行吗？</h2><p>弄清这个问题，我们需要先弄明白三次握手的目的是什么，能不能只用两次握手来达到同样的目的。</p><ul><li>第一次握手：客户端发送网络包，服务端收到了。 这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</li><li>第二次握手：服务端发包，客户端收到了。 这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。</li><li>第三次握手：客户端发包，服务端收到了。 这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</li></ul><p>因此，需要三次握手才能确认双方的接收与发送能力是否正常。</p><p>试想如果是用两次握手，则会出现下面这种情况：</p><blockquote><p>如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在<strong>某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端</strong>，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。</p></blockquote><img src="C:\Users\21016\AppData\Roaming\Typora\typora-user-images\image-20230127102826836.png" alt="image-20230127102826836" style="zoom:50%;" /><img src="C:\Users\21016\AppData\Roaming\Typora\typora-user-images\image-20230127102904598.png" alt="image-20230127102904598" style="zoom:50%;" /><h3 id="第二种回答-1"><a href="#第二种回答-1" class="headerlink" title="第二种回答"></a>第二种回答</h3><ul><li><strong>初始化状态</strong>：客户端和服务端都在连接状态，接下来开始进行四次分手断开连接操作。</li><li><strong>第一次分手</strong>：第一次分手无论是客户端还是服务端都可以发起，因为 TCP 是全双工的。</li></ul><blockquote><p>假如客户端发送的数据已经发送完毕，发送FIN &#x3D; 1 <strong>告诉服务端，客户端所有数据已经全发完了</strong>，<strong>服务端你可以关闭接收了</strong>，但是如果你们服务端有数据要发给客户端，客户端照样可以接收的。此时客户端处于FIN &#x3D; 1等待服务端确认释放连接状态。</p></blockquote><ul><li><strong>第二次分手</strong>：服务端接收到客户端的释放请求连接之后，<strong>知道客户端没有数据要发给自己了</strong>，<strong>然后服务端发送ACK &#x3D; 1告诉客户端收到你发给我的信息</strong>，此时服务端处于 CLOSE_WAIT 等待关闭状态。（服务端先回应给客户端一声，我知道了，但服务端的发送数据能力即将等待关闭，于是接下来第三次就来了。）</li><li><strong>第三次分手</strong>：此时服务端向客户端把所有的数据发送完了，然后发送一个FIN &#x3D; 1，<strong>用于告诉客户端，服务端的所有数据发送完毕</strong>，<strong>客户端你也可以关闭接收数据连接了</strong>。此时服务端状态处于LAST_ACK状态，来等待确认客户端是否收到了自己的请求。（服务端等客户端回复是否收到呢，不收到的话，服务端不知道客户端是不是挂掉了还是咋回事呢，所以服务端不敢关闭自己的接收能力，于是第四次就来了。）</li><li><strong>第四次分手</strong>：此时如果客户端收到了服务端发送完的信息之后，就发送ACK &#x3D; 1，告诉服务端，客户端已经收到了你的信息。<strong>有一个 2 MSL 的延迟等待</strong>。</li></ul><h2 id="62、挥手为什么需要四次？"><a href="#62、挥手为什么需要四次？" class="headerlink" title="#62、挥手为什么需要四次？"></a><a href="https://interviewguide.cn/notes/03-hunting_job/02-interview/03-04-net.html#_62%E3%80%81%E6%8C%A5%E6%89%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%9B%9B%E6%AC%A1">#</a>62、挥手为什么需要四次？</h2><h3 id="第一种回答-1"><a href="#第一种回答-1" class="headerlink" title="#第一种回答"></a><a href="https://interviewguide.cn/notes/03-hunting_job/02-interview/03-04-net.html#%E7%AC%AC%E4%B8%80%E7%A7%8D%E5%9B%9E%E7%AD%94-2">#</a>第一种回答</h3><p>因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中<strong>ACK报文是用来应答的，SYN报文是用来同步的</strong>。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，”你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。</p><h3 id="第二种回答-2"><a href="#第二种回答-2" class="headerlink" title="#第二种回答"></a><a href="https://interviewguide.cn/notes/03-hunting_job/02-interview/03-04-net.html#%E7%AC%AC%E4%BA%8C%E7%A7%8D%E5%9B%9E%E7%AD%94-2">#</a>第二种回答</h3><p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。</p><h2 id="63、2MSL等待状态？"><a href="#63、2MSL等待状态？" class="headerlink" title="#63、2MSL等待状态？"></a><a href="https://interviewguide.cn/notes/03-hunting_job/02-interview/03-04-net.html#_63%E3%80%812msl%E7%AD%89%E5%BE%85%E7%8A%B6%E6%80%81">#</a>63、2MSL等待状态？</h2><p>TIME_WAIT状态也成为2MSL等待状态。每个具体TCP实现必须选择一个报文段最大生存时间MSL（Maximum Segment Lifetime），它是任何报文段被丢弃前在网络内的最长时间。这个时间是有限的，因为TCP报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段。</p><p>对一个具体实现所给定的MSL值，处理的原则是：当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在TIME_WAIT状态停留的时间为2倍的MSL。这样可让TCP再次发送最后的ACK以防这个ACK丢失（另一端超时并重发最后的FIN）。</p><p>这种2MSL等待的另一个结果是这个TCP连接在2MSL等待期间，定义这个连接的插口（客户的IP地址和端口号，服务器的IP地址和端口号）不能再被使用。这个连接只能在2MSL结束后才能再被使用。</p><h2 id="64、四次挥手释放连接时，等待2MSL的意义"><a href="#64、四次挥手释放连接时，等待2MSL的意义" class="headerlink" title="#64、四次挥手释放连接时，等待2MSL的意义?"></a><a href="https://interviewguide.cn/notes/03-hunting_job/02-interview/03-04-net.html#_64%E3%80%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E9%87%8A%E6%94%BE%E8%BF%9E%E6%8E%A5%E6%97%B6-%E7%AD%89%E5%BE%852msl%E7%9A%84%E6%84%8F%E4%B9%89">#</a>64、四次挥手释放连接时，等待2MSL的意义?</h2><blockquote><p><strong>MSL</strong>是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p></blockquote><p>为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。</p><h3 id="两个理由"><a href="#两个理由" class="headerlink" title="#两个理由"></a><a href="https://interviewguide.cn/notes/03-hunting_job/02-interview/03-04-net.html#%E4%B8%A4%E4%B8%AA%E7%90%86%E7%94%B1">#</a>两个理由</h3><ol><li>保证客户端发送的最后一个ACK报文段能够到达服务端。 这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，服务端超时重传FIN+ACK报文段，而客户端能在2MSL时间内收到这个重传的FIN+ACK报文段，接着客户端重传一次确认，重新启动2MSL计时器，最后客户端和服务端都进入到CLOSED状态，若客户端在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到服务端重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则服务端无法正常进入到CLOSED状态。</li><li>防止“已失效的连接请求报文段”出现在本连接中。 客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。</li></ol><h2 id="65、为什么TIME-WAIT状态需要经过2MSL才能返回到CLOSE状态？"><a href="#65、为什么TIME-WAIT状态需要经过2MSL才能返回到CLOSE状态？" class="headerlink" title="#65、为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？"></a><a href="https://interviewguide.cn/notes/03-hunting_job/02-interview/03-04-net.html#_65%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88time-wait%E7%8A%B6%E6%80%81%E9%9C%80%E8%A6%81%E7%BB%8F%E8%BF%872msl%E6%89%8D%E8%83%BD%E8%BF%94%E5%9B%9E%E5%88%B0close%E7%8A%B6%E6%80%81">#</a>65、为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？</h2><h3 id="第一种回答-2"><a href="#第一种回答-2" class="headerlink" title="#第一种回答"></a><a href="https://interviewguide.cn/notes/03-hunting_job/02-interview/03-04-net.html#%E7%AC%AC%E4%B8%80%E7%A7%8D%E5%9B%9E%E7%AD%94-3">#</a>第一种回答</h3><p>理论上，四个报文都发送完毕，就可以直接进入CLOSE状态了，但是可能网络是不可靠的，有可能最后一个ACK丢失。所以<strong>TIME_WAIT状态就是用来重发可能丢失的ACK报文</strong>。</p><h3 id="第二种回答-3"><a href="#第二种回答-3" class="headerlink" title="#第二种回答"></a><a href="https://interviewguide.cn/notes/03-hunting_job/02-interview/03-04-net.html#%E7%AC%AC%E4%BA%8C%E7%A7%8D%E5%9B%9E%E7%AD%94-3">#</a>第二种回答</h3><p>对应这样一种情况，最后客户端发送的ACK &#x3D; 1给服务端的<strong>过程中丢失</strong>了，服务端没收到，服务端怎么认为的？我已经发送完数据了，怎么客户端没回应我？是不是中途丢失了？然后服务端再次发起断开连接的请求，一个来回就是2MSL。</p><p>客户端给服务端发送的ACK &#x3D; 1丢失，<strong>服务端等待 1MSL没收到</strong>，<strong>然后重新发送消息需要1MSL</strong>。如果再次接收到服务端的消息，则<strong>重启2MSL计时器</strong>，<strong>发送确认请求</strong>。客户端只需等待2MSL，如果没有再次收到服务端的消息，就说明服务端已经接收到自己确认消息；此时双方都关闭的连接，TCP 四次分手完毕</p><h3 id="TCP如何保证可靠传输"><a href="#TCP如何保证可靠传输" class="headerlink" title="TCP如何保证可靠传输"></a>TCP如何保证可靠传输</h3><p>‘停止等待协议     累计确认   滑动窗口</p><ul><li><strong>确认和重传</strong>：接收方收到报文就会确认，发送方发送一段时间后没有收到确认就会重传。</li><li><strong>数据校验</strong>：TCP报文头有校验和，用于校验报文是否损坏。</li><li><strong>数据合理分片和排序</strong>：tcp会按最大传输单元(MTU)合理分片，接收方会缓存未按序到达的数据，重新排序后交给应用层。而UDP：IP数据报大于1500字节，大于MTU。这个时候发送方的IP层就需要分片，把数据报分成若干片，是的每一片都小于MTU。而接收方IP层则需要进行数据报的重组。由于UDP的特性，某一片数据丢失时，接收方便无法重组数据报，导致丢弃整个UDP数据报。</li><li><strong>流量控制</strong>：当接收方来不及处理发送方的数据，能通过滑动窗口，提示发送方降低发送的速率，防止包丢失。</li><li><strong>拥塞控制</strong>：当网络拥塞时，通过拥塞窗口，减少数据的发送，防止包丢失。</li></ul><h2 id="79、TCP四大拥塞控制算法总结？（极其重要）"><a href="#79、TCP四大拥塞控制算法总结？（极其重要）" class="headerlink" title="79、TCP四大拥塞控制算法总结？（极其重要）"></a>79、TCP四大拥塞控制算法总结？（极其重要）</h2><h3 id="四大算法"><a href="#四大算法" class="headerlink" title="#四大算法"></a><a href="https://interviewguide.cn/notes/03-hunting_job/02-interview/03-04-net.html#%E5%9B%9B%E5%A4%A7%E7%AE%97%E6%B3%95">#</a><strong>四大算法</strong></h3><p>拥塞控制主要是四个算法：1）慢启动，2）拥塞避免，3）拥塞发生，4）快速恢复。这四个算法不是一天都搞出来的，这个四算法的发展经历了很多时间，到今天都还在优化中。</p><p><img src="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220036635.png" alt="img"></p><h3 id="慢热启动算法-–-Slow-Start"><a href="#慢热启动算法-–-Slow-Start" class="headerlink" title="#慢热启动算法 – Slow Start"></a><a href="https://interviewguide.cn/notes/03-hunting_job/02-interview/03-04-net.html#%E6%85%A2%E7%83%AD%E5%90%AF%E5%8A%A8%E7%AE%97%E6%B3%95-slow-start">#</a>慢热启动算法 – Slow Start</h3><p>所谓慢启动，也就是TCP连接刚建立，一点一点地提速，试探一下网络的承受能力，以免直接扰乱了网络通道的秩序。</p><p>慢启动算法：</p><ol><li>连接建好的开始先初始化拥塞窗口cwnd大小为1，表明可以传一个MSS大小的数据。</li><li>每当收到一个ACK，cwnd大小加一，呈线性上升。</li><li>每当过了一个往返延迟时间RTT(Round-Trip Time)，cwnd大小直接翻倍，乘以2，呈指数让升。</li><li>还有一个ssthresh（slow start threshold），是一个上限，当cwnd &gt;&#x3D; ssthresh时，就会进入“拥塞避免算法”（后面会说这个算法）</li></ol><h3 id="拥塞避免算法-–-Congestion-Avoidance"><a href="#拥塞避免算法-–-Congestion-Avoidance" class="headerlink" title="#拥塞避免算法 – Congestion Avoidance"></a><a href="https://interviewguide.cn/notes/03-hunting_job/02-interview/03-04-net.html#%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D%E7%AE%97%E6%B3%95-congestion-avoidance">#</a>拥塞避免算法 – Congestion Avoidance</h3><p>如同前边说的，当拥塞窗口大小cwnd大于等于慢启动阈值ssthresh后，就进入拥塞避免算法。算法如下：</p><ol><li>收到一个ACK，则cwnd &#x3D; cwnd + 1 &#x2F; cwnd</li><li>每当过了一个往返延迟时间RTT，cwnd大小加一。</li></ol><p>过了慢启动阈值后，拥塞避免算法可以避免窗口增长过快导致窗口拥塞，而是缓慢的增加调整到网络的最佳值。</p><h3 id="拥塞发生状态时的算法"><a href="#拥塞发生状态时的算法" class="headerlink" title="#拥塞发生状态时的算法"></a><a href="https://interviewguide.cn/notes/03-hunting_job/02-interview/03-04-net.html#%E6%8B%A5%E5%A1%9E%E5%8F%91%E7%94%9F%E7%8A%B6%E6%80%81%E6%97%B6%E7%9A%84%E7%AE%97%E6%B3%95">#</a>拥塞发生状态时的算法</h3><p>一般来说，TCP拥塞控制默认认为网络丢包是由于网络拥塞导致的，所以一般的TCP拥塞控制算法以丢包为网络进入拥塞状态的信号。对于丢包有两种判定方式，一种是超时重传RTO[Retransmission Timeout]超时，另一个是收到三个重复确认ACK。</p><p>超时重传是TCP协议保证数据可靠性的一个重要机制，其原理是在发送一个数据以后就开启一个计时器，在一定时间内如果没有得到发送数据报的ACK报文，那么就重新发送数据，直到发送成功为止。</p><p>但是如果发送端接收到3个以上的重复ACK，TCP就意识到数据发生丢失，需要重传。这个机制不需要等到重传定时器超时，所以叫 做快速重传，而快速重传后没有使用慢启动算法，而是拥塞避免算法，所以这又叫做快速恢复算法。</p><p>超时重传RTO[Retransmission Timeout]超时，TCP会重传数据包。TCP认为这种情况比较糟糕，反应也比较强烈：</p><ul><li>由于发生丢包，将慢启动阈值ssthresh设置为当前cwnd的一半，即ssthresh &#x3D; cwnd &#x2F; 2.</li><li>cwnd重置为1</li><li>进入慢启动过程</li></ul><p>最为早期的TCP Tahoe算法就只使用上述处理办法，但是由于一丢包就一切重来，导致cwnd又重置为1，十分不利于网络数据的稳定传递。</p><p>所以，TCP Reno算法进行了优化。当收到三个重复确认ACK时，TCP开启快速重传Fast Retransmit算法，而不用等到RTO超时再进行重传：</p><ul><li>cwnd大小缩小为当前的一半</li><li>ssthresh设置为缩小后的cwnd大小</li><li>然后进入快速恢复算法Fast Recovery。</li></ul><p><img src="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220036573.png" alt="img"></p><h3 id="快速恢复算法-–-Fast-Recovery"><a href="#快速恢复算法-–-Fast-Recovery" class="headerlink" title="#快速恢复算法 – Fast Recovery"></a><a href="https://interviewguide.cn/notes/03-hunting_job/02-interview/03-04-net.html#%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D%E7%AE%97%E6%B3%95-fast-recovery">#</a>快速恢复算法 – Fast Recovery</h3><p>TCP Tahoe是早期的算法，所以没有快速恢复算法，而Reno算法有。在进入快速恢复之前，cwnd和ssthresh已经被更改为原有cwnd的一半。快速恢复算法的逻辑如下：</p><ul><li><p>cwnd &#x3D; cwnd + 3 <em>MSS，加3</em> MSS的原因是因为收到3个重复的ACK。</p></li><li><p>重传DACKs指定的数据包。</p></li><li><p>如果再收到DACKs，那么cwnd大小增加一。</p></li><li><p>如果收到新的ACK，表明重传的包成功了，那么退出快速恢复算法。将cwnd设置为ssthresh，然后进入拥塞避免算法。</p><p><img src="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220036984.png" alt="img"></p></li></ul><p>如图所示，第五个包发生了丢失，所以导致接收方接收到三次重复ACK，也就是ACK5。所以将ssthresh设置当当时cwnd的一半，也就是6&#x2F;2 &#x3D; 3，cwnd设置为3 + 3 &#x3D; 6。然后重传第五个包。当收到新的ACK时，也就是ACK11，则退出快速恢复阶段，将cwnd重新设置为当前的ssthresh，也就是3，然后进入拥塞避免算法阶段。</p><h2 id="80、为何快速重传是选择3次ACK？"><a href="#80、为何快速重传是选择3次ACK？" class="headerlink" title="#80、为何快速重传是选择3次ACK？"></a><a href="https://interviewguide.cn/notes/03-hunting_job/02-interview/03-04-net.html#_80%E3%80%81%E4%B8%BA%E4%BD%95%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0%E6%98%AF%E9%80%89%E6%8B%A93%E6%AC%A1ack">#</a>80、为何快速重传是选择3次ACK？</h2><p>主要的考虑还是要区分包的丢失是由于链路故障还是乱序等其他因素引发。</p><p>两次duplicated ACK时很可能是乱序造成的！三次duplicated ACK时很可能是丢包造成的！四次duplicated ACK更更更可能是丢包造成的，但是这样的响应策略太慢。丢包肯定会造成三次duplicated ACK!综上是选择收到三个重复确认时窗口减半效果最好，这是实践经验。</p><p>在没有fast retransmit &#x2F; recovery 算法之前，重传依靠发送方的retransmit timeout，就是在timeout内如果没有接收到对方的ACK，默认包丢了，发送方就重传，包的丢失原因</p><p>1）包checksum 出错</p><p>2）网络拥塞</p><p>3）网络断，包括路由重收敛，但是发送方无法判断是哪一种情况，于是采用最笨的办法，就是将自己的发送速率减半，即CWND 减为1&#x2F;2，这样的方法对2是有效的，可以缓解网络拥塞，3则无所谓，反正网络断了，无论发快发慢都会被丢；但对于1来说，丢包是因为偶尔的出错引起，一丢包就对半减速不合理。</p><p>于是有了fast retransmit 算法，基于在反向还可以接收到ACK，可以认为网络并没有断，否则也接收不到ACK，如果在timeout 时间内没有接收到&gt; 2 的duplicated ACK，则概率大事件为乱序，乱序无需重传，接收方会进行排序工作；</p><p>而如果接收到三个或三个以上的duplicated ACK，则大概率是丢包，可以逻辑推理，发送方可以接收ACK，则网络是通的，可能是1、2造成的，先不降速，重传一次，如果接收到正确的ACK，则一切OK，流速依然（包出错被丢）。</p><p>而如果依然接收到duplicated ACK，则认为是网络拥塞造成的，此时降速则比较合理。</p><h2 id="TCP粘包问题是什么？你会如何去解决它？"><a href="#TCP粘包问题是什么？你会如何去解决它？" class="headerlink" title="TCP粘包问题是什么？你会如何去解决它？"></a>TCP粘包问题是什么？你会如何去解决它？</h2><p><strong>TCP粘包</strong>是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。</p><ul><li><p>由TCP<strong>连接复用</strong>造成的粘包问题。</p></li><li><p>因为TCP默认会使用</p><p>Nagle算法</p><p>，此算法会导致粘包问题。</p><ul><li>只有上一个分组得到确认，才会发送下一个分组；</li><li>收集多个小分组，在一个确认到来时一起发送。</li></ul></li><li><p><strong>数据包过大</strong>造成的粘包问题。</p></li><li><p>流量控制，<strong>拥塞控制</strong>也可能导致粘包。</p></li><li><p><strong>接收方不及时接收缓冲区的包，造成多个包接收</strong></p></li></ul><p><strong>解决</strong>：</p><ol><li><strong>Nagle算法</strong>问题导致的，需要结合应用场景适当关闭该算法</li><li>尾部标记序列。通过特殊标识符表示数据包的边界，例如\n\r，\t，或者一些隐藏字符。</li><li>头部标记分步接收。在TCP报文的头部加上表示数据长度。</li><li>应用层发送数据时<strong>定长</strong>发送。</li></ol><h4 id="SYN-flood攻击"><a href="#SYN-flood攻击" class="headerlink" title="SYN flood攻击"></a>SYN flood攻击</h4><img src="C:\Users\21016\AppData\Roaming\Typora\typora-user-images\image-20230127155413806.png" alt="image-20230127155413806" style="zoom:50%;" /><h2 id="cookie和session"><a href="#cookie和session" class="headerlink" title="cookie和session"></a>cookie和session</h2><p>HTTP Cookie（也叫 Web Cookie或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。</p><p>Session 代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性及配置信息。</p><ul><li>作用范围不同，Cookie 保存在客户端（浏览器），Session 保存在服务器端。</li><li>存取方式的不同，Cookie 只能保存 ASCII，Session 可以存任意数据类型，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。</li><li>有效期不同，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。</li><li>隐私策略不同，Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。</li><li>存储大小不同， 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie。</li></ul><h2 id="token"><a href="#token" class="headerlink" title="token"></a>token</h2><ul><li>用户登录，成功后服务器返回Token给客户端。</li><li>客户端收到数据后保存在客户端</li><li>客户端再次访问服务器，将token放入headers中</li><li>服务器端采用filter过滤器校验。校验成功则返回请求数据，校验失败则返回错误码</li></ul><img src="C:\Users\21016\Desktop\6-五大类HTTP状态码.webp" alt="6-五大类HTTP状态码" style="zoom:50%;" /><h2 id="102、常见的HTTP状态码有哪些？"><a href="#102、常见的HTTP状态码有哪些？" class="headerlink" title="102、常见的HTTP状态码有哪些？"></a>102、常见的HTTP状态码有哪些？</h2><table><thead><tr><th>状态码</th><th>类别</th><th>含义</th></tr></thead><tbody><tr><td>1XX</td><td>Informational（信息性状态码）</td><td>接收的请求正在处理</td></tr><tr><td>2XX</td><td>Success（成功状态码）</td><td>请求正常处理完毕</td></tr><tr><td>3XX</td><td>Redirection（重定向状态码）</td><td>需要进行附加操作以完成请求</td></tr><tr><td>4XX</td><td>Client Error（客户端错误状态码）</td><td>服务器无法处理请求</td></tr><tr><td>5XX</td><td>Server Error（服务器错误状态码）</td><td>服务器处理请求出</td></tr></tbody></table><h2 id="1xx-信息"><a href="#1xx-信息" class="headerlink" title="#1xx 信息"></a><a href="https://interviewguide.cn/notes/03-hunting_job/02-interview/03-06-net.html#_1xx-%E4%BF%A1%E6%81%AF">#</a>1xx 信息</h2><p><strong>100 Continue</strong> ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</p><h2 id="2xx-成功"><a href="#2xx-成功" class="headerlink" title="#2xx 成功"></a><a href="https://interviewguide.cn/notes/03-hunting_job/02-interview/03-06-net.html#_2xx-%E6%88%90%E5%8A%9F">#</a>2xx 成功</h2><ul><li><strong>200 OK</strong></li><li><strong>204 No Content</strong> ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。</li><li><strong>206 Partial Content</strong> ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。</li></ul><h2 id="3xx-重定向"><a href="#3xx-重定向" class="headerlink" title="#3xx 重定向"></a><a href="https://interviewguide.cn/notes/03-hunting_job/02-interview/03-06-net.html#_3xx-%E9%87%8D%E5%AE%9A%E5%90%91">#</a>3xx 重定向</h2><ul><li><strong>301 Moved Permanently</strong> ：永久性重定向</li><li><strong>302 Found</strong> ：临时性重定向</li><li><strong>303 See Other</strong> ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。</li><li><strong>304 Not Modified</strong> ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。</li><li><strong>307 Temporary Redirect</strong> ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。</li></ul><h2 id="4xx-客户端错误"><a href="#4xx-客户端错误" class="headerlink" title="#4xx 客户端错误"></a><a href="https://interviewguide.cn/notes/03-hunting_job/02-interview/03-06-net.html#_4xx-%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%94%99%E8%AF%AF">#</a>4xx 客户端错误</h2><ul><li><strong>400 Bad Request</strong> ：请求报文中存在语法错误。</li><li><strong>401 Unauthorized</strong> ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。</li><li><strong>403 Forbidden</strong> ：请求被拒绝。</li><li><strong>404 Not Found</strong></li></ul><h2 id="5xx-服务器错误"><a href="#5xx-服务器错误" class="headerlink" title="#5xx 服务器错误"></a><a href="https://interviewguide.cn/notes/03-hunting_job/02-interview/03-06-net.html#_5xx-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%94%99%E8%AF%AF">#</a>5xx 服务器错误</h2><ul><li><strong>500 Internal Server Error</strong> ：服务器正在执行请求时发生错误。</li><li><strong>503 Service Unavailable</strong> ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</li></ul><p>岗位职责</p><p>- 负责中台能力需求方案设计和实现 - 负责服务质量、稳定性建设，从工具等方面提升团队开发效率 - 主要语言为PHP、Golang</p><p>岗位要求</p><p>- 计算机及相关专业的在校学生(本科以上)优先，连续实习6个月以上 - 具备扎实的计算机基础，熟悉linux&#x2F;shell，掌握常用数据结构／算法／设计模式，至少深入理解一门编程语言：PHP、Golang - 掌握服务端主流技术：缓存、消息队列、负载均衡、分布式存储、分布式事务等 - 良好的代码设计能力和编码风格，热爱写代码 - 逻辑思维和责任感强，有良好的沟通、协调、抗压能力，善于理解和学习，务实自驱，乐于接受新事物 - 具有良好的沟通能力，具备合作精神，能够迅速融入团队 实习生要求2024年毕业，最少实习时间6个月</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游客安排</title>
      <link href="/2024/05/16/%E6%B8%B8%E5%AE%A2%E5%AE%89%E6%8E%92/"/>
      <url>/2024/05/16/%E6%B8%B8%E5%AE%A2%E5%AE%89%E6%8E%92/</url>
      
        <content type="html"><![CDATA[<h1 id="游客安排"><a href="#游客安排" class="headerlink" title="游客安排"></a>游客安排</h1><p>涉及知识点：（最长上升子序列+动态规划+二分贪心）</p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>题目链接：[P8736 <a href="https://www.luogu.com.cn/problem/P8736">蓝桥杯 2020 国 B] 游园安排 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p>L 星球游乐园非常有趣，吸引着各个星球的游客前来游玩。小蓝是 L 星球 游乐园的管理员。</p><p>为了更好的管理游乐园，游乐园要求所有的游客提前预约，小蓝能看到系统上所有预约游客的名字。每个游客的名字由一个大写英文字母开始，后面跟 0 个或多个小写英文字母。游客可能重名。</p><p>小蓝特别喜欢递增的事物。今天，他决定在所有预约的游客中，选择一部分游客在上午游玩，其他的游客都在下午游玩，在上午游玩的游客<strong>要求按照预约的顺序排列后，名字是单调递增的，即排在前面的名字严格小于排在后面的名字。</strong></p><p>一个名字 A 小于另一个名字 B 是指：存在一个整数 i，使得 AA 的前 i 个字母与 B 的前 i 个字母相同，且 A 的第 i+1个字母小于 BB 的第 i+1 个字母。(如果 A 不存在第i+1 个字母且 B 存在第i+1 个字母, 也视为 A 的第i+1 个字母小于 B 的第i+1 个字母)</p><p>作为小蓝的助手，你要按照小蓝的想法安排游客，同时你又希望上午有<strong>尽量多的游客</strong>游玩，请告诉小蓝让哪些游客上午游玩。如果方案有多种，请输出上午游玩的第一个游客名字最小的方案。如果此时还有多种方案，请输出第一个游客名字最小的前提下第二个游客名字最小的方案。如果仍然有多种，依此类推选择第三个、第四个……游客名字最小的方案。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入包含一个字符串，按预约的顺序给出所有游客的名字，相邻的游客名字之间没有字符分隔。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>按预约顺序输出上午游玩的游客名单，中间不加任何分隔字符。</p><h3 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h3><p>输入 #1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WoAiLanQiaobei</span><br></pre></td></tr></table></figure><p>输出 #1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AiLanQiaobei</span><br></pre></td></tr></table></figure><h3 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明&#x2F;提示"></a>说明&#x2F;提示</h3><p>对于 20% 的评测数据, 输入的总长度不超过20 个字母。</p><p>对于 50% 的评测数据, 输入的总长度不超过 300 个字母。</p><p>对于 70% 的评测数据, 输入的总长度不超过 10000 个字母。</p><p>对于所有评测数据, 每个名字的长度不超过 10 个字母, 输入的总长度不超过 10^6个字母。</p><p>蓝桥杯 2020 年国赛 B 组 G 题。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>参考：<a href="https://blog.csdn.net/qq_30347475/article/details/117395573">第十一届蓝桥杯-游园安排_一个老蒟蒻的博客-CSDN博客</a></p><p>最长上升子序列：<a href="https://blog.csdn.net/lxt_Lucia/article/details/81206439">最长上升子序列 (LIS) 详解+例题模板 (全)_lxt_Lucia的博客-CSDN博客_最长上升子序列</a></p><p><strong>解析</strong><br>    题目我看了很久，第一次做的时候以为是一道简单的排序题，可是怎么都输出不对，后来看了别人的题解才知道，这道题的本质是最长上升子序列，于是自己也想了一想，确实如此，不然你怎么能确定上午安排人的人数呢？</p><p>​    <strong>什么是最长上升子序列？</strong></p><p>​    就是在一段字符中，取出某几个字符组成一个字符串，这个字符串的每一个字符都大于左边字符并且小于右边的字符，那么这个字符串就是上升序列，也就是说类似于函数中的单调递增的概念，就比如说abtxz这就是一个上升序列，那么最长上升子序列就是指一个字符串中的子序列中，最长的那个上升子序列</p><p>​但是呢，这一题又有点不一样，这是最长上升字典序的问题，就是将一个字符串的人名所组成的字典作为字符，取最长的上升子序列，简单点说，就是将最长上升子序列中的字符改成人名组成的字符串进行组合就行了，那么就很好理解了，看了下样例输出，果然如此。</p><p>​<strong>方法：动态规划优化-二分加贪心</strong><br>​二分其实没啥，就是为了寻找某个元素，而且是直接使用lower_bound来查找的，所以没什么困难的地方，这里的重点在于贪心，下面讲讲贪心的思路</p><p>​首先将所有人序列取出存储到数组中后，先将第一个序列入队，遍历剩下所有序列，如果说碰见比队尾大的序列就直接入队，否则，也就是当前序列并不小于队尾序列的话，那么就用其代替掉队列中比其大的第一个序列（这是贪心思想，待会解释），并要更新一下当前情况下所能组成的最大单调子序列，将其入队</p><p>​运用贪心的思想，我们就能很容易确定最长上升子序列的长度，因为碰见大的就插入，碰见小的就替换，那么整各队列的长度最终一定会是最长上升序列的长度</p><p>​最后，我们从num开始往前遍历，和动态规划的回溯一样,这里就不解释了</p><p>​值得一说的是，这里使用动态数组主要是为了防止超内存</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line">string s;</span><br><span class="line">string v[N];</span><br><span class="line">vector&lt;string&gt; endd;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; f;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(s[i]&gt;=<span class="string">&#x27;A&#x27;</span>&amp;&amp;s[i]&lt;=<span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i!=<span class="number">0</span>)</span><br><span class="line">num++;</span><br><span class="line">v[num]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">v[num]+=s[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">v[num]+=s[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">endd.<span class="built_in">push_back</span>(v[<span class="number">0</span>]);</span><br><span class="line">f.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=num;i++)<span class="comment">//遍历到最后一个子字符串数组元素 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(v[i]&gt;endd.<span class="built_in">back</span>())<span class="comment">//如果当前end中的字符串能构成上升序列 </span></span><br><span class="line">&#123;</span><br><span class="line">endd.<span class="built_in">push_back</span>(v[i]);<span class="comment">//则将当前子字符串入队 </span></span><br><span class="line">f.<span class="built_in">push_back</span>(endd.<span class="built_in">size</span>());<span class="comment">//那么当前动态数组的长度就是当前上升序列的长度 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;   <span class="comment">//下面是贪心做法 </span></span><br><span class="line"><span class="comment">//如果不能构成单调上升序列</span></span><br><span class="line"><span class="type">int</span> pos=<span class="built_in">lower_bound</span>(endd.<span class="built_in">begin</span>(),endd.<span class="built_in">end</span>(),v[i])-endd.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">//找到大于等于序列v[i]的第一个元素的位置 </span></span><br><span class="line"> </span><br><span class="line">endd[pos]=v[i];<span class="comment">//将这个元素替换为v[i]（这个可能不好理解，下面会说的） </span></span><br><span class="line">f.<span class="built_in">push_back</span>(pos+<span class="number">1</span>);</span><br><span class="line"><span class="comment">//更新一下，那么当前的上升序列的长度就是pos+1（因为0-pos是单调上升的，加上0这个首元素所以是pos+1) </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">string k[N];<span class="comment">//用字符串连接会超时 </span></span><br><span class="line">  <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=num,m=endd.<span class="built_in">size</span>();m&gt;<span class="number">0</span>;i--)<span class="comment">//类似动态规划将结果逆序输出</span></span><br><span class="line"> &#123;</span><br><span class="line"><span class="keyword">if</span>(f[i]==m)</span><br><span class="line">&#123;</span><br><span class="line">k[cnt++]=v[i];</span><br><span class="line">m--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=cnt<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) cout&lt;&lt;k[i];</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">现在来说一下贪心的思路</span><br><span class="line"></span><br><span class="line">首先我们上面说了，我们只要碰到比尾部小的元素就更换队列内的元素，否则就加入队尾，这种贪心思想其实就是方法一中的动态规划思想求出最长子序列的方法，f一样存储的是每个子序列的最长上升子序列的长度，所以说，不要这样想：我这样遍历不是动态数组里面的顺序都是乱的吗？那我到时候怎么输出啊，不不不，这种贪心只是为了能够用上二分法来对时间复杂度进行优化，他的本质还是动态规划，二分+贪心只是为了解决方法一中的嵌套循环的问题，使时间复杂度降低到 O(NlogN)</span><br></pre></td></tr></table></figure><p>一个问题：最长非降序子序列如何寻找</p><p>另外，在做题时，要用全局变量开数组，也不要用vector，因为要开双倍空间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string ans[maxj];</span><br><span class="line">string ve[maxj];//以字符串为单位</span><br><span class="line">vector&lt;string&gt;ed;//记录答案序列</span><br><span class="line">vector&lt;int&gt;f;</span><br></pre></td></tr></table></figure><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">string ans[maxj];</span><br><span class="line">string ve[maxj];<span class="comment">//以字符串为单位</span></span><br><span class="line">vector&lt;string&gt;ed;<span class="comment">//记录答案序列</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;f;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();)&#123;</span><br><span class="line">        string now=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        now+=s[i];</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;s.<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[j]&gt;=<span class="string">&#x27;A&#x27;</span>&amp;&amp;s[j]&lt;=<span class="string">&#x27;Z&#x27;</span>)<span class="keyword">break</span>;</span><br><span class="line">            now+=s[j];</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;now&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">        ve[num++]=now;</span><br><span class="line">        i=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    ed.<span class="built_in">emplace_back</span>(ve[<span class="number">0</span>]);</span><br><span class="line">    f.<span class="built_in">emplace_back</span>(<span class="number">1</span>);<span class="comment">//记录大小</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;num;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ve[i]&gt;ed.<span class="built_in">back</span>())&#123;</span><br><span class="line">            ed.<span class="built_in">emplace_back</span>(ve[i]);</span><br><span class="line">            f.<span class="built_in">emplace_back</span>(ed.<span class="built_in">size</span>());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//贪心+二分</span></span><br><span class="line">            <span class="type">int</span> pos=<span class="built_in">lower_bound</span>(ed.<span class="built_in">begin</span>(),ed.<span class="built_in">end</span>(),ve[i])-ed.<span class="built_in">begin</span>();</span><br><span class="line">            ed[pos]=ve[i];</span><br><span class="line">            f.<span class="built_in">emplace_back</span>(pos+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=num,m=ed.<span class="built_in">size</span>();m&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(f[i]==m)&#123;</span><br><span class="line">            m--;</span><br><span class="line">            ans[++cnt]=ve[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=cnt;i&gt;=<span class="number">1</span>;--i)cout&lt;&lt;ans[i];cout&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目相关知识总结</title>
      <link href="/2024/05/16/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
      <url>/2024/05/16/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="数据分析、数据挖掘、机器学习相关内容总结"><a href="#数据分析、数据挖掘、机器学习相关内容总结" class="headerlink" title="数据分析、数据挖掘、机器学习相关内容总结"></a>数据分析、数据挖掘、机器学习相关内容总结</h1><p>   <strong>本博客结合大量项目， 从实战出发， 细致讲解关于数据分析、数据挖掘、机器学习等内容知识。</strong>（<strong>持续更新中</strong>）</p><h2 id="关于pip"><a href="#关于pip" class="headerlink" title="关于pip"></a>关于pip</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#卸载安装pip</span><br><span class="line">python -m pip uninstall pip</span><br><span class="line">python -m ensurepip</span><br><span class="line"></span><br><span class="line"># 更新pip</span><br><span class="line">pip install --upgrade pip</span><br><span class="line"></span><br><span class="line"># 更换pip镜像源</span><br><span class="line">pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"></span><br><span class="line"># 清除缓存</span><br><span class="line">pip cache purge</span><br><span class="line"></span><br><span class="line"># 更新指定包</span><br><span class="line">pip install -U pip setuptools</span><br><span class="line"></span><br><span class="line"># 指定清华镜像下载指定包</span><br><span class="line">pip install paddlepaddle==2.3.0 -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="关于conda"><a href="#关于conda" class="headerlink" title="关于conda"></a>关于conda</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 更换清华镜像源</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class="line"></span><br><span class="line"># 优先使用清华镜像</span><br><span class="line">conda config --prepend channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</span><br><span class="line">conda config --prepend channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free</span><br><span class="line"></span><br><span class="line"># 清除缓存</span><br><span class="line">conda clean --all</span><br><span class="line"></span><br><span class="line"># 更新conda</span><br><span class="line">conda update conda</span><br><span class="line"></span><br><span class="line"># conda实在不好用可以用pip在Anaconda Prompt中安装相关包</span><br></pre></td></tr></table></figure><h2 id="jupyter相关内容"><a href="#jupyter相关内容" class="headerlink" title="jupyter相关内容"></a>jupyter相关内容</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># jupyter重装命令</span><br><span class="line">pip install --upgrade --force-reinstall --no-cache-dir jupyter</span><br><span class="line"></span><br><span class="line"># 绘图字体问题</span><br><span class="line">plt.rcParams[&#x27;font.sans-serif&#x27;] = [u&#x27;SimHei&#x27;]</span><br><span class="line">plt.rcParams[&#x27;axes.unicode_minus&#x27;] = False</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="orange相关内容"><a href="#orange相关内容" class="headerlink" title="orange相关内容"></a>orange相关内容</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 通过Anaconda安装orange</span><br><span class="line">conda config --add channels conda-forge</span><br><span class="line">conda install orange3</span><br><span class="line"></span><br><span class="line"># 启动orange</span><br><span class="line">orange-canvas</span><br><span class="line"></span><br><span class="line"># 卸载</span><br><span class="line">pip uninstall orange orange-canvas-core orange-widget-base</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Pytorch"><a href="#Pytorch" class="headerlink" title="Pytorch"></a>Pytorch</h2><h2 id="常见包的理解："><a href="#常见包的理解：" class="headerlink" title="常见包的理解："></a>常见包的理解：</h2><h3 id="pandas"><a href="#pandas" class="headerlink" title="pandas"></a>pandas</h3><p>Pandas 提供了易于使用的数据结构和数据分析工具，特别适用于处理结构化数据，如表格型数据（类似于Excel表格）。</p><p>Pandas 主要引入了两种新的数据结构：<strong>DataFrame</strong> 和 <strong>Series</strong>。<strong>DataFrame 可视为由多个 Series 组成的数据结构</strong></p><p><a href="https://blog.csdn.net/qq_44766883/article/details/108176973">https://blog.csdn.net/qq_44766883/article/details/108176973</a></p><h3 id="numpy"><a href="#numpy" class="headerlink" title="numpy"></a>numpy</h3><p>支持大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。</p><p><a href="https://www.cnblogs.com/lemonbit/p/7043879.html">https://www.cnblogs.com/lemonbit/p/7043879.html</a></p><h3 id="matplotlib"><a href="#matplotlib" class="headerlink" title="matplotlib"></a>matplotlib</h3><p>它能让使用者很轻松地将数据图形化，并且提供多样化的输出格式。</p><p><a href="https://www.zhihu.com/tardis/zm/art/139052035?source_id=1003">https://www.zhihu.com/tardis/zm/art/139052035?source_id=1003</a></p><h3 id="sklearn"><a href="#sklearn" class="headerlink" title="sklearn"></a>sklearn</h3><p>SKLearn中有六大任务模块，如下图所示：分别是分类、回归、聚类、降维、模型选择和预处理。</p><p><a href="https://www.showmeai.tech/article-detail/203">https://www.showmeai.tech/article-detail/203</a></p><h2 id="常见的数据处理命令"><a href="#常见的数据处理命令" class="headerlink" title="常见的数据处理命令"></a>常见的数据处理命令</h2><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入基本包</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>]=[<span class="string">&#x27;SimHei&#x27;</span>]   <span class="comment"># 用来正常显示中文标签</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>]=<span class="literal">False</span>     <span class="comment"># 用来正常显示负号</span></span><br><span class="line">matplotlib.rc(<span class="string">&quot;font&quot;</span>,family=<span class="string">&#x27;SimHei&#x27;</span>)</span><br><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">import</span> nltk</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件导入，数据探索</span></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;./input/data.csv&#x27;</span>)</span><br><span class="line">df.head(<span class="number">5</span>) <span class="comment"># 查看文件前5行</span></span><br><span class="line">df.shape <span class="comment"># 查看数据大小</span></span><br><span class="line">df.info() <span class="comment"># 查看数格式，空值等信息</span></span><br><span class="line">df.describe() <span class="comment"># 查看数据基本的统计信息</span></span><br><span class="line">df[<span class="string">&#x27;属性&#x27;</span>].value_counts() <span class="comment"># 某一列按不同值计数，返回的是计数列向量</span></span><br><span class="line">df[<span class="string">&#x27;属性&#x27;</span>].replace([<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],inplace=<span class="literal">True</span>) <span class="comment"># 对应属性值被替代，inplace=true时，会替换原内容，不返回副本</span></span><br><span class="line">df = pd.concat([df, dummy_df], axis=<span class="number">1</span>) <span class="comment">#前后拼接操作，axis=0按列 axis=1按行</span></span><br><span class="line">df.mean(axis=<span class="number">0</span>) <span class="comment"># 按行显示均值</span></span><br><span class="line">df.std(axis=<span class="number">0</span>) <span class="comment"># 按列显示均值</span></span><br><span class="line">np.<span class="built_in">sum</span>(pd.isnull(content)) <span class="comment"># 检查空白内容</span></span><br><span class="line">content = content[~index_of_juan].reset_index(drop=<span class="literal">True</span>) <span class="comment"># 重新设置index，单用drop的时候，True不会新增一列，False会新增一列index</span></span><br><span class="line">chapter_names_split = chapter_names.<span class="built_in">str</span>.split(<span class="string">&quot; &quot;</span>).reset_index(drop=<span class="literal">True</span>) <span class="comment"># 处理章节名，按照空格分割字符串，返回的是分割后的字符串列表</span></span><br><span class="line">garments.drop(columns=[<span class="string">&#x27;属性&#x27;</span>], inplace=<span class="literal">True</span>) <span class="comment"># 删除‘属性’这一列</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># iloc[a:b,c:d]:取行索引从a到b-1，列索引从c到d-1的数据。</span></span><br><span class="line"><span class="built_in">print</span>(df.iloc[<span class="number">0</span>:<span class="number">2</span>,<span class="number">0</span>:<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(df.iloc[<span class="number">0</span>:<span class="number">2</span>,<span class="number">0</span>:<span class="number">2</span>].values)</span><br><span class="line"><span class="comment">#Out1：   姓名   班级</span></span><br><span class="line"><span class="comment">#      0  小明  302</span></span><br><span class="line"><span class="comment">#      1  小王  303</span></span><br><span class="line"><span class="comment">#Out2：[[&#x27;小明&#x27; 302]</span></span><br><span class="line"><span class="comment">#       [&#x27;小王&#x27; 303]]</span></span><br><span class="line"></span><br><span class="line">df[<span class="string">&#x27;属性&#x27;</span>].value_counts() <span class="comment"># 对于每种可能进行计数</span></span><br><span class="line"></span><br><span class="line">df[<span class="string">&#x27;属性&#x27;</span>].replace([情况<span class="number">1</span>,情况<span class="number">2</span>],[new情况<span class="number">1</span>，new情况<span class="number">2</span>],inplace=<span class="literal">True</span>) <span class="comment"># inplace为True时，将新的数据替换原数据</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="如何每一段内容的开始index和结束index"><a href="#如何每一段内容的开始index和结束index" class="headerlink" title="如何每一段内容的开始index和结束index"></a>如何每一段内容的开始index和结束index</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 使用正则表达式，选取相应索引</span></span><br><span class="line">index_of_hui = content.content.<span class="built_in">str</span>.<span class="keyword">match</span>(<span class="string">&quot;^第+.+回&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 根据索引选取每一章节的标题</span></span><br><span class="line">chapter_names = content.content[index_of_hui].reset_index(drop=<span class="literal">True</span>)</span><br><span class="line">chapter_names.head()</span><br><span class="line"></span><br><span class="line"><span class="comment">## 建立保存数据的数据框</span></span><br><span class="line">data = pd.DataFrame(<span class="built_in">list</span>(chapter_names_split),columns=[<span class="string">&quot;chapter&quot;</span>,<span class="string">&quot;left_name&quot;</span>,<span class="string">&quot;right_name&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">## 添加章节序号和章节名称列</span></span><br><span class="line">data[<span class="string">&quot;chapter_number&quot;</span>] = np.arange(<span class="number">1</span>,<span class="number">121</span>)</span><br><span class="line">data[<span class="string">&quot;chapter_name&quot;</span>] = data.left_name+<span class="string">&quot;,&quot;</span>+data.right_name</span><br><span class="line"></span><br><span class="line"><span class="comment">## 添加每章开始的行位置</span></span><br><span class="line">data[<span class="string">&quot;start_id&quot;</span>] = index_of_hui[index_of_hui == <span class="literal">True</span>].index</span><br><span class="line"></span><br><span class="line"><span class="comment">## 添加每章结束的行位置</span></span><br><span class="line">data[<span class="string">&quot;end_id&quot;</span>] = data[<span class="string">&quot;start_id&quot;</span>][<span class="number">1</span>:<span class="built_in">len</span>(data[<span class="string">&quot;start_id&quot;</span>])].reset_index(drop = <span class="literal">True</span>) - <span class="number">1</span></span><br><span class="line">data[<span class="string">&quot;end_id&quot;</span>][[<span class="built_in">len</span>(data[<span class="string">&quot;end_id&quot;</span>])-<span class="number">1</span>]] = content.index[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">## 添加每章的行数</span></span><br><span class="line">data[<span class="string">&quot;length_of_chapters&quot;</span>] = data.end_id - data.start_id</span><br><span class="line"></span><br><span class="line">data.head()</span><br></pre></td></tr></table></figure><h3 id="groupby、apply、agg函数的应用"><a href="#groupby、apply、agg函数的应用" class="headerlink" title="groupby、apply、agg函数的应用"></a>groupby、apply、agg函数的应用</h3><p><strong>apply</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DataFrame.apply(func, axis=<span class="number">0</span>) </span><br><span class="line"><span class="comment"># func 代表的是传入的函数或 lambda 表达式；</span></span><br><span class="line"><span class="comment"># axis 参数可提供的有两个，该参数默认为0/列</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># lambda 表达式 </span></span><br><span class="line">df.A = df.A.apply(<span class="keyword">lambda</span> x:<span class="built_in">str</span>(x)+<span class="string">&quot;\tYes&quot;</span> <span class="keyword">if</span> x%<span class="number">2</span>==<span class="number">0</span> <span class="keyword">else</span> <span class="built_in">str</span>(x)+<span class="string">&quot;\tNo&quot;</span>) <span class="comment">#对A列逐个判断，x相当于单个元素，满足条件做出对应条件的操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 可以自定义函数进行操作</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">addOne</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="keyword">return</span> data + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">df[<span class="string">&#x27;Age&#x27;</span>] = df[<span class="string">&#x27;Age&#x27;</span>].apply(addOne)</span><br><span class="line">df[<span class="string">&#x27;Age&#x27;</span>] = df[<span class="string">&#x27;Age&#x27;</span>].apply(<span class="built_in">int</span>)</span><br></pre></td></tr></table></figure><p><strong>groupby</strong></p><p><a href="https://www.51cto.com/article/720182.html">https://www.51cto.com/article/720182.html</a></p><p><a href="https://blog.csdn.net/FrankieHello/article/details/97272990">pandas之分组groupby()的使用整理与总结-CSDN博客</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">sales.groupby(<span class="string">&quot;store&quot;</span>)[<span class="string">&quot;stock_qty&quot;</span>].agg([<span class="string">&quot;mean&quot;</span>, <span class="string">&quot;max&quot;</span>]) <span class="comment"># 按store属性聚类，筛选stock_qty列并进行相应聚合</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按sex聚类，返回[&#x27;Age&#x27;, &#x27;Score&#x27;]的mean</span></span><br><span class="line">grouped = df.groupby(<span class="string">&#x27;Sex&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(grouped.mean()[[<span class="string">&#x27;Age&#x27;</span>, <span class="string">&#x27;Score&#x27;</span>]])</span><br></pre></td></tr></table></figure><p><strong>agg</strong></p><p><a href="https://blog.csdn.net/weixin_45144170/article/details/105008350">https://blog.csdn.net/weixin_45144170/article/details/105008350</a></p><p>默认对行进行聚合操作，常用于groupby之后，有max，min，mean，std，sum，median（中位数），var（方差），count（计数）</p><p><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.agg.html">https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.agg.html</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">sales.groupby(<span class="string">&quot;store&quot;</span>)[<span class="string">&quot;stock_qty&quot;</span>].agg([<span class="string">&quot;mean&quot;</span>, <span class="string">&quot;max&quot;</span>]) <span class="comment"># 这些函数聚合到行上</span></span><br><span class="line"></span><br><span class="line">df.agg(&#123;<span class="string">&#x27;A&#x27;</span> : [<span class="string">&#x27;sum&#x27;</span>, <span class="string">&#x27;min&#x27;</span>], <span class="string">&#x27;B&#x27;</span> : [<span class="string">&#x27;min&#x27;</span>, <span class="string">&#x27;max&#x27;</span>]&#125;) <span class="comment"># 每列有不同的聚合</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 可以自定义函数，并对指定属性进行操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getSum</span>(<span class="params">data</span>):</span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> d <span class="keyword">in</span> data:</span><br><span class="line">        total+=d</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(grouped.aggregate(np.median))</span><br><span class="line"><span class="built_in">print</span>(grouped.aggregate(&#123;<span class="string">&#x27;Age&#x27;</span>:np.median, <span class="string">&#x27;Score&#x27;</span>:np.<span class="built_in">sum</span>&#125;))</span><br><span class="line"><span class="built_in">print</span>(grouped.aggregate(&#123;<span class="string">&#x27;Age&#x27;</span>:getSum&#125;))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="词频分析-词云"><a href="#词频分析-词云" class="headerlink" title="词频分析+词云"></a>词频分析+词云</h3><p><strong>参照项目六：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 对红楼梦全文进行分词</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据表的行列数</span></span><br><span class="line">row,col = data.shape</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预定义列表</span></span><br><span class="line">data[<span class="string">&quot;cutted_words&quot;</span>] = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定自定义的词典，以便包含jieba词库里没有的词，保证更高的正确率</span></span><br><span class="line">jieba.load_userdict(<span class="string">&#x27;./input/Red_Mansion_Dictionary.txt&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> np.arange(row):</span><br><span class="line">    <span class="comment"># 分词</span></span><br><span class="line">    cutwords = <span class="built_in">list</span>(jieba.cut(data.content[i]))</span><br><span class="line">    <span class="comment"># 去除长度为1的词</span></span><br><span class="line">    cutwords = pd.Series(cutwords)[pd.Series(cutwords).apply(<span class="built_in">len</span>)&gt;<span class="number">1</span>]</span><br><span class="line">    <span class="comment"># 去停用词</span></span><br><span class="line">    cutwords = cutwords[~cutwords.isin(stop_words)]</span><br><span class="line">    data.cutted_words[i] = cutwords.values</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加每一章节的词数</span></span><br><span class="line">data[<span class="string">&#x27;length_of_words&#x27;</span>] = data.cutted_words.apply(<span class="built_in">len</span>)</span><br><span class="line">data[<span class="string">&#x27;cutted_words&#x27;</span>].head()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 统计全书的词频，计算每个词出现的频率并排序</span></span><br><span class="line">words = np.concatenate(data.cutted_words)</span><br><span class="line"></span><br><span class="line"><span class="comment">#统计词频</span></span><br><span class="line">word_df = pd.DataFrame(&#123;<span class="string">&quot;word&quot;</span>:words&#125;)</span><br><span class="line">word_frequency = word_df.groupby(by=[<span class="string">&quot;word&quot;</span>])[<span class="string">&quot;word&quot;</span>].agg(&#123;<span class="string">&quot;count&quot;</span>&#125;).reset_index()</span><br><span class="line">word_frequency.columns = [<span class="string">&quot;word&quot;</span>,<span class="string">&quot;frequency&quot;</span>]</span><br><span class="line">word_frequency = word_frequency.reset_index().sort_values(by=<span class="string">&quot;frequency&quot;</span>,ascending=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">word_frequency.head(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 使用条形图展示满足一定条件的词语</span></span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>,<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">frequent_words = word_frequency.loc[word_frequency.frequency &gt; <span class="number">500</span>].sort_values(<span class="string">&#x27;frequency&#x27;</span>)</span><br><span class="line">plt.barh(y = frequent_words[<span class="string">&quot;word&quot;</span>],width = frequent_words[<span class="string">&quot;frequency&quot;</span>])</span><br><span class="line"></span><br><span class="line">plt.xticks(size = <span class="number">10</span>)  </span><br><span class="line">plt.ylabel(<span class="string">&quot;关键词&quot;</span>)   </span><br><span class="line">plt.xlabel(<span class="string">&quot;频数&quot;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;红楼梦词频分析&quot;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment">## 如何绘制词云</span></span><br><span class="line"><span class="keyword">from</span> wordcloud <span class="keyword">import</span> WordCloud</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">wordcloud = WordCloud(font_path=<span class="string">&#x27;./input/SimHei.ttf&#x27;</span>,margin=<span class="number">5</span>, width=<span class="number">1800</span>, height=<span class="number">900</span>)</span><br><span class="line"></span><br><span class="line">wordcloud.generate(<span class="string">&quot;/&quot;</span>.join(np.concatenate(data.cutted_words))) <span class="comment"># np.concatenate将分词转换成一维数组，需要有/或者空格分隔</span></span><br><span class="line"></span><br><span class="line">plt.imshow(wordcloud)</span><br><span class="line">plt.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="排序sort使用"><a href="#排序sort使用" class="headerlink" title="排序sort使用"></a>排序sort使用</h3><p>默认升序</p><p><strong>demo：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">word_frequency = word_frequency.reset_index().sort_values(by=<span class="string">&quot;某一属性&quot;</span>,ascending=<span class="literal">False</span>) <span class="comment"># 按照某一属性，降序排列 </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="相关性判断"><a href="#相关性判断" class="headerlink" title="相关性判断"></a>相关性判断</h2><h3 id="热力图判断相关性"><a href="#热力图判断相关性" class="headerlink" title="热力图判断相关性"></a>热力图判断相关性</h3><p><a href="https://blog.csdn.net/weixin_60737527/article/details/126048311">https://blog.csdn.net/weixin_60737527/article/details/126048311</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cmap：热图颜色风格，与matplotlib中cmap相同，详解附录。</span></span><br><span class="line"><span class="comment"># annot：True,False，是否显示数值注释,默认为False。</span></span><br><span class="line"><span class="comment"># cbar：True,False 是否显示标尺，默认为True。</span></span><br><span class="line"><span class="comment"># linewidth：每个小方格之间的间距。</span></span><br><span class="line"><span class="comment"># linecolor：分割线的颜色。</span></span><br><span class="line"><span class="comment"># annot_kws：&#123;&#x27;color&#x27;:&#x27;  &#x27;,&#x27;size&#x27;:  ,&#x27;family&#x27;:&#x27;  &#x27;,&#x27;style&#x27;:&#x27;  &#x27;,&#x27;weight&#x27;:  ,......&#125;，单元格数值标签属性。</span></span><br><span class="line"><span class="comment">##样例1</span></span><br><span class="line">plt.figure(figsize = (<span class="number">12</span>,<span class="number">12</span>))</span><br><span class="line">df1 = df.iloc[:,[<span class="number">1</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>]].copy()</span><br><span class="line">plt.title(<span class="string">&#x27;连续型变量皮尔逊相关系数热力图&#x27;</span>,fontsize=<span class="number">20</span>)</span><br><span class="line">sns.heatmap(df1.corr(),annot = <span class="literal">True</span>,cmap=<span class="string">&quot;Blues&quot;</span>,annot_kws=&#123;<span class="string">&#x27;fontsize&#x27;</span>:<span class="number">9</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 样例2</span></span><br><span class="line"><span class="comment"># 计算相关系数</span></span><br><span class="line"><span class="comment"># print(garments.dtypes)</span></span><br><span class="line"><span class="comment"># 自动选择浮点型列  </span></span><br><span class="line">float_columns = garments.select_dtypes(include=[np.float64])  </span><br><span class="line"><span class="comment"># 计算浮点型列之间的相关系数  </span></span><br><span class="line">corr = float_columns.corr()  </span><br><span class="line">fig = plt.figure(figsize=(<span class="number">7</span>,<span class="number">7</span>))</span><br><span class="line"></span><br><span class="line">cmap = sns.diverging_palette(<span class="number">220</span>,<span class="number">10</span>,as_cmap=<span class="literal">True</span>) <span class="comment"># 改变颜色 ，颜色范围 as_cmap返回返回一个 matplotlib colormap 而不是一个颜色列表。</span></span><br><span class="line">mask = np.zeros_like(corr, dtype=<span class="built_in">bool</span>)  <span class="comment"># 将np.bool更改为bool  </span></span><br><span class="line">mask[np.triu_indices_from(mask)] = <span class="literal">True</span> <span class="comment"># 返回矩阵上三角矩阵，其值设为true不显示</span></span><br><span class="line"></span><br><span class="line">sns.heatmap(corr, annot=<span class="literal">True</span>, square=<span class="literal">True</span>,linewidths=<span class="number">1.5</span>, cmap=cmap, mask=mask, center=<span class="number">0</span>, cbar_kws=&#123;<span class="string">&quot;shrink&quot;</span>: <span class="number">.5</span>&#125;)</span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">&quot;特征间的相关性&quot;</span>,fontsize=<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="卡方"><a href="#卡方" class="headerlink" title="卡方"></a>卡方</h3><p><strong>可参考项目三</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectKBest</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> chi2</span><br><span class="line"></span><br><span class="line">y = df[<span class="string">&#x27;default.payment.next.month&#x27;</span>]</span><br><span class="line">X = df[[<span class="string">&#x27;SEX&#x27;</span>,<span class="string">&#x27;EDUCATION&#x27;</span>,<span class="string">&#x27;MARRIAGE&#x27;</span>]]</span><br><span class="line"></span><br><span class="line">chi2_selector = SelectKBest(chi2, k=<span class="number">2</span>)</span><br><span class="line">chi2_selector.fit(X, y)</span><br><span class="line"><span class="comment"># 给出x对应的卡方得分</span></span><br><span class="line">chi2_selector.scores_</span><br><span class="line"><span class="comment"># 属性保存了每个特征的卡方检验的p值</span></span><br><span class="line"><span class="comment"># 如果p值很小（通常小于某个显著性水平，如0.05或0.01），则我们拒绝原假设，认为该特征与目标变量之间存在显著的关联性。</span></span><br><span class="line">chi2_selector.pvalues_</span><br></pre></td></tr></table></figure><p><strong>demo</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectKBest, chi2  </span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 加载iris数据集  </span></span><br><span class="line">iris = load_iris()  </span><br><span class="line">X, y = iris.data, iris.target  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 初始化SelectKBest对象，使用chi2作为得分函数  </span></span><br><span class="line">chi2_selector = SelectKBest(score_func=chi2, k=<span class="number">2</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 拟合模型  </span></span><br><span class="line">chi2_selector.fit(X, y)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 输出每个特征的p值  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;P-values for each feature:&quot;</span>, chi2_selector.pvalues_)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 转换特征，只保留得分最高的k个特征  </span></span><br><span class="line">X_new = chi2_selector.transform(X)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 输出选定的特征索引  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Selected feature indices:&quot;</span>, chi2_selector.get_support(indices=<span class="literal">True</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="TF-IDF"><a href="#TF-IDF" class="headerlink" title="TF-IDF"></a>TF-IDF</h2><h3 id="相关理解"><a href="#相关理解" class="headerlink" title="相关理解"></a>相关理解</h3><p><a href="https://easyai.tech/ai-definition/tf-idf/">一文看懂 TF-IDF (概念图解+4大变种+发展历史) (easyai.tech)</a></p><p><strong>TF （Term Frequency）—— “单词频率”</strong></p><p>一个查询关键字中某一个单词在目标文档中出现的次数。</p><p><strong>IDF（Inverse Document Frequency）—— “逆文档频率”</strong></p><p>“惩罚”（Penalize）那些出现在太多文档中的单词。</p><h3 id="代码demo"><a href="#代码demo" class="headerlink" title="代码demo"></a>代码demo</h3><p><strong>参看项目六</strong></p><ul><li>TfidfVectorizer模型建立后，可通过<code>fit_transform()</code>函数进行训练，将文本中的词语转换为词的TF－IDF矩阵；通过<code>get_feature_names()</code>可看到所有文本的关键字；通过<code>vocabulary_</code>属性查看关键词编号。TfidfVectorizer模型的输出为矩阵形式，通过<code>toarray()</code>函数可看到TF－IDF矩阵的结果。</li></ul><p><strong>项目内截出</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 导包</span></span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> TfidfVectorizer</span><br><span class="line"></span><br><span class="line">content = []</span><br><span class="line"><span class="keyword">for</span> cutword <span class="keyword">in</span> data.cutted_words:</span><br><span class="line">    content.append(<span class="string">&quot; &quot;</span>.join(cutword))</span><br><span class="line"></span><br><span class="line"><span class="comment">## 构建语料库，并计算文档的TF－IDF矩阵</span></span><br><span class="line">transformer = TfidfVectorizer()</span><br><span class="line">tfidf = transformer.fit_transform(content)</span><br><span class="line"></span><br><span class="line"><span class="comment">## TF－IDF以稀疏矩阵的形式存储，将TF－IDF转化为数组的形式,文档－词矩阵</span></span><br><span class="line">word_vectors = tfidf.toarray()</span><br><span class="line">word_vectors</span><br><span class="line"></span><br><span class="line"><span class="comment">## 输出结果</span></span><br><span class="line"><span class="comment"># array([[0.        , 0.        , 0.00732401, ..., 0.        , 0.        ,</span></span><br><span class="line"><span class="comment">#         0.        ],</span></span><br><span class="line"><span class="comment">#        [0.        , 0.        , 0.0089662 , ..., 0.        , 0.        ,</span></span><br><span class="line"><span class="comment">#         0.        ],</span></span><br><span class="line"><span class="comment">#        [0.04321373, 0.        , 0.0486704 , ..., 0.        , 0.        ,</span></span><br><span class="line"><span class="comment">#         0.        ],</span></span><br><span class="line"><span class="comment">#        ...,</span></span><br><span class="line"><span class="comment">#        [0.        , 0.        , 0.        , ..., 0.        , 0.        ,</span></span><br><span class="line"><span class="comment">#         0.        ],</span></span><br><span class="line"><span class="comment">#        [0.        , 0.        , 0.00731152, ..., 0.        , 0.        ,</span></span><br><span class="line"><span class="comment">#         0.        ],</span></span><br><span class="line"><span class="comment">#        [0.        , 0.        , 0.00886065, ..., 0.        , 0.        ,</span></span><br><span class="line"><span class="comment">#         0.        ]])</span></span><br></pre></td></tr></table></figure><p><strong>demo</strong></p><p><a href="https://blog.csdn.net/qq_43391414/article/details/112912107">一个例子来使用sklearn中的TfidfVectorizer_tfidvectorizer 单汉字-CSDN博客</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> TfidfVectorizer</span><br><span class="line"><span class="comment"># 训练数据</span></span><br><span class="line">train = [<span class="string">&quot;Chinese Beijing Chinese&quot;</span>,<span class="string">&quot;Chinese Chinese Shanghai&quot;</span>,<span class="string">&quot;Chinese Macao&quot;</span>,<span class="string">&quot;Tokyo Japan Chinese&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将训练数据转化为向量。</span></span><br><span class="line"></span><br><span class="line">tv=TfidfVectorizer() <span class="comment"># 初始化一个空的tv。</span></span><br><span class="line">tv_fit=tv.fit_transform(train) <span class="comment"># 用训练数据充实tv,也充实了tv_fit。</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;fit后，所有的词汇如下：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(tv.get_feature_names_out())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;fit后，训练数据的向量化表示为：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(tv_fit.toarray())</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="时间的处理"><a href="#时间的处理" class="headerlink" title="时间的处理"></a>时间的处理</h2><h2 id="离散特征编码"><a href="#离散特征编码" class="headerlink" title="离散特征编码"></a>离散特征编码</h2><ul><li>One-Hot编码和哑变量编码都只能对离散型变量进行编码。</li></ul><h3 id="独热编码"><a href="#独热编码" class="headerlink" title="独热编码"></a>独热编码</h3><p>有限类别，需要将字符串转换成数值型时，独热编码（one hot encoding）会将有限类别转换成数值向量</p><p>One-Hot编码之后生成的新特征数等于对应特征的不同种类取值个数</p><p>对于没有排序的离散变量,如果是距离模型(聚类和KNN等),OneHOt编码显然会更合理.</p><h3 id="哑变量编码（dummy）"><a href="#哑变量编码（dummy）" class="headerlink" title="哑变量编码（dummy）"></a>哑变量编码（dummy）</h3><p>哑变量编码之后生成的新特征数比对应特征的取值个数少1个。</p><p>避免了多重共线性 （Multicollinearity）问题。</p><h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><ol><li>哑变量编码</li><li>pd.get_dummies()方法即可以用于产生One-Hot编码，也可以用于产生哑变量编码</li><li>当drop_first&#x3D;True时为哑变量编码，当为False时为One-Hot编码</li><li>哑变量编码是将One-Hot编码的第一列结果去掉即可。<br><strong>参看项目三</strong></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 官方文档</span></span><br><span class="line">pandas.get_dummies(data, prefix=<span class="literal">None</span>, prefix_sep=<span class="string">&#x27;_&#x27;</span>, dummy_na=<span class="literal">False</span>, columns=<span class="literal">None</span>, sparse=<span class="literal">False</span>, drop_first=<span class="literal">False</span>)[source])</span><br><span class="line"><span class="comment"># 实际应用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定单列独热，并添加到原数据的后边，没有删除原数据</span></span><br><span class="line">df = df.join(pd.get_dummies(df.color))</span><br><span class="line"><span class="comment"># 指定单列独热，并添加到原数据的后边，删除原数据</span></span><br><span class="line">dummies = pd.get_dummies(df[category_features])</span><br><span class="line">train_df = pd.concat([df, dummies], axis=<span class="number">1</span>).drop(category_features, axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定多列独热，并添加到原数据后边，删除原数据</span></span><br><span class="line">str_columns = [<span class="string">&#x27;SEX&#x27;</span>,<span class="string">&#x27;MARRIAGE&#x27;</span>]</span><br><span class="line">df_new = pd.get_dummies(df,columns=str_columns)</span><br><span class="line">df_new</span><br></pre></td></tr></table></figure><h2 id="数据标准化"><a href="#数据标准化" class="headerlink" title="数据标准化"></a>数据标准化</h2><h3 id="Z-sorce标准化（正规化方法"><a href="#Z-sorce标准化（正规化方法" class="headerlink" title="Z-sorce标准化（正规化方法"></a>Z-sorce标准化（正规化方法</h3><h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><p>公式&#x3D;x-E(x)&#x2F;(sqrt(D(x))) </p><p>标准化后的变量值围绕0上下波动，大于0说明高于平均水平，小于0说明低于平均水平。</p><p>将特征数据的分布调整成标准正态分布，也叫高斯分布，也就是使得数据的均值维0，方差为1.</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><p>方式1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"></span><br><span class="line">X=garments.drop([<span class="string">&#x27;actual_productivity&#x27;</span>],axis=<span class="number">1</span>)</span><br><span class="line">y=garments[<span class="string">&#x27;actual_productivity&#x27;</span>]</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.2</span>, random_state=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据标准化  测试集使用fit_transform验证集使用transform</span></span><br><span class="line">s = StandardScaler()</span><br><span class="line">X_train_sm = s.fit_transform(X_train)</span><br><span class="line">X_test_sm = s.transform(X_test)</span><br><span class="line"></span><br><span class="line">X_train_sm = X_train</span><br><span class="line">X_test_sm = X_test</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>方式2：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line">x = np.array([[<span class="number">1.</span>, -<span class="number">1.</span>, <span class="number">2.</span>],</span><br><span class="line">              [<span class="number">2.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">              [<span class="number">0.</span>, <span class="number">1.</span>, -<span class="number">1.</span>]])</span><br><span class="line"><span class="comment"># 将每一列特征标准化为标准正态分布，注意，标准化是针对每一列而言的</span></span><br><span class="line">x_scale = preprocessing.scale(x)</span><br><span class="line">x_scale</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">X.iloc[:,<span class="number">0</span>:<span class="number">20</span>] = preprocessing.scale(X.iloc[:,<span class="number">0</span>:<span class="number">20</span>])</span><br><span class="line">X.sample(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 显示效果</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;均值为：&#123;a&#125;&#x27;</span>.<span class="built_in">format</span>(a = X.LIMIT_BAL.mean()))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;标准差为：&#123;a&#125;&#x27;</span>.<span class="built_in">format</span>(a = X.LIMIT_BAL.std()))</span><br></pre></td></tr></table></figure><h2 id="数据集划分"><a href="#数据集划分" class="headerlink" title="数据集划分"></a>数据集划分</h2><p>对于分类问题，需要划分训练集和测试集</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">y = df_new[<span class="string">&#x27;default.payment.next.month&#x27;</span>]</span><br><span class="line">X = df_new.drop(columns=[<span class="string">&#x27;ID&#x27;</span>,<span class="string">&#x27;default.payment.next.month&#x27;</span>]) <span class="comment"># 不要无关、x轴的属性</span></span><br><span class="line">X_train, X_test,y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.3</span>, random_state=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 查看对应值所占比例</span></span><br><span class="line"><span class="built_in">print</span> (y_train.value_counts()/<span class="built_in">len</span>(y_train))</span><br><span class="line"><span class="built_in">print</span> (y_test.value_counts()/<span class="built_in">len</span>(y_test))</span><br></pre></td></tr></table></figure><h2 id="常见模型总结"><a href="#常见模型总结" class="headerlink" title="常见模型总结"></a>常见模型总结</h2><h3 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h3><h4 id="相关理解-1"><a href="#相关理解-1" class="headerlink" title="相关理解"></a>相关理解</h4><p>​    通过使用另一个相关的已知数据值来预测未知数据的值。</p><p>​    它以数学方式将未知变量或因变量以及已知变量或自变量建模为线性方程。</p><p>​    例如，假设你有关于去年的支出和收入的数据。线性回归技术会分析这些数据，并确定您的支出是收入的一半。然后，他们通过将未来已知收入减半来计算未知的未来支出。</p><h4 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h4><p><strong>项目七</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> r2_score,mean_squared_error</span><br><span class="line"></span><br><span class="line">mlr = LinearRegression()</span><br><span class="line">mlr.fit(X_train_sm, y_train)</span><br><span class="line">y_pred_sm = mlr.predict(X_test_sm)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;R2 为 <span class="subst">&#123;<span class="built_in">round</span>(r2_score(y_test,y_pred_sm),<span class="number">4</span>)&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;均方误差 (MSE): %.4f&#x27;</span> % mean_squared_error(y_test, y_pred_sm))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化</span></span><br><span class="line">plt.figure(figsize=(<span class="number">6</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">plt.scatter(x=y_test,y=y_pred_sm, alpha=<span class="number">.5</span>)</span><br><span class="line"></span><br><span class="line">plt.xlabel(<span class="string">&#x27;实际值&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;预测值&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;实际值预测值对比&#x27;</span>,size=<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h3 id="逻辑回归模型"><a href="#逻辑回归模型" class="headerlink" title="逻辑回归模型"></a>逻辑回归模型</h3><h4 id="相关理解："><a href="#相关理解：" class="headerlink" title="相关理解："></a>相关理解：</h4><h4 id="demo："><a href="#demo：" class="headerlink" title="demo："></a>demo：</h4><h3 id="支持向量机（SVM）"><a href="#支持向量机（SVM）" class="headerlink" title="支持向量机（SVM）"></a>支持向量机（SVM）</h3><h3 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h3><h4 id="理解-1"><a href="#理解-1" class="headerlink" title="理解"></a>理解</h4><p>有关神经网络的内容很多很多（<strong>待补思维导图</strong></p><p>​    <strong>神经网络</strong>是模拟人类大脑处理信息方式的简化模型。 此模型的工作方式为模拟大量类似于神经元的抽象形式的互连处理单元。</p><p>​    这些处理单元都位于层中。 神经网络通常包含三个部分：<strong>输入层</strong>，其中的单元表示输入字段；一个或多个<strong>隐藏层</strong>；一个<strong>输出层</strong>，带有一个或多个表示目标字段的单元。 这些单元通过可变的连接强度（或 <strong>权重</strong> ）连接。 输入数据 显示在第一层，其值从每个神经元传播到下一层的每个神经元。 最终从输出层中输出结果。</p><p>​    前馈神经网络（Feedforward Neural Network）中，信息从输入层开始输入，每层的神经元接收前一级输入，并输出到下一级，直至输出层。整个网络信息输入传输中无反馈（循环）。即任何层的输出都不会影响同级层，可用一个有向无环图表示。</p><p>​    常见的前馈神经网络包括<strong>卷积神经网络（CNN）</strong>、全连接神经网络（FCN)、生成对抗网络(GAN)等。</p><p>​    反馈神经网络（Feedback Neural Network）中，神经元不但可以接收其他神经元的信号，而且可以接收自己的反馈信号。和前馈神经网络相比，反馈神经网络中的神经元具有记忆功能，在不同时刻具有不同的状态。反馈神经网络中的信息传播可以是单向也可以是双向传播，因此可以用一个有向循环图或者无向图来表示。</p><p>​    常见的反馈神经网络包括**循环神经网络(RNN)**、长短期记忆网络(LSTM)、Hopfield网络和玻尔兹曼机。</p><h4 id="简单demo"><a href="#简单demo" class="headerlink" title="简单demo"></a>简单demo</h4><p><strong>分类是预测离散值输出，如类别标签，而回归则预测连续值输出，如价格或得分</strong></p><p><strong>项目七MLPClassifer</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.neural_network <span class="keyword">import</span> MLPRegressor</span><br><span class="line"></span><br><span class="line">mlp = MLPRegressor(random_state=<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">mlp.fit(X_train_sm, y_train)</span><br><span class="line"></span><br><span class="line">y_pred_sm = mlp.predict(X_test_sm)</span><br><span class="line">y_pred_sm = pd.DataFrame(y_pred_sm)[<span class="number">0</span>].apply(<span class="keyword">lambda</span> x: <span class="number">1</span> <span class="keyword">if</span> x &gt; <span class="number">1</span> <span class="keyword">else</span> x).values</span><br><span class="line">y_pred_sm = pd.DataFrame(y_pred_sm)[<span class="number">0</span>].apply(<span class="keyword">lambda</span> x: <span class="number">0</span> <span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">else</span> x).values</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;R2 为 <span class="subst">&#123;<span class="built_in">round</span>(r2_score(y_test,y_pred_sm),<span class="number">4</span>)&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;均方误差 (MSE): %.4f&#x27;</span> % mean_squared_error(y_test, y_pred_sm))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化</span></span><br><span class="line">plt.figure(figsize=(<span class="number">6</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">plt.scatter(x=y_test,y=y_pred_sm, alpha=<span class="number">.5</span>)</span><br><span class="line"></span><br><span class="line">plt.xlabel(<span class="string">&#x27;实际值&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;预测值&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;实际值预测值对比&#x27;</span>,size=<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/u011311291/article/details/78743393">https://blog.csdn.net/u011311291/article/details/78743393</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># two-layer neural network </span></span><br><span class="line"><span class="comment"># train part</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.neural_network <span class="keyword">import</span> MLPClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> KFold</span><br><span class="line"><span class="keyword">from</span> joblib <span class="keyword">import</span> dump</span><br><span class="line"></span><br><span class="line"><span class="comment">#get training data</span></span><br><span class="line">X = train_data[:,<span class="number">1</span>:]</span><br><span class="line">y = train_data[:,<span class="number">0</span>]  </span><br><span class="line"></span><br><span class="line"><span class="comment">#neural network classifier of structure (3,2)</span></span><br><span class="line">kf = KFold(n_splits=<span class="number">3</span>) <span class="comment"># 3-fold cross-validation</span></span><br><span class="line">best_clf = <span class="literal">None</span></span><br><span class="line">best_score = <span class="number">0</span></span><br><span class="line">train_scores = []</span><br><span class="line">test_scores = []</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;kfold-------&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> train_index, test_index <span class="keyword">in</span> kf.split(X):</span><br><span class="line">    <span class="comment"># create neural network using MLPClassifer</span></span><br><span class="line">    <span class="comment"># 第一个隐藏层有3个神经元，第二个隐藏层有2个神经元</span></span><br><span class="line">    clf = MLPClassifier(solver = <span class="string">&#x27;sgd&#x27;</span>, activation = <span class="string">&#x27;logistic&#x27;</span>, max_iter = <span class="number">1000</span>, hidden_layer_sizes = (<span class="number">3</span>,<span class="number">2</span>),random_state = <span class="number">1</span>)</span><br><span class="line">    X_train, X_test = X[train_index], X[test_index]</span><br><span class="line">    y_train, y_test = y[train_index], y[test_index]</span><br><span class="line">    clf.fit(X_train, y_train)</span><br><span class="line">    train_score = clf.score(X_train, y_train)</span><br><span class="line">    train_scores.append(train_score)</span><br><span class="line"> </span><br><span class="line">    test_score = clf.score(X_test, y_test)</span><br><span class="line">    test_scores.append(test_score)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#compare score of the tree models and get the best one</span></span><br><span class="line">    <span class="keyword">if</span> test_score &gt; best_score:</span><br><span class="line">        best_score = test_score</span><br><span class="line">        best_clf = clf</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#print(clf.n_outputs_)</span></span><br><span class="line">in_sample_error = [<span class="number">1</span> - score <span class="keyword">for</span> score <span class="keyword">in</span> train_scores]</span><br><span class="line">test_set_error = [<span class="number">1</span> - score <span class="keyword">for</span> score <span class="keyword">in</span> test_scores]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;in_sample_error: &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(in_sample_error)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;test_set_error: &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(test_set_error)</span><br><span class="line"></span><br><span class="line"><span class="comment">#store the classifier</span></span><br><span class="line"><span class="keyword">if</span> best_clf != <span class="literal">None</span>:</span><br><span class="line">    dump(best_clf, <span class="string">&quot;train_model.m&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>MLPRegressor</strong></p><p><a href="https://zhuanlan.zhihu.com/p/46934912">https://zhuanlan.zhihu.com/p/46934912</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> neural_network</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">mlp = neural_network.MLPRegressor(hidden_layer_sizes=(<span class="number">10</span>), activation=<span class="string">&quot;relu&quot;</span>,</span><br><span class="line">                 solver=<span class="string">&#x27;adam&#x27;</span>, alpha=<span class="number">0.0001</span>,</span><br><span class="line">                 batch_size=<span class="string">&#x27;auto&#x27;</span>, learning_rate=<span class="string">&quot;constant&quot;</span>,</span><br><span class="line">                 learning_rate_init=<span class="number">0.001</span>,</span><br><span class="line">                 power_t=<span class="number">0.5</span>, max_iter=<span class="number">200</span>,tol=<span class="number">1e-4</span>)</span><br><span class="line">x = np.arange(-<span class="number">3.0</span>, <span class="number">3.0</span>, <span class="number">0.1</span>)</span><br><span class="line">y = np.exp(x)</span><br><span class="line">mlp.fit(np.asarray(x).reshape([-<span class="number">1</span>,<span class="number">1</span>]),y)</span><br><span class="line">inp = [[ele] <span class="keyword">for</span> ele <span class="keyword">in</span> x]</span><br><span class="line">pre = mlp.predict(inp)</span><br><span class="line">plt.plot(np.asarray(x), np.asarray(y), <span class="string">&#x27;bo&#x27;</span>)</span><br><span class="line">plt.plot(np.asarray(inp), np.asarray(pre), <span class="string">&#x27;ro&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h3 id="贝叶斯网络"><a href="#贝叶斯网络" class="headerlink" title="贝叶斯网络"></a>贝叶斯网络</h3><h3 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h3><p><a href="https://easyai.tech/ai-definition/decision-tree/">一文看懂决策树 - Decision tree（3个步骤+3种典型算法+10个优缺点） (easyai.tech)</a></p><h4 id="原理理解："><a href="#原理理解：" class="headerlink" title="原理理解："></a>原理理解：</h4><ul><li>三个步骤：</li></ul><p><strong>特征选择</strong></p><p>特征选择决定了使用哪些特征来做判断。在训练数据集中，每个样本的属性可能有很多个，不同属性的作用有大有小。因而特征选择的作用就是筛选出跟分类结果相关性较高的特征，也就是分类能力较强的特征。</p><p>在特征选择中通常使用的准则是：信息增益。</p><p><strong>决策树生成</strong></p><p>选择好特征后，就从根节点触发，对节点计算所有特征的信息增益，选择信息增益最大的特征作为节点特征，根据该特征的不同取值建立子节点；对每个子节点使用相同的方式生成新的子节点，直到信息增益很小或者没有特征可以选择为止。</p><p><strong>决策树剪枝</strong></p><p>剪枝的主要目的是对抗「过拟合」，通过主动去掉部分分支来降低过拟合的风险。</p><ul><li>三种算法</li></ul><p><strong>ID3 算法</strong></p><p>ID3 是最早提出的决策树算法，他就是利用信息增益来选择特征的。</p><p><strong>C4.5 算法</strong></p><p>他是 ID3 的改进版，他不是直接使用信息增益，而是引入“信息增益比”指标作为特征的选择依据。</p><p><strong>CART（Classification and Regression Tree）</strong></p><p>这种算法即可以用于分类，也可以用于回归问题。CART 算法使用了基尼系数取代了信息熵模型。</p><ul><li>常用内容</li></ul><p>除了下边基本的基本训练和评价指标以外，还可以将训练的决策树可视化出来</p><p><a href="https://juejin.cn/post/7085552825316409352">https://juejin.cn/post/7085552825316409352</a></p><h4 id="代码模版："><a href="#代码模版：" class="headerlink" title="代码模版："></a>代码模版：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用sklearn中自带的决策树方法训练</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># 更多参数https://blog.csdn.net/li980828298/article/details/51172744</span></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> tree</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line">tree_model = DecisionTreeClassifier(criterion=<span class="string">&#x27;gini&#x27;</span>,random_state=<span class="number">1</span>) <span class="comment">#&#x27;gini&#x27;基尼系数或者&quot;entropy&quot;信息增益</span></span><br><span class="line">tree_model.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检测训练效果</span></span><br><span class="line">tree_score = tree_model.predict_proba(X_test)[:,<span class="number">1</span>]</span><br><span class="line">tree_pred = tree_model.predict(X_test)</span><br><span class="line">Get_report(y_test,tree_pred)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="GBDT模型"><a href="#GBDT模型" class="headerlink" title="GBDT模型"></a>GBDT模型</h3><h4 id="RF-随机森林-与GBDT之间的区别与联系"><a href="#RF-随机森林-与GBDT之间的区别与联系" class="headerlink" title="RF(随机森林)与GBDT之间的区别与联系"></a>RF(随机森林)与GBDT之间的区别与联系</h4><h5 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a><strong>相同点</strong>：</h5><ul><li>都是由多棵树组成，最终的结果都是由多棵树一起决定。</li><li>RF和GBDT在使用CART树时，可以是分类树或者回归树。</li></ul><h5 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a><strong>不同点</strong>：</h5><ul><li><p>组成随机森林的树可以并行生成，而GBDT是串行生成</p></li><li><p>随机森林的结果是多数表决表决的，而GBDT则是多棵树累加之和</p></li><li><p>随机森林对异常值不敏感，而GBDT对异常值比较敏感</p></li><li><p>随机森林是减少模型的方差，而GBDT是减少模型的偏差</p></li><li><p>随机森林不需要进行特征归一化。而GBDT则需要进行特征归一化</p></li></ul><h3 id="XGBoost模型"><a href="#XGBoost模型" class="headerlink" title="XGBoost模型"></a>XGBoost模型</h3><p>关于Boost（提升法）以及GBDT与XGBoost的联系区别，可以参照：</p><p><a href="https://www.biaodianfu.com/boosting.html">https://www.biaodianfu.com/boosting.html</a></p><p><a href="https://www.cnblogs.com/mantch/p/11164221.html">https://www.cnblogs.com/mantch/p/11164221.html</a></p><h4 id="相关理解：-1"><a href="#相关理解：-1" class="headerlink" title="相关理解："></a>相关理解：</h4><p>XGBoost的<strong>核心算法思想</strong>不难，基本就是：</p><ol><li>不断地添加树，不断地进行特征分裂来生长一棵树，每次添加一个树，其实是学习一个新函数**f(x)**，去拟合上次预测的残差。</li><li>当我们训练完成得到k棵树，我们要预测一个样本的分数，其实就是根据这个样本的特征，在每棵树中会落到对应的一个叶子节点，每个叶子节点就对应一个分数</li><li>最后只需要将每棵树对应的分数加起来就是该样本的预测值。</li></ol><p><strong>XGBoost与GDBT的联系</strong></p><ol><li>GBDT是机器学习算法，XGBoost是该算法的工程实现。</li><li>在使用CART作为基分类器时，XGBoost显式地加入了正则项来控制模型的复杂度，有利于防止过拟合，从而提高模型的泛化能力。</li><li>GBDT在模型训练时只使用了代价函数的一阶导数信息，XGBoost对代价函数进行二阶泰勒展开，可以同时使用一阶和二阶导数。</li><li>传统的GBDT采用CART作为基分类器，XGBoost支持多种类型的基分类 器，比如线性分类器。</li><li>传统的GBDT在每轮迭代时使用全部的数据，XGBoost则采用了与随机森林相似的策略，支持对数据进行采样。</li><li>传统的GBDT没有设计对缺失值进行处理，XGBoost能够自动学习出缺失值的处理策略。</li></ol><h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><p><strong>简单demo</strong>：<a href="https://juejin.cn/post/7126012972039667720">https://juejin.cn/post/7126012972039667720</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># load module</span></span><br><span class="line"><span class="keyword">from</span> xgboost.sklearn <span class="keyword">import</span> XGBClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score</span><br><span class="line"><span class="keyword">from</span> xgboost <span class="keyword">import</span> plot_importance</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># load datasets</span></span><br><span class="line">data = datasets.load_digits()</span><br><span class="line"><span class="built_in">print</span>(data.data)</span><br><span class="line"><span class="built_in">print</span>(data.target)</span><br><span class="line"></span><br><span class="line"><span class="comment"># data analysis</span></span><br><span class="line"><span class="built_in">print</span>(data.data.shape)</span><br><span class="line"><span class="built_in">print</span>(data.target.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># data split</span></span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(data.data,</span><br><span class="line">                                                    data.target,</span><br><span class="line">                                                    test_size=<span class="number">0.3</span>,</span><br><span class="line">                                                    random_state=<span class="number">33</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># fit model for train data</span></span><br><span class="line"><span class="comment"># 所有的参数都是放在XGBClassifier()这个类中，得到初始化的模型对象xgb_class_model</span></span><br><span class="line"><span class="comment"># 建立模型</span></span><br><span class="line">xgb_class_model = XGBClassifier(learning_rate=<span class="number">0.1</span>,</span><br><span class="line">                      n_estimators=<span class="number">1000</span>,  <span class="comment"># 树的个数--1000棵树建立xgboost</span></span><br><span class="line">                      max_depth=<span class="number">6</span>,  <span class="comment"># 树的深度</span></span><br><span class="line">                      min_child_weight=<span class="number">1</span>,  <span class="comment"># 叶子节点最小权重</span></span><br><span class="line">                      gamma=<span class="number">0.</span>,  <span class="comment"># 惩罚项中叶子结点个数前的参数</span></span><br><span class="line">                      subsample=<span class="number">0.8</span>,  <span class="comment"># 随机选择80%样本建立决策树</span></span><br><span class="line">                      colsample_btree=<span class="number">0.8</span>,  <span class="comment"># 随机选择80%特征建立决策树</span></span><br><span class="line">                      objective=<span class="string">&#x27;multi:softmax&#x27;</span>,  <span class="comment"># 指定目标函数，多分类</span></span><br><span class="line">                      scale_pos_weight=<span class="number">1</span>,  <span class="comment"># 解决样本个数不平衡的问题</span></span><br><span class="line">                      random_state=<span class="number">27</span>  <span class="comment"># 随机数</span></span><br><span class="line">                      )</span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">xgb_class_model.fit(x_train,</span><br><span class="line">                    y_train,</span><br><span class="line">                    eval_set=[(x_test, y_test)],</span><br><span class="line">                    eval_metric=<span class="string">&quot;mlogloss&quot;</span>,</span><br><span class="line">                    early_stopping_rounds=<span class="number">10</span>,</span><br><span class="line">                    verbose=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># plot feature importance</span></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">15</span>, <span class="number">15</span>))</span><br><span class="line">plot_importance(model,</span><br><span class="line">                height=<span class="number">0.5</span>,</span><br><span class="line">                ax=ax,</span><br><span class="line">                max_num_features=<span class="number">64</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># make prediction for test data</span></span><br><span class="line">y_pred = xgb_class_model.predict(x_test)  </span><br><span class="line"><span class="comment"># 这里是直接给出类型，predict_proba()函数是给出属于每个类别的概率。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># model evaluate</span></span><br><span class="line">accuracy = accuracy_score(y_test, y_pred)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;accuarcy: %.2f%%&quot;</span> % (accuracy * <span class="number">100.0</span>))</span><br></pre></td></tr></table></figure><p><strong>项目三</strong></p><p>一些参数理解：<a href="https://www.cnblogs.com/TimVerion/p/11436001.html">https://www.cnblogs.com/TimVerion/p/11436001.html</a></p><p><strong>L1 正则化</strong>就像给模型的每个系数施加了一个“成本”。系数越接近 0，其成本就越低。这鼓励模型选择更少的非零系数，从而产生一个更稀疏的模型。</p><p><strong>L2 正则化（岭回归）</strong>是一种正则化技术，通过向模型的损失函数添加一个正则化项来实现，该项惩罚模型中系数的平方和。 L2 正则化就像给模型的每个系数施加了一个“成本”。 系数越大，其成本就越高。 这鼓励模型选择较小的系数，从而产生一个更平滑的模型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 模型训练</span></span><br><span class="line"><span class="keyword">from</span> xgboost <span class="keyword">import</span> XGBClassifier</span><br><span class="line">model = XGBClassifier(booster=<span class="string">&#x27;gbtree&#x27;</span>,learning_rate=<span class="number">0.1</span>,gamma=<span class="number">1</span>,scale_pos_weight=<span class="number">1</span>,n_estimators=<span class="number">1000</span>,max_depth=<span class="number">6</span>,alpha=<span class="number">5</span>,reg_lambda=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># n_estimators=1000：提升迭代次数，即模型中的树的数量。</span></span><br><span class="line"><span class="comment"># alpha=5：L1正则化项系数</span></span><br><span class="line"><span class="comment"># reg_lambda=1：L2正则化项系数</span></span><br><span class="line">eval_set = [(X_test, y_test)]</span><br><span class="line">model.fit(X_train, y_train, early_stopping_rounds=<span class="number">10</span>, eval_metric=<span class="string">&quot;auc&quot;</span>, eval_set=eval_set, verbose=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># early_stopping_rounds=10: 这个参数用于提前停止训练。这有助于防止过拟合，并节省计算资源</span></span><br><span class="line"><span class="comment"># eval_metric=&quot;auc&quot; 这是用于评估模型性能的指标。在这个例子中，使用了 AUC（Area Under the Curve）作为评价指标。AUC 是用于评估分类模型性能的一个常用指标，特别是在处理不平衡数据集时。</span></span><br><span class="line"><span class="comment"># 当 verbose=True 时，训练过程中的信息（如迭代次数、损失值等）会被打印出来。设置为 False 则不会打印这些信息，使输出更简洁。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 评价指标</span></span><br><span class="line">y_pred = model.predict(X_test)</span><br><span class="line">y_socre = model.predict_proba(X_test)[:,<span class="number">1</span>]</span><br><span class="line">predictions = [<span class="built_in">round</span>(value) <span class="keyword">for</span> value <span class="keyword">in</span> y_pred]</span><br><span class="line">Get_report(y_test,y_pred)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>交叉验证调参</strong>：<a href="https://juejin.cn/post/7126012972039667720">https://juejin.cn/post/7126012972039667720</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xgboost <span class="keyword">as</span> xgb</span><br><span class="line"></span><br><span class="line">xgb_param = model.get_xgb_params()</span><br><span class="line">xgtrain = xgb.DMatrix(x_train, label=y_train)</span><br><span class="line">cvresult = xgb.cv(xgb_param, xgtrain, num_boost_round=<span class="number">5000</span>, nfold=<span class="number">5</span>, metrics=[<span class="string">&#x27;mlogloss&#x27;</span>], </span><br><span class="line">     early_stopping_rounds=<span class="number">50</span>, stratified=<span class="literal">True</span>, seed=<span class="number">1301</span>)</span><br><span class="line"><span class="comment">#交叉验证后最好的树</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Best number of trees = &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(cvresult.shape[<span class="number">0</span>]))</span><br><span class="line">model.set_params(n_estimators=cvresult.shape[<span class="number">0</span>])<span class="comment">#把model的参数设置成最好的树对应的参数</span></span><br><span class="line"><span class="comment"># 下面进行相同方式的结果展现</span></span><br><span class="line">fig,ax = plt.subplots(figsize=(<span class="number">15</span>,<span class="number">15</span>))</span><br><span class="line">plot_importance(model, height=<span class="number">0.5</span>, ax=ax, max_num_features=<span class="number">64</span>)</span><br><span class="line">plt.show()</span><br><span class="line"> </span><br><span class="line"><span class="comment">### 预测</span></span><br><span class="line">y_pred = model.predict(x_test)</span><br><span class="line"> </span><br><span class="line"><span class="comment">### 模型正确率</span></span><br><span class="line">accuracy = accuracy_score(y_test,y_pred)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;准确率: %.2f%%&quot;</span> % (accuracy*<span class="number">100.0</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="KNN模型"><a href="#KNN模型" class="headerlink" title="KNN模型"></a>KNN模型</h3><h4 id="原理理解：-1"><a href="#原理理解：-1" class="headerlink" title="原理理解："></a>原理理解：</h4><p><a href="https://blog.csdn.net/havefun00/article/details/79474128?ops_request_misc=%7B%22request_id%22:%22171196287216800226568753%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=171196287216800226568753&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-79474128-null-null.142%5Ev100%5Econtrol&utm_term=KNN%E6%A8%A1%E5%9E%8B&spm=1018.2226.3001.4187">机器学习之K近邻（KNN）模型_knn模型-CSDN博客</a></p><p>​    如果一个样本在特征空间中的k个最相似(即特征空间中最邻近)的样本中的大多数属于某一个类别，则该样本也属于这个类别。</p><p>​    KNN算法可用于多分类，KNN算法不仅可以用于分类，还可以用于回归。通过找出一个样本的k个最近邻居，将这些邻居的属性的平均值赋给该样本，作为预测值。</p><h4 id="代码模版：-1"><a href="#代码模版：-1" class="headerlink" title="代码模版："></a>代码模版：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier  </span><br><span class="line">y = df_new[<span class="string">&#x27;default.payment.next.month&#x27;</span>]</span><br><span class="line">X = df_new.drop(columns=[<span class="string">&#x27;ID&#x27;</span>,<span class="string">&#x27;default.payment.next.month&#x27;</span>]) <span class="comment"># 不要无关、x轴的属性</span></span><br><span class="line">X_train, X_test,y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.3</span>, random_state=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># n_neighbors</span></span><br><span class="line">knn_model = KNeighborsClassifier(n_neighbors=<span class="number">3</span>)</span><br><span class="line">knn_model.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证相关效果的时候可以看  常见评价指标-混淆矩阵哪里</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用predict方法获取模型对每一个测试集样本标签的预测结果knn_pred。用predict_proba方法获取模型把每一个样本划分为正类的概率knn_score。</span></span><br><span class="line">knn_score = knn_model.predict_proba(X_test)[:,<span class="number">1</span>]</span><br><span class="line">knn_pred = knn_model.predict(X_test)</span><br><span class="line">Get_report(y_test , knn_pred)</span><br></pre></td></tr></table></figure><h3 id="KMeans聚类"><a href="#KMeans聚类" class="headerlink" title="KMeans聚类"></a>KMeans聚类</h3><h4 id="相关理解：-2"><a href="#相关理解：-2" class="headerlink" title="相关理解："></a>相关理解：</h4><p><a href="https://www.cnblogs.com/pinard/p/6164214.html">https://www.cnblogs.com/pinard/p/6164214.html</a></p><p>​    K-means聚类：对于给定的样本集A，按照样本之间的距离大小，将样本集A划分为K个簇A_1,A_2,⋯,A_K。让这些簇内的点尽量紧密的连在一起，而让簇间的距离尽量的大。</p><p>​    K-Means算法是无监督的聚类算法。目的是使得每个点都属于离它最近的均值（此即聚类中心）对应的簇A_i中。</p><p>   <strong>K-means 的算法步骤为：</strong></p><ol><li><p>选择初始化的 k 个样本作为初始聚类中心 a&#x3D;a1,a2,…ak ；</p></li><li><p>针对数据集中每个样本 xi计算它到 k 个聚类中心的距离并将其分到<strong>距离最小</strong>的聚类中心所对应的类中；</p></li><li><p>针对每个类别 aj，重新计算它的聚类中心 aj&#x3D;1&#x2F;ci *∑(x∈ci)(x) （即属于该类的所有样本的质心）；</p></li><li><p>重复上面 2 3 两步操作，直到达到某个中止条件（迭代次数、最小误差变化等）。</p></li></ol><p><a href="https://zhuanlan.zhihu.com/p/78798251">https://zhuanlan.zhihu.com/p/78798251</a></p><p>​    为了更好的聚类结果，开始时要对数据进行归一化、标准化，对于异常值要进行异常值检测，之后要合理选择k值，常见方法有手肘法或者 Gap statistic 方法</p><h4 id="代码模版：-2"><a href="#代码模版：-2" class="headerlink" title="代码模版："></a>代码模版：</h4><p><strong>参看项目六</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line"><span class="comment">## 参数聚类数目`n_clusters = 3`，随机种子`random_state = 0`。</span></span><br><span class="line"><span class="comment">## 对word_vectors进行k均值聚类</span></span><br><span class="line">kmeans = KMeans(n_clusters=<span class="number">3</span>, random_state=<span class="number">0</span>).fit(word_vectors)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 聚类得到的类别</span></span><br><span class="line">kmean_labels = data[[<span class="string">&quot;chapter_name&quot;</span>,<span class="string">&quot;chapter&quot;</span>]]</span><br><span class="line">kmean_labels[<span class="string">&quot;cluster&quot;</span>] = kmeans.labels_</span><br><span class="line">kmean_labels</span><br></pre></td></tr></table></figure><p><strong>demo</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">4</span>], [<span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line"><span class="meta">... </span>              [<span class="number">10</span>, <span class="number">2</span>], [<span class="number">10</span>, <span class="number">4</span>], [<span class="number">10</span>, <span class="number">0</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kmeans = KMeans(n_clusters=<span class="number">2</span>, random_state=<span class="number">0</span>).fit(X)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kmeans.labels_</span><br><span class="line">array([<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], dtype=int32)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kmeans.predict([[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">12</span>, <span class="number">3</span>]])</span><br><span class="line">array([<span class="number">1</span>, <span class="number">0</span>], dtype=int32)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kmeans.cluster_centers_</span><br><span class="line">array([[<span class="number">10.</span>,  <span class="number">2.</span>],</span><br><span class="line">       [ <span class="number">1.</span>,  <span class="number">2.</span>]])</span><br></pre></td></tr></table></figure><p>更具体的实现：<a href="https://blog.51cto.com/u_12617333/5358268">https://blog.51cto.com/u_12617333/5358268</a></p><h3 id="主成分分析PCA"><a href="#主成分分析PCA" class="headerlink" title="主成分分析PCA"></a>主成分分析PCA</h3><h4 id="相关理解：-3"><a href="#相关理解：-3" class="headerlink" title="相关理解："></a>相关理解：</h4><p>​    PCA降维是一种常见的数据降维方法，其目的是在“信息”损失较小的前提下，将高维的数据转换到低维，从而减小计算量。PCA通常用于高维数据集的探索与可视化，还可以用于数据压缩，数据预处理等。</p><p>​    PCA的一般步骤是：先对原始数据零均值化，然后求<a href="https://so.csdn.net/so/search?q=%E5%8D%8F%E6%96%B9%E5%B7%AE&spm=1001.2101.3001.7020">协方差</a>矩阵，接着对协方差矩阵求特征向量和特征值，这些特征向量组成了新的特征空间。</p><h4 id="代码模版：-3"><a href="#代码模版：-3" class="headerlink" title="代码模版："></a>代码模版：</h4><p><strong>参看项目六</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line"></span><br><span class="line"><span class="comment">## 使用PCA对数据进行降维</span></span><br><span class="line">pca = PCA(n_components=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">pca.fit(word_vectors)</span><br><span class="line"><span class="built_in">print</span>(pca.explained_variance_ratio_)</span><br><span class="line"><span class="comment">## 对数据降维</span></span><br><span class="line">pca_results = pca.fit_transform(word_vectors)</span><br><span class="line"><span class="built_in">print</span>(pca_results.shape)</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># [0.037004   0.02803814]</span></span><br><span class="line"><span class="comment"># (120, 2)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># explained_variance_ratio_参数解释 </span></span><br><span class="line"><span class="comment"># explained_variance_ratio_ 是一个用于主成分分析（PCA）的函数，它返回每个主成分解释的方差百分比。在使用PCA进行特征降维时，我们通常会使用explained_variance_ratio_ 函数来选择要保留的主成分数量。</span></span><br><span class="line"><span class="comment"># 具体来说，explained_variance_ratio_ 函数返回一个数组，其中包含每个主成分解释的方差百分比。例如，如果我们对一个数据集应用PCA，并得到了5个主成分，那么 explained_variance_ratio_ 函数将返回一个长度为5的数组，每个元素表示一个主成分解释的方差百分比。</span></span><br><span class="line"><span class="comment"># 通过检查这个数组，我们可以确定哪些主成分对数据集的方差贡献最大，从而选择保留哪些主成分以保留足够的信息。通常，我们选择保留解释方差比较高的主成分，例如解释方差累积达到总方差的95%或以上的主成分。</span></span><br><span class="line"><span class="comment"># 需要注意的是，使用 explained_variance_ratio_ 函数仅仅是选择主成分的一种方法，我们还可以使用其他的选择方法，例如手动设置保留的主成分数量或使用其他评估指标。因此，在进行PCA特征降维时，需要根据具体情况选择合适的方法。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 绘制降维后的结果， 可用于评价聚类效果</span></span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>,<span class="number">8</span>))</span><br><span class="line">plt.scatter(pca_results[:,<span class="number">0</span>],pca_results[:,<span class="number">1</span>],c = kmean_labels.cluster)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> np.arange(<span class="number">120</span>):</span><br><span class="line">    plt.text(pca_results[i,<span class="number">0</span>]+<span class="number">0.02</span>,pca_results[i,<span class="number">1</span>],s = data.chapter_number[i])</span><br><span class="line">    </span><br><span class="line">plt.xlabel(<span class="string">&quot;主成分1&quot;</span>)   </span><br><span class="line">plt.ylabel(<span class="string">&quot;主成分2&quot;</span>)  </span><br><span class="line">plt.title(<span class="string">&quot;K-means PCA&quot;</span>)  </span><br><span class="line">plt.show() </span><br></pre></td></tr></table></figure><p><strong>demo</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line">X = np.array([[-<span class="number">1</span>, -<span class="number">1</span>], [-<span class="number">2</span>, -<span class="number">1</span>], [-<span class="number">3</span>, -<span class="number">2</span>], [<span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">1</span>], [<span class="number">3</span>, <span class="number">2</span>]])</span><br><span class="line">pca = PCA(n_components=<span class="number">2</span>)</span><br><span class="line">newX = pca.fit_transform(X)     <span class="comment">#等价于pca.fit(X) pca.transform(X)</span></span><br><span class="line">invX = pca.inverse_transform(newX)  <span class="comment">#将降维后的数据转换成原始数据</span></span><br><span class="line"><span class="built_in">print</span>(X)</span><br><span class="line">    [[-<span class="number">1</span> -<span class="number">1</span>]</span><br><span class="line">     [-<span class="number">2</span> -<span class="number">1</span>]</span><br><span class="line">     [-<span class="number">3</span> -<span class="number">2</span>]</span><br><span class="line">     [ <span class="number">1</span>  <span class="number">1</span>]</span><br><span class="line">     [ <span class="number">2</span>  <span class="number">1</span>]</span><br><span class="line">     [ <span class="number">3</span>  <span class="number">2</span>]]</span><br><span class="line"><span class="built_in">print</span>(newX）</span><br><span class="line">    array([[ <span class="number">1.38340578</span>,  <span class="number">0.2935787</span> ],</span><br><span class="line">           [ <span class="number">2.22189802</span>, -<span class="number">0.25133484</span>],</span><br><span class="line">           [ <span class="number">3.6053038</span> ,  <span class="number">0.04224385</span>],</span><br><span class="line">           [-<span class="number">1.38340578</span>, -<span class="number">0.2935787</span> ],</span><br><span class="line">           [-<span class="number">2.22189802</span>,  <span class="number">0.25133484</span>],</span><br><span class="line">           [-<span class="number">3.6053038</span> , -<span class="number">0.04224385</span>]])</span><br><span class="line"><span class="built_in">print</span>(invX)</span><br><span class="line">    [[-<span class="number">1</span> -<span class="number">1</span>]</span><br><span class="line">     [-<span class="number">2</span> -<span class="number">1</span>]</span><br><span class="line">     [-<span class="number">3</span> -<span class="number">2</span>]</span><br><span class="line">     [ <span class="number">1</span>  <span class="number">1</span>]</span><br><span class="line">     [ <span class="number">2</span>  <span class="number">1</span>]</span><br><span class="line">     [ <span class="number">3</span>  <span class="number">2</span>]]</span><br><span class="line"><span class="built_in">print</span>(pca.explained_variance_ratio_)</span><br><span class="line">    [ <span class="number">0.99244289</span>  <span class="number">0.00755711</span>]</span><br></pre></td></tr></table></figure><p>更详细的解释：<a href="https://blog.csdn.net/qq_20135597/article/details/95247381">【python】sklearn中PCA的使用方法_from sklearn.decomposition import pca-CSDN博客</a></p><h3 id="层次聚类-Hierarchical-Clustering"><a href="#层次聚类-Hierarchical-Clustering" class="headerlink" title="层次聚类(Hierarchical Clustering)"></a>层次聚类(Hierarchical Clustering)</h3><h4 id="理解："><a href="#理解：" class="headerlink" title="理解："></a>理解：</h4><p>​    层次聚类(Hierarchical Clustering)是聚类算法的一种，通过计算不同类别数据点间的相似度来创建一棵有层次的嵌套聚类树。在聚类树中，不同类别的原始数据点是树的最低层，树的顶层是一个聚类的根节点。</p><h4 id="模版："><a href="#模版：" class="headerlink" title="模版："></a>模版：</h4><p><strong>参照项目六</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.cluster.hierarchy <span class="keyword">import</span> dendrogram,ward</span><br><span class="line"><span class="keyword">from</span> scipy.spatial.distance <span class="keyword">import</span> pdist,squareform</span><br><span class="line"></span><br><span class="line"><span class="comment">## 标签，每个章节的标题</span></span><br><span class="line">labels = data.chapter_number.values</span><br><span class="line"></span><br><span class="line"><span class="comment">#计算每章的距离矩阵</span></span><br><span class="line">cos_distance_matrix = squareform(pdist(word_vectors,<span class="string">&#x27;cosine&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">## 根据距离聚类</span></span><br><span class="line">ward_results = ward(cos_distance_matrix)  </span><br><span class="line"></span><br><span class="line"><span class="comment">## 聚类结果可视化</span></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">10</span>, <span class="number">15</span>))</span><br><span class="line"></span><br><span class="line">ax = dendrogram(ward_results,orientation=<span class="string">&#x27;right&#x27;</span>, labels=labels);</span><br><span class="line">plt.yticks(size = <span class="number">8</span>)</span><br><span class="line">plt.title(<span class="string">&quot;红楼梦各章节层次聚类&quot;</span>)</span><br><span class="line"></span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()   </span><br></pre></td></tr></table></figure><h2 id="如何选择模型"><a href="#如何选择模型" class="headerlink" title="如何选择模型"></a>如何选择模型</h2><p><a href="https://www.cnblogs.com/pinard/p/5992719.html">https://www.cnblogs.com/pinard/p/5992719.html</a></p><h2 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h2><p>以Sklearn中的SelectKBest为例</p><h3 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h3><p><strong>可参考项目三</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectKBest</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> chi2</span><br><span class="line"></span><br><span class="line">y = df[<span class="string">&#x27;default.payment.next.month&#x27;</span>]</span><br><span class="line">X = df[[<span class="string">&#x27;SEX&#x27;</span>,<span class="string">&#x27;EDUCATION&#x27;</span>,<span class="string">&#x27;MARRIAGE&#x27;</span>]]</span><br><span class="line"></span><br><span class="line">chi2_selector = SelectKBest(chi2, k=<span class="number">2</span>)</span><br><span class="line">chi2_selector.fit(X, y)</span><br><span class="line"><span class="comment"># 给出x对应的卡方得分</span></span><br><span class="line">chi2_selector.scores_</span><br><span class="line"><span class="comment"># 属性保存了每个特征的卡方检验的p值</span></span><br><span class="line"><span class="comment"># 如果p值很小（通常小于某个显著性水平，如0.05或0.01），则我们拒绝原假设，认为该特征与目标变量之间存在显著的关联性。</span></span><br><span class="line">chi2_selector.pvalues_</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>demo</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectKBest, chi2  </span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 加载iris数据集  </span></span><br><span class="line">iris = load_iris()  </span><br><span class="line">X, y = iris.data, iris.target  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 初始化SelectKBest对象，使用chi2作为得分函数  </span></span><br><span class="line">chi2_selector = SelectKBest(score_func=chi2, k=<span class="number">2</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 拟合模型  </span></span><br><span class="line">chi2_selector.fit(X, y)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 输出每个特征的p值  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;P-values for each feature:&quot;</span>, chi2_selector.pvalues_)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 转换特征，只保留得分最高的k个特征  </span></span><br><span class="line">X_new = chi2_selector.transform(X)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 输出选定的特征索引  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Selected feature indices:&quot;</span>, chi2_selector.get_support(indices=<span class="literal">True</span>))</span><br></pre></td></tr></table></figure><h2 id="如何进行参数调优"><a href="#如何进行参数调优" class="headerlink" title="如何进行参数调优"></a>如何进行参数调优</h2><h3 id="相关指标"><a href="#相关指标" class="headerlink" title="相关指标"></a>相关指标</h3><h3 id="交叉验证demo："><a href="#交叉验证demo：" class="headerlink" title="交叉验证demo："></a>交叉验证demo：</h3><h2 id="常见的评价指标"><a href="#常见的评价指标" class="headerlink" title="常见的评价指标"></a>常见的评价指标</h2><h3 id="混淆矩阵"><a href="#混淆矩阵" class="headerlink" title="混淆矩阵"></a>混淆矩阵</h3><p>分类预测时，可以对训练完后的模型进行观察效果。</p><p><img src="/%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5.png" alt="混淆矩阵"></p><h4 id="准确率（Accuracy）"><a href="#准确率（Accuracy）" class="headerlink" title="准确率（Accuracy）"></a>准确率（Accuracy）</h4><p>顾名思义，就是所有的预测正确（正类负类）的占总的比重。</p><p>&#x3D;(TP+TN)&#x2F;(TP+TN+FP+FN)</p><h4 id="精确率（Precision）"><a href="#精确率（Precision）" class="headerlink" title="精确率（Precision）"></a>精确率（Precision）</h4><p>即查准率。即正确预测为正的占全部预测为正的比例。个人理解：真正正确的占所有预测为正的比例。</p><p>&#x3D;TP&#x2F;(TP+FP)</p><h4 id="召回率（Recall）"><a href="#召回率（Recall）" class="headerlink" title="召回率（Recall）"></a>召回率（Recall）</h4><p>即查全率。即正确预测为正的占全部实际为正的比例。个人理解：真正正确的占所有实际为正的比例。</p><p>&#x3D;TP&#x2F;(TP+FN)</p><h4 id="F1值"><a href="#F1值" class="headerlink" title="F1值"></a>F1值</h4><p>  F1值（F1 Score）是用于综合评估分类模型性能的指标，它结合了精确率（Precision）和召回率（Recall）。F1值是精确率和召回率的调和平均数，它可以用来衡量模型在保持精确率和召回率之间的平衡时的性能。</p><p>F1值可以用以下公式计算：</p><p>​    F1值 &#x3D; 2 * (精确率* 召回率) &#x2F; (精确率 + 召回率)&#x3D; 2* TP&#x2F;(2 * TP+FP+FN)</p><p>F1值的取值范围是0到1，<strong>其中1表示最佳性能，0表示最差性能。</strong></p><h4 id="AUC值"><a href="#AUC值" class="headerlink" title="AUC值"></a>AUC值</h4><p><strong>AUC值越大的分类器，正确率越高。</strong></p><p>从AUC判断分类器（预测模型）优劣的标准：</p><ol><li><p>AUC &#x3D; 1，是完美分类器，采用这个预测模型时，存在至少一个阈值能得出完美预测。绝大多数预测的场合，不存在完美分类器。</p></li><li><p>0.5 &lt; AUC &lt; 1，优于随机猜测。这个分类器（模型）妥善设定阈值的话，能有预测价值。</p></li><li><p>AUC &#x3D; 0.5，跟随机猜测一样（例：丢铜板），模型没有预测价值。</p></li><li><p>AUC &lt; 0.5，比随机猜测还差；但只要总是反预测而行，就优于随机猜测。</p></li></ol><h4 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 继续KNN模型哪里，</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用predict方法获取模型对每一个测试集样本标签的预测结果knn_pred。用predict_proba方法获取模型把每一个样本划分为正类的概率knn_score。</span></span><br><span class="line">knn_score = knn_model.predict_proba(X_test)[:,<span class="number">1</span>]</span><br><span class="line">knn_pred = knn_model.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个函数来获取AUC Score和混淆矩阵</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Get_report</span>(<span class="params">testers , predictors</span>):</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&#x27;模型的AUC Score为：&#123;a&#125;&#x27;</span>.<span class="built_in">format</span>(a=metrics.accuracy_score(testers, predictors)))</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&#x27;模型的分类报告展示如下:&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span> (metrics.classification_report(testers, predictors))</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&#x27;模型的混淆矩阵展示如下:&#x27;</span>)</span><br><span class="line">    plt.figure(figsize=(<span class="number">8</span>,<span class="number">4</span>))</span><br><span class="line">    ConfMatrix = confusion_matrix(testers, predictors)</span><br><span class="line">    sns.heatmap(ConfMatrix,annot=<span class="literal">True</span>, cmap=<span class="string">&quot;Blues&quot;</span>, fmt=<span class="string">&quot;d&quot;</span>, </span><br><span class="line">            xticklabels = [<span class="string">&#x27;未违约&#x27;</span>, <span class="string">&#x27;违约&#x27;</span>], </span><br><span class="line">            yticklabels = [<span class="string">&#x27;未违约&#x27;</span>, <span class="string">&#x27;违约&#x27;</span>])</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;真实标签&#x27;</span>)</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;预测标签&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&quot;混淆矩阵&quot;</span>)</span><br><span class="line">Get_report(y_test , knn_pred)</span><br></pre></td></tr></table></figure><h2 id="绘图常用"><a href="#绘图常用" class="headerlink" title="绘图常用"></a>绘图常用</h2><h3 id="Matplotlib-3-6-0-文档（绘图实例）"><a href="#Matplotlib-3-6-0-文档（绘图实例）" class="headerlink" title="Matplotlib 3.6.0 文档（绘图实例）"></a>Matplotlib 3.6.0 文档（绘图实例）</h3><p><a href="https://www.matplotlib.net/stable/index.html">Matplotlib 文档_Matplotlib 中文网</a></p><h3 id="绘图相关命令"><a href="#绘图相关命令" class="headerlink" title="绘图相关命令"></a>绘图相关命令</h3><h4 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h4><p><a href="https://www.cnblogs.com/cgmcoding/p/13384535.html">https://www.cnblogs.com/cgmcoding/p/13384535.html</a></p><p><strong>简单代码</strong></p><p><strong>项目三</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">t0 = df[df[<span class="string">&#x27;default.payment.next.month&#x27;</span>] == <span class="number">0</span>]</span><br><span class="line">t1 = df[df[<span class="string">&#x27;default.payment.next.month&#x27;</span>] == <span class="number">1</span>]</span><br><span class="line">plt.figure()</span><br><span class="line">fig, ax = plt.subplots(<span class="number">1</span>,<span class="number">2</span>,figsize=(<span class="number">12</span>,<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">sns.distplot(t0[<span class="string">&#x27;AGE&#x27;</span>],kde_kws=&#123;<span class="string">&quot;color&quot;</span>:<span class="string">&quot;blue&quot;</span>,<span class="string">&quot;label&quot;</span>:<span class="string">&quot;未违约&quot;</span>&#125;)</span><br><span class="line">sns.distplot(t1[<span class="string">&#x27;AGE&#x27;</span>],kde_kws=&#123;<span class="string">&quot;color&quot;</span>:<span class="string">&quot;orange&quot;</span>,<span class="string">&quot;label&quot;</span>:<span class="string">&quot;违约&quot;</span>&#125;)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;年龄&#x27;</span>, fontsize=<span class="number">12</span>)</span><br><span class="line">locs, labels = plt.xticks()  </span><br><span class="line"><span class="comment"># 获取当前 x 轴刻度位置和标签，并将它们分别存储在 locs 和 labels 变量中。</span></span><br><span class="line"><span class="comment"># 虽然这段代码在这里并没有进行进一步的操作，但通常这样的赋值可以用于后续的刻度或标签自定义。</span></span><br><span class="line">plt.title(<span class="string">&#x27;不同年龄违约情况&#x27;</span>)</span><br><span class="line">plt.tick_params(axis=<span class="string">&#x27;both&#x27;</span>, which=<span class="string">&#x27;major&#x27;</span>, labelsize=<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">sns.distplot(t0[<span class="string">&quot;LIMIT_BAL&quot;</span>],kde_kws=&#123;<span class="string">&quot;color&quot;</span>:<span class="string">&quot;blue&quot;</span>,<span class="string">&quot;label&quot;</span>:<span class="string">&quot;未违约&quot;</span>&#125;)</span><br><span class="line">sns.distplot(t1[<span class="string">&quot;LIMIT_BAL&quot;</span>],kde_kws=&#123;<span class="string">&quot;color&quot;</span>:<span class="string">&quot;orange&quot;</span>,<span class="string">&quot;label&quot;</span>:<span class="string">&quot;违约&quot;</span>&#125;)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;信用卡额度&#x27;</span>, fontsize=<span class="number">12</span>)</span><br><span class="line">locs, labels = plt.xticks()</span><br><span class="line">plt.title(<span class="string">&#x27;不同信用卡额度违约情况&#x27;</span>)</span><br><span class="line">plt.tick_params(axis=<span class="string">&#x27;both&#x27;</span>, which=<span class="string">&#x27;major&#x27;</span>, labelsize=<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h4 id="柱状图"><a href="#柱状图" class="headerlink" title="柱状图"></a>柱状图</h4><p><a href="https://blog.csdn.net/zyb228/article/details/101303579">seaborn系列 (5) | 柱状图countplot()_countplot函数-CSDN博客</a></p><p><strong>demo：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">sns.<span class="built_in">set</span>(style=<span class="string">&quot;darkgrid&quot;</span>)</span><br><span class="line"><span class="comment"># 获取数据</span></span><br><span class="line">titanic = sns.load_dataset(<span class="string">&quot;titanic&quot;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">案例1：显示单个分类变量的值统计数</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">sns.countplot(x=<span class="string">&quot;属性&quot;</span>, data=titanic) <span class="comment"># 可以是y，横向展示数据情况</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h4 id="箱型图"><a href="#箱型图" class="headerlink" title="箱型图"></a>箱型图</h4><p><a href="https://blog.csdn.net/weixin_44052055/article/details/121442449">python绘制箱线图boxplot()_python boxplot-CSDN博客</a></p><p><img src="/%E7%AE%B1%E5%9E%8B%E5%9B%BE.png" alt="箱型图"></p><p><strong>demo</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 绘制多个不同指标的箱型图</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">fig, ax =plt.subplots(<span class="number">3</span>,<span class="number">1</span>,figsize=(<span class="number">8</span>,<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置颜色</span></span><br><span class="line">my_colors = [<span class="string">&quot;#F1B5B9&quot;</span>, <span class="string">&quot;#AAC8D1&quot;</span>]</span><br><span class="line">sns.set_palette( my_colors )</span><br><span class="line"></span><br><span class="line">sns.boxplot(x=<span class="string">&#x27;day&#x27;</span>,y=<span class="string">&#x27;actual_productivity&#x27;</span>,data=garments,hue=<span class="string">&#x27;department&#x27;</span>, order=[<span class="string">&#x27;Monday&#x27;</span>,<span class="string">&#x27;Tuesday&#x27;</span>,<span class="string">&#x27;Wednesday&#x27;</span>,<span class="string">&#x27;Thursday&#x27;</span>,<span class="string">&#x27;Saturday&#x27;</span>,<span class="string">&#x27;Sunday&#x27;</span>], ax=ax[<span class="number">0</span>])</span><br><span class="line">sns.boxplot(x=<span class="string">&#x27;quarter&#x27;</span>,y=<span class="string">&#x27;actual_productivity&#x27;</span>,data=garments,hue=<span class="string">&#x27;department&#x27;</span>, ax=ax[<span class="number">1</span>])</span><br><span class="line">sns.boxplot(x=<span class="string">&#x27;month&#x27;</span>,y=<span class="string">&#x27;actual_productivity&#x27;</span>,data=garments,hue=<span class="string">&#x27;department&#x27;</span>, ax=ax[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">ax[<span class="number">0</span>].set_title(<span class="string">&#x27;不同星期对员工生产率的影响&#x27;</span>,size=<span class="number">15</span>)</span><br><span class="line">ax[<span class="number">1</span>].set_title(<span class="string">&#x27;每月各周对员工生产率的影响&#x27;</span>,size=<span class="number">15</span>)</span><br><span class="line">ax[<span class="number">2</span>].set_title(<span class="string">&#x27;不同月份对员工生产率的影响&#x27;</span>,size=<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line">ax[<span class="number">0</span>].legend(loc=<span class="string">&#x27;lower right&#x27;</span>)</span><br><span class="line">ax[<span class="number">1</span>].legend(loc=<span class="string">&#x27;lower right&#x27;</span>)</span><br><span class="line">ax[<span class="number">2</span>].legend(loc=<span class="string">&#x27;lower right&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置默认的间距</span></span><br><span class="line">plt.tight_layout() </span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="关于工程问题"><a href="#关于工程问题" class="headerlink" title="关于工程问题"></a>关于工程问题</h2><h3 id="使用requirements-txt安装依赖"><a href="#使用requirements-txt安装依赖" class="headerlink" title="使用requirements.txt安装依赖"></a>使用requirements.txt安装依赖</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><h3 id="setup-py安装问题"><a href="#setup-py安装问题" class="headerlink" title="setup.py安装问题"></a>setup.py安装问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python setup.py install</span><br></pre></td></tr></table></figure><h3 id="pyinstaller打包"><a href="#pyinstaller打包" class="headerlink" title="pyinstaller打包"></a>pyinstaller打包</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pip install pyinstaller</span><br><span class="line"></span><br><span class="line">pyinstaller example.py -F -p C:/python/lib/site-packages</span><br><span class="line"></span><br><span class="line">pyinstaller -F -w 自己的py名字.py</span><br></pre></td></tr></table></figure><h2 id="很不错的笔记参考"><a href="#很不错的笔记参考" class="headerlink" title="很不错的笔记参考"></a>很不错的笔记参考</h2><p><a href="https://hg95.github.io/sklearn-notes/model_selection/%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%8D%AE%E9%9B%86%E5%88%92%E5%88%86ShuffleSplit.html">https://hg95.github.io/sklearn-notes/model_selection/%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%8D%AE%E9%9B%86%E5%88%92%E5%88%86ShuffleSplit.html</a></p><p><a href="https://paddlepedia.readthedocs.io/en/latest/tutorials/computer_vision/index.html">https://paddlepedia.readthedocs.io/en/latest/tutorials/computer_vision/index.html</a></p><h1 id="相关项目"><a href="#相关项目" class="headerlink" title="相关项目"></a>相关项目</h1><h2 id="项目一：基于机器学习的欧洲五大足球联赛结果的分析与预测系统"><a href="#项目一：基于机器学习的欧洲五大足球联赛结果的分析与预测系统" class="headerlink" title="项目一：基于机器学习的欧洲五大足球联赛结果的分析与预测系统"></a><strong>项目一：基于机器学习的欧洲五大足球联赛结果的分析与预测系统</strong></h2><p>​     本项目是个参赛项目不便公开</p><h2 id="项目二：基于KMeans聚类算法的企业数据挖掘及其可视化"><a href="#项目二：基于KMeans聚类算法的企业数据挖掘及其可视化" class="headerlink" title="项目二：基于KMeans聚类算法的企业数据挖掘及其可视化"></a><strong>项目二：基于KMeans聚类算法的企业数据挖掘及其可视化</strong></h2><p>​    本项目是跟着老师做的，内容也不便公开</p><h2 id="项目三：信用卡用户贷款违约预测"><a href="#项目三：信用卡用户贷款违约预测" class="headerlink" title="项目三：信用卡用户贷款违约预测"></a><strong>项目三：信用卡用户贷款违约预测</strong></h2><p>github链接：</p><h3 id="相关内容："><a href="#相关内容：" class="headerlink" title="相关内容："></a>相关内容：</h3><p>​    本项目使用的数据集为信用卡客户数据，具体的数据包括：每位客户案例的编号、客户的信用卡额度、性别、受教育程度、婚姻状况、年龄、在记录数据期间(2005年4-9月)每个月的还款情况、账单记录和支付记录，以及该客户在接下来的一个月中违约与否的记录。</p><p>​    本项目开始对数据进行数据信息检查，数据清洗，对数据可视化与分析，并对数据进行建模，使用了KNN模型，决策树模型，XGBoost模型，并结合混淆矩阵对不同模型进行评价。</p><h2 id="项目四：多维度多模型下的用户行为分析"><a href="#项目四：多维度多模型下的用户行为分析" class="headerlink" title="项目四：多维度多模型下的用户行为分析"></a><strong>项目四：多维度多模型下的用户行为分析</strong></h2><p>github链接：</p><h3 id="相关内容：-1"><a href="#相关内容：-1" class="headerlink" title="相关内容："></a>相关内容：</h3><h2 id="项目五：短视频APP活跃用户预测"><a href="#项目五：短视频APP活跃用户预测" class="headerlink" title="项目五：短视频APP活跃用户预测"></a><strong>项目五：短视频APP活跃用户预测</strong></h2><p>github链接：</p><h3 id="相关内容：-2"><a href="#相关内容：-2" class="headerlink" title="相关内容："></a>相关内容：</h3><p>​    </p><h2 id="项目六：基于KMeans聚类算法的红楼梦文本分析"><a href="#项目六：基于KMeans聚类算法的红楼梦文本分析" class="headerlink" title="项目六：基于KMeans聚类算法的红楼梦文本分析"></a><strong>项目六：基于KMeans聚类算法的红楼梦文本分析</strong></h2><p>github链接：</p><h3 id="相关内容：-3"><a href="#相关内容：-3" class="headerlink" title="相关内容："></a>相关内容：</h3><p>​    在本项目中，我们首先对红楼梦120回的文本数据进行了清洗和格式的整理；接着宏观的分析了其中的章节结构、次数和字数等基本情况；然后通过分词、分析词频并通过可视化的方法进行展示；最后通过两种聚类方法对各章节的文本进行聚类，使用两种降维方式对聚类结果进行验证和可视化。《红楼梦》被评为中国古典章回小说的巅峰之作，思想价值和艺术价值极高。关于红楼梦的研究一直是中国传统文学的热点，红学家们众说纷纭，思想观点百花齐放，在此案例中我们从统计分析和文本挖掘等角度对红楼梦进行了一些简单的分析。此外关于小说中人物的社交关系也是一大热点。    </p><p>​    本项目完成对红楼梦原著的提取分析工作，使用正则表达式，提取文章内容、每章标题，之后完成对数据的清洗统计工作，并使用TF-IDF提取关键词，使用KMeans聚类算法，利用PCA降维算法，也是用了层次聚类的方法可视化关系，最后对于结果进行可视化分析。</p><p>​    本项目最大的特色是如何处理文本内容。</p><h2 id="项目七：利用回归模型预测服装厂员工生产效率"><a href="#项目七：利用回归模型预测服装厂员工生产效率" class="headerlink" title="项目七：利用回归模型预测服装厂员工生产效率"></a><strong>项目七：利用回归模型预测服装厂员工生产效率</strong></h2><p>​    本项目中使用了服装厂员工生产效率数据集，结合可视化分析方法探索了数据中隐藏的信息，并通过建立线性回归、回归决策树和神经网络三种模型预测员工实际生产率。</p><p>​    本项目对数据进行清洗，检测异常值并处理空值，对数据进行探索性分析，对数据进行相关性分析，并使用线性回归，回归决策树以及神经网络三种模型预测员工实际效率，最后可视化分析。</p><h2 id="其他项目"><a href="#其他项目" class="headerlink" title="其他项目"></a><strong>其他项目</strong></h2>]]></content>
      
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>部分和位置有关的题</title>
      <link href="/2024/05/02/%E9%83%A8%E5%88%86%E5%92%8C%E4%BD%8D%E7%BD%AE%E6%9C%89%E5%85%B3%E7%9A%84%E9%A2%98/"/>
      <url>/2024/05/02/%E9%83%A8%E5%88%86%E5%92%8C%E4%BD%8D%E7%BD%AE%E6%9C%89%E5%85%B3%E7%9A%84%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="和位置、大小有关的题"><a href="#和位置、大小有关的题" class="headerlink" title="和位置、大小有关的题"></a>和位置、大小有关的题</h1><h2 id="一、采用单调栈-贪心"><a href="#一、采用单调栈-贪心" class="headerlink" title="一、采用单调栈+贪心"></a>一、采用单调栈+贪心</h2><p><a href="https://ac.nowcoder.com/acm/contest/46813/F">F-小沙の串串_2023牛客寒假算法基础集训营5 (nowcoder.com)</a></p><h2 id="二、"><a href="#二、" class="headerlink" title="二、"></a>二、</h2><p><a href="https://codeforces.com/contest/1778/problem/B">Problem - B - Codeforces</a></p><p>太疲劳别打比赛，只是掉分</p><p>注意那个条件是对于所有的i，所以只需要打破其中一个的就可以了，选择最小的</p><h2 id="三、二分，审题，选和不选的全部情况"><a href="#三、二分，审题，选和不选的全部情况" class="headerlink" title="三、二分，审题，选和不选的全部情况"></a>三、二分，审题，选和不选的全部情况</h2><p><a href="https://codeforces.com/contest/1788/problem/D">Problem - D - Codeforces</a></p><p>2的多少次幂预处理，</p><h2 id="四、hash，或者stl"><a href="#四、hash，或者stl" class="headerlink" title="四、hash，或者stl"></a>四、hash，或者stl</h2><p><a href="https://codeforces.com/group/Aokqa6Haao/contest/427952/problem/J">Problem - J - Codeforces</a></p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>需要预处理筛法，快速找到质因子，用hash记录出现情况，map记录对应出现次数，ans统计答案</p><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>质因子的寻找，先预处理，循环外围sqrt，内围while，最后找完判断a[i]&gt;1?  统计答案</p><h2 id="五、二分，前缀和，差分"><a href="#五、二分，前缀和，差分" class="headerlink" title="五、二分，前缀和，差分"></a>五、二分，前缀和，差分</h2><p><a href="https://codeforces.com/contest/1795/problem/C">Problem - C - Codeforces</a></p><h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><p>每一个要逐个被后边做加法、做减法&#x3D;》逐个-二分，加法减法-前缀和</p><p>记录每个被完整加和的次数，并处理其他剩余部分即可</p><h3 id="注意：-1"><a href="#注意：-1" class="headerlink" title="注意："></a>注意：</h3><p>被完整加的次数是核心突破口</p><h2 id="六、位运算，时间戳"><a href="#六、位运算，时间戳" class="headerlink" title="六、位运算，时间戳"></a>六、位运算，时间戳</h2><p><a href="https://ac.nowcoder.com/acm/contest/52244/G">G-A Xor B Problem again_2023年中国高校计算机大赛-团队程序设计天梯赛（GPLT）上海理工大学校内选拔赛（同步赛) (nowcoder.com)</a></p><h3 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h3><p>对当前数记载个数，之后遍历每个数，对应的数是x&#x3D;(1&lt;&lt;17)-1-i,是对应数可有一的位，之后j&#x3D;(j-1)&amp;x,这样的话，就可以遍历所有对应的数，最后加和求答案</p><h3 id="注意：-2"><a href="#注意：-2" class="headerlink" title="注意："></a>注意：</h3><p>能用数组就用数组，要不然会T</p><h2 id="七、相邻位置交换，最小交换次数。"><a href="#七、相邻位置交换，最小交换次数。" class="headerlink" title="七、相邻位置交换，最小交换次数。"></a>七、相邻位置交换，最小交换次数。</h2><p><a href="https://codeforces.com/contest/1828/problem/D1">Problem - D1 - Codeforces</a></p><p>题意：最小操作使之有序，长度从1到n</p><p>优先队列或者栈操作。</p><p>大致思想就是用前边大，跨过小的，从而达到最小的要求。</p><h2 id="八、构造"><a href="#八、构造" class="headerlink" title="八、构造"></a>八、构造</h2><p><a href="https://codeforces.com/contest/1839/problem/C">Problem - C - Codeforces</a></p><h2 id="九、与字符串子串排序有关"><a href="#九、与字符串子串排序有关" class="headerlink" title="九、与字符串子串排序有关"></a>九、与字符串子串排序有关</h2><p><a href="https://codeforces.com/contest/1849/problem/C">Problem - C - Codeforces</a></p><h2 id="十、如何优化字符串部分子串获取问题-双指针，dp转移"><a href="#十、如何优化字符串部分子串获取问题-双指针，dp转移" class="headerlink" title="十、如何优化字符串部分子串获取问题-双指针，dp转移"></a>十、如何优化字符串部分子串获取问题-双指针，dp转移</h2><p><a href="https://codeforces.com/contest/1948/problem/D">Problem - D - Codeforces</a></p><h2 id="十一、二分变形，位置数字大小关系"><a href="#十一、二分变形，位置数字大小关系" class="headerlink" title="十一、二分变形，位置数字大小关系"></a>十一、二分变形，位置数字大小关系</h2><p><a href="https://codeforces.com/contest/1945/problem/E">Problem - E - Codeforces</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n,x;cin&gt;&gt;n&gt;&gt;x;</span><br><span class="line"><span class="type">int</span> pos=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">cin&gt;&gt;p[i];</span><br><span class="line"><span class="keyword">if</span>(p[i]==x)pos=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据二分后的大小关系判断位置 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 核心理解在于二分只比较中间位置 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 模拟流程、举例子、分情况 </span></span><br><span class="line"><span class="type">int</span> l=<span class="number">1</span>,r=n+<span class="number">1</span>;</span><br><span class="line"><span class="type">bool</span> vis=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(l+<span class="number">1</span>&lt;r)&#123;</span><br><span class="line"><span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(p[l]==x)vis=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(p[mid]&lt;=x)l=mid;</span><br><span class="line"><span class="keyword">else</span> r=mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一次搜索可以，输出0</span></span><br><span class="line"><span class="keyword">if</span>(p[l]==x)&#123;</span><br><span class="line">cout&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不影响二分过程（没有使用过，或 大小关系不影响） </span></span><br><span class="line"><span class="comment">// 否则，只能说明l=1，r=2，经过的中间点都大于x，l点换为x即为答案  </span></span><br><span class="line"><span class="comment">//if(!vis||p[l]&lt;=x)&#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">没有l移动，换成l</span></span><br><span class="line"><span class="comment">有r移动，但x不影响l的移动 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">cout&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">cout&lt;&lt;pos&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;l&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="comment">//return ;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十二、数值和位置一致时贡献1"><a href="#十二、数值和位置一致时贡献1" class="headerlink" title="十二、数值和位置一致时贡献1"></a>十二、数值和位置一致时贡献1</h2><p><a href="https://codeforces.com/contest/1917/problem/C">Problem - C - Codeforces</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>部分Acwing</title>
      <link href="/2024/05/02/%E9%83%A8%E5%88%86Acwing/"/>
      <url>/2024/05/02/%E9%83%A8%E5%88%86Acwing/</url>
      
        <content type="html"><![CDATA[<h2 id="一、4993-FEB"><a href="#一、4993-FEB" class="headerlink" title="一、4993.FEB"></a>一、4993.FEB</h2><p><a href="https://www.acwing.com/problem/content/4996/">4993. FEB - AcWing题库</a></p><ul><li><p>先分后和，分类讨论。举特例，数学归纳法</p></li><li><p>第一步，逐段分析</p></li><li><p>第二步，求每段的情况</p></li></ul><p>第一种情况：xxxxx     0 1 2….k-1 -&gt;   全都不一样 …全都一样</p><p>第二种情况：0xxxxx  0 1 …. k     -&gt;  全都不一样 …全都一样</p><p>第三种情况：0xxxxx0  分k的奇偶 -&gt; k 奇 0 2 ….k+1          ;k 偶 1 3 ….k+1    </p><p>第四种情况：0xxxxx1  分k的奇偶 -&gt; k 奇 1 2 ….k+1          ;k 偶 0 3 ….k+1    </p><p>举例子然后分析可以得到每种情况的类型数量</p><ul><li>第三步，合并</li></ul><p>公差2和2合并，公差为2</p><p>公差2和1合并，公差为1</p><p>对应最大值，最小值分别为两个数组最大和最小的和</p><ul><li>第四步，代码</li></ul><p>第一种情况对应特例，第二种情况对应边界，三、四种情况对应中间部分</p><p>至于合并时的最大、最小值，全在于和前边一样不一样</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">string s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="built_in">string</span>(n, <span class="string">&#x27;F&#x27;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (s[l] == <span class="string">&#x27;F&#x27;</span>) l ++ ;</span><br><span class="line">        <span class="keyword">while</span> (s[r] == <span class="string">&#x27;F&#x27;</span>) r -- ;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> low = <span class="number">0</span>, high = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> str = s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i] == <span class="string">&#x27;F&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (str[i - <span class="number">1</span>] == <span class="string">&#x27;B&#x27;</span>) str[i] = <span class="string">&#x27;E&#x27;</span>;</span><br><span class="line">                <span class="keyword">else</span> str[i] = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; l &amp;&amp; str[i] == str[i - <span class="number">1</span>]) low ++ ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        str = s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i] == <span class="string">&#x27;F&#x27;</span>) str[i] = str[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (i &gt; l &amp;&amp; str[i] == str[i - <span class="number">1</span>]) high ++ ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ends = l + n - <span class="number">1</span> - r, d = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (ends) high += ends, d = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; (high - low) / d + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = low; i &lt;= high; i += d)</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、4966-填充"><a href="#二、4966-填充" class="headerlink" title="二、4966.填充"></a>二、4966.填充</h2><p><a href="https://www.acwing.com/problem/content/4969/">4966. 填充 - AcWing题库</a></p><p>贪心，最优解</p><p>贪心问题往往是公式推导，策略选择，方法的证明</p><p>本题，在能配对的前提下，尽可能左配，左配能替代右配或者更优</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i+<span class="number">1</span>&lt;s.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">        <span class="type">char</span> a=s[i],b=s[i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="string">&#x27;?&#x27;</span>||b==<span class="string">&#x27;?&#x27;</span>||a==b)ans++,i++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、5407管道"><a href="#三、5407管道" class="headerlink" title="三、5407管道"></a>三、5407管道</h2><p><a href="https://www.acwing.com/problem/content/5410/">5407. 管道 - AcWing题库</a></p><p>二分答案，check用区间合并</p><p>本题的区间合并又有点不太一样</p><p>区间合并板子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;PII&gt; &amp;segs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;PII&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(), segs.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> st = <span class="number">-2e9</span>, ed = <span class="number">-2e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> seg : segs)</span><br><span class="line">        <span class="keyword">if</span> (ed &lt; seg.first)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line">            st = seg.first, ed = seg.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ed = <span class="built_in">max</span>(ed, seg.second);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line"></span><br><span class="line">    segs = res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本题代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; w[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> mid)</span></span>&#123;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt;p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="type">int</span> l=w[i].first,s=w[i].second;</span><br><span class="line">        <span class="keyword">if</span>(s&lt;=mid)&#123;</span><br><span class="line">            <span class="type">int</span> t=mid-s;</span><br><span class="line">            p.<span class="built_in">push_back</span>(&#123;<span class="built_in">max</span>(<span class="number">1ll</span>,l-t),<span class="built_in">min</span>(m,l+t)&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> st=<span class="number">-1</span>,ed=<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">sort</span>(p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">//本题的区间合并需要考虑加1，因为两点之间没有东西了也叫覆盖</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p[i].first&lt;=ed+<span class="number">1</span>)ed=<span class="built_in">max</span>(ed,p[i].second);</span><br><span class="line">        <span class="keyword">else</span> st=p[i].first,ed=p[i].second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  st==<span class="number">1</span>&amp;&amp;ed==m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//二分+区间合并</span></span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        cin&gt;&gt;w[i].first&gt;&gt;w[i].second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">2e9</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid))r=mid;</span><br><span class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;l&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;r&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、4968-互质数的个数"><a href="#四、4968-互质数的个数" class="headerlink" title="四、4968. 互质数的个数"></a>四、4968. 互质数的个数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">const</span>  <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">100</span>,MOD=<span class="number">998244353</span>,inf=<span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ksm</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)ans=ans*a%MOD;</span><br><span class="line"></span><br><span class="line">        a=a*a%MOD;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans%MOD;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> pri[N],vis[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> a,b;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="comment">// 题意：范围小于给定数，互质数的个数</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        欧拉函数板子题：给定a，函数算出1&lt;=x&lt;=a ,__gcd(x,a)==1 的个数</span></span><br><span class="line"><span class="comment">        a=p1^a1 * p2^a2 * p3^a3 ....pn^an</span></span><br><span class="line"><span class="comment">        结果=a*((p1-1)/p1*(p2-1)/p2*(p3-1)/p3.....)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        本题多一个b次方，除法可以考虑逆序对或者转换公式</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">if</span>(a==<span class="number">1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">// 素数质数  欧式筛快速幂</span></span><br><span class="line">    <span class="type">int</span> res=a,x=a;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i*i&lt;=x;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x%i==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(x%i==<span class="number">0</span>)x/=i;</span><br><span class="line">            res=res/i*(i<span class="number">-1</span>)%MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">1</span>)res=res/x*(x<span class="number">-1</span>)%MOD;</span><br><span class="line">    cout&lt;&lt;<span class="function">res*<span class="title">ksm</span><span class="params">(a,b<span class="number">-1</span>)</span>%MOD</span>;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="五、5406-松散子序列"><a href="#五、5406-松散子序列" class="headerlink" title="五、5406. 松散子序列"></a>五、5406. 松散子序列</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dp[N];<span class="comment">// 当前位置下的最大值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s;cin&gt;&gt;s;</span><br><span class="line">    <span class="type">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">    s=<span class="string">&#x27; &#x27;</span>+s;</span><br><span class="line">    <span class="comment">// 符合条件下的子序列价值最大, 像是策略dp</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">        dp 主要在于状态和如何进行不同状态下的转移</span></span><br><span class="line"><span class="comment">        常见的在于选和不选，   以及不同状态之间转移方案的选择</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   dp[<span class="number">1</span>]=s[<span class="number">1</span>]-<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="comment">// 当前位置不选，前一个位置即为最大</span></span><br><span class="line">        <span class="comment">// 当前位置选，从之前的位置开始，更新当前的值</span></span><br><span class="line">        dp[i]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>],dp[i<span class="number">-2</span>]+s[i]-<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[n]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h2 id="六、5408-保险箱"><a href="#六、5408-保险箱" class="headerlink" title="六、5408. 保险箱"></a>六、5408. 保险箱</h2><p><a href="https://www.acwing.com/problem/content/5411/">5408. 保险箱 - AcWing题库</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dp[N][<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    string x,y;</span><br><span class="line">    cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    <span class="comment">//题意：x通过每一位的改变变成y，求最小修改次数</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        策略在于</span></span><br><span class="line"><span class="comment">          发现变化，当前位的借位或者进位 只会影响高位，不会影响低位</span></span><br><span class="line"><span class="comment">          模拟每一种情况的变化</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    x=<span class="string">&#x27; &#x27;</span>+x;</span><br><span class="line">    y=<span class="string">&#x27; &#x27;</span>+y;</span><br><span class="line">    <span class="comment">// 0当前位正常加减  1表示当前位加减会想左进位  2当前位加减会向左借位</span></span><br><span class="line">    dp[n][<span class="number">0</span>]=<span class="built_in">abs</span>(x[n]-y[n]);</span><br><span class="line">    dp[n][<span class="number">1</span>]=-x[n]+y[n]+<span class="number">10</span>;</span><br><span class="line">    dp[n][<span class="number">2</span>]=x[n]-y[n]+<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;--i)&#123;</span><br><span class="line">        <span class="type">int</span> xx=x[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="type">int</span> yy=y[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="comment">// 0状态的转移</span></span><br><span class="line">        dp[i][<span class="number">0</span>]=<span class="built_in">min</span>(&#123;dp[i+<span class="number">1</span>][<span class="number">0</span>]+<span class="built_in">abs</span>(xx-yy),dp[i+<span class="number">1</span>][<span class="number">1</span>]+<span class="built_in">abs</span>(xx-yy+<span class="number">1</span>),dp[i+<span class="number">1</span>][<span class="number">2</span>]+<span class="built_in">abs</span>(xx<span class="number">-1</span>-yy)&#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1 </span></span><br><span class="line">        dp[i][<span class="number">1</span>]=<span class="built_in">min</span>(&#123;dp[i+<span class="number">1</span>][<span class="number">0</span>]+yy-xx+<span class="number">10</span>,dp[i+<span class="number">1</span>][<span class="number">1</span>]+yy-xx+<span class="number">9</span>,dp[i+<span class="number">1</span>][<span class="number">2</span>]+yy-xx+<span class="number">11</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">        dp[i][<span class="number">2</span>]=<span class="built_in">min</span>(&#123;dp[i+<span class="number">1</span>][<span class="number">0</span>]+xx-yy+<span class="number">10</span>,dp[i+<span class="number">1</span>][<span class="number">1</span>]+xx-yy+<span class="number">11</span>,dp[i+<span class="number">1</span>][<span class="number">2</span>]+xx-yy+<span class="number">9</span>&#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">min</span>(&#123;dp[<span class="number">1</span>][<span class="number">0</span>],dp[<span class="number">1</span>][<span class="number">1</span>],dp[<span class="number">1</span>][<span class="number">2</span>]&#125;)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h2 id="七、4662-因数平方和"><a href="#七、4662-因数平方和" class="headerlink" title="七、4662. 因数平方和"></a>七、4662. 因数平方和</h2><p><a href="https://www.acwing.com/problem/content/4665/">4662. 因数平方和 - AcWing题库</a></p><p><a href="https://www.acwing.com/solution/content/174106/">AcWing 4662. 【数学, 数论分块】因数平方和【蓝桥杯】 - AcWing</a></p><p>数论分块</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1-n 的 i*i 的和， == n*(n+1)*(n*2+1)/6;</span></span><br><span class="line">    <span class="keyword">return</span> n*(n+<span class="number">1ll</span>)%MOD*(<span class="number">2</span>*n%MOD+<span class="number">1ll</span>)%MOD* <span class="number">166666668</span>%MOD; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    <span class="comment">// 数学,公式推导,整除个数</span></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        最开始发现的规律：1-n 每个数是 i*i*(n/i) 然后求和 =》(n/i)可以提示数学分块 </span></span><br><span class="line"><span class="comment">        转换求数学分块和，转换=&gt;(n/i)*(求和l-r((求和1-r)(i*i)-(求和1-（l-1))(i*i)))</span></span><br><span class="line"><span class="comment">        这里运用了，分块和，前缀和，固定公式</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l&lt;=n;)&#123;</span><br><span class="line">        <span class="type">int</span> x=n/l,r=n/x;</span><br><span class="line">        ans=(ans+(<span class="built_in">ask</span>(r)-<span class="built_in">ask</span>(l<span class="number">-1</span>))*x%MOD)%MOD;</span><br><span class="line">        l=r+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;(ans+MOD)%MOD&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h2 id="八、4646-爬树的甲壳虫（需要再看"><a href="#八、4646-爬树的甲壳虫（需要再看" class="headerlink" title="八、4646. 爬树的甲壳虫（需要再看"></a>八、4646. 爬树的甲壳虫（需要再看</h2><p><a href="https://www.acwing.com/problem/content/4649/">4646. 爬树的甲壳虫 - AcWing题库</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        res = (res + <span class="number">1ll</span>) % MOD * y % MOD * <span class="built_in">ksm</span>(y - x, MOD - <span class="number">2ll</span>) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="九、4656、技能提升-：二分"><a href="#九、4656、技能提升-：二分" class="headerlink" title="九、4656、技能提升 ：二分"></a>九、4656、技能提升 ：二分</h2><p><a href="https://www.acwing.com/problem/content/4659/">4656. 技能升级 - AcWing题库</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[N],b[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> r,<span class="type">int</span> cnt,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> l=r-d*(cnt<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> (l+r)*cnt/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 检查到达这个值所需的次数是否可以满足</span></span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;x)&#123;</span><br><span class="line">            cnt+=<span class="built_in">ceil</span>(<span class="number">1.0</span>*(a[i]-x)/b[i]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt&lt;=m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 增加的技能点数会变小</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        等差数列+二分</span></span><br><span class="line"><span class="comment">        二分的是数据下界，</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        cin&gt;&gt;a[i]&gt;&gt;b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">1e6</span>,ans=<span class="number">0</span>,now=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid))&#123;</span><br><span class="line">            r=mid<span class="number">-1</span>;</span><br><span class="line">            ans=mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ass=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;ans)&#123;</span><br><span class="line">            now=<span class="built_in">ceil</span>(<span class="number">1.0</span>*(a[i]-ans)/b[i]); <span class="comment">// ceil使用先转换成浮点型，精度损失</span></span><br><span class="line">            cnt+=now;</span><br><span class="line">            ass+=<span class="built_in">sum</span>(a[i],now,b[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ass+(m-cnt)*ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 之所以会有 (m-cnt)*ans ，反向思维，最后的值不是ans的话cnt个数会变多，所以不合理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十、1225、正则问题-：dfs或者栈"><a href="#十、1225、正则问题-：dfs或者栈" class="headerlink" title="十、1225、正则问题  ：dfs或者栈"></a>十、1225、正则问题  ：dfs或者栈</h2><p><a href="https://www.acwing.com/problem/content/description/1227/">1225. 正则问题 - AcWing题库</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> id;<span class="comment">// 这个id得放外边，不然的话向上回溯的时候id没变化 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="comment">// 对于每种可能的情况进行特判</span></span><br><span class="line"><span class="keyword">while</span>(id&lt;s.<span class="built_in">size</span>())&#123;</span><br><span class="line"><span class="comment">// 代表开始，累加 </span></span><br><span class="line"><span class="keyword">if</span>(s[id]==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">id++;</span><br><span class="line">res += <span class="built_in">dfs</span>();</span><br><span class="line">id++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代表最后，结束 </span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(s[id] == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line"><span class="comment">//cout&lt;&lt;res&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代表左右只能选一个 </span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(s[id] == <span class="string">&#x27;|&#x27;</span>)&#123;</span><br><span class="line">id++;</span><br><span class="line">res=<span class="built_in">max</span>(res, <span class="built_in">dfs</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正常运行计数 </span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">id++;</span><br><span class="line">res++;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// 字符匹配的问题,在括号里找到最长的字符用于字符串匹配 </span></span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line"><span class="comment">// 有层次问题，用dfs递归解决</span></span><br><span class="line">cout&lt;&lt;<span class="built_in">dfs</span>()&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="十一：97、约数之和-：分治法或者公式法"><a href="#十一：97、约数之和-：分治法或者公式法" class="headerlink" title="十一：97、约数之和 ：分治法或者公式法"></a>十一：97、约数之和 ：分治法或者公式法</h2><p><a href="https://www.acwing.com/problem/content/99/">97. 约数之和 - AcWing题库</a></p><h3 id="约数之和公式推导"><a href="#约数之和公式推导" class="headerlink" title="约数之和公式推导"></a>约数之和公式推导</h3><p><img src="/%E7%BA%A6%E6%95%B0%E4%B9%8B%E5%92%8C.png" alt="约数之和"></p><h3 id="质因子分解"><a href="#质因子分解" class="headerlink" title="质因子分解"></a>质因子分解</h3><p>一定要注意最后分解的数是否还有</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i, s ++ ;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 奇数个情况时转换成偶数情况 , +1是因为p^0被特判了 </span></span><br><span class="line"><span class="keyword">if</span>(k%<span class="number">2</span>==<span class="number">0</span>)<span class="keyword">return</span> (p%MOD*<span class="built_in">sum</span>(p,k<span class="number">-1</span>)%MOD+<span class="number">1</span>)%MOD;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">return</span> (<span class="built_in">ksm</span>(p,k/<span class="number">2</span>+<span class="number">1</span>)%MOD+<span class="number">1</span>)%MOD*<span class="built_in">sum</span>(p,k/<span class="number">2</span>)%MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// a的b次方的约数之和 </span></span><br><span class="line"><span class="comment">// 约数之和常见公式结论+快速幂+分治+公式推导 + 质因子分解 </span></span><br><span class="line"><span class="type">int</span> a,b;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=a;++i)&#123;</span><br><span class="line"><span class="comment">// 循环质因子分解</span></span><br><span class="line"><span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(a%i==<span class="number">0</span>)&#123;</span><br><span class="line">a/=i;</span><br><span class="line">s++;</span><br><span class="line">&#125; </span><br><span class="line">res=res*<span class="built_in">sum</span>(i,s*b)%MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a==<span class="number">0</span>)res=<span class="number">0</span>;</span><br><span class="line">cout&lt;&lt;res&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十二、98、分形之城-：坐标变换，递归"><a href="#十二、98、分形之城-：坐标变换，递归" class="headerlink" title="十二、98、分形之城 ：坐标变换，递归"></a>十二、98、分形之城 ：坐标变换，递归</h2><p><a href="https://www.acwing.com/problem/content/100/">98. 分形之城 - AcWing题库</a></p><p>坐标变换：平移，对称，规律</p><p>递归：每次将块数变小 , 注意画图，注意细节，注意1加1ll</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="function">pii <span class="title">sum</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> a)</span></span>&#123;<span class="comment">// 第n级编号为a </span></span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">0</span>)<span class="keyword">return</span> &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">// 缩减到某一块,1/4份的个数，长度 </span></span><br><span class="line"><span class="type">int</span> block=(<span class="number">1ll</span>&lt;&lt;<span class="number">2</span>*n<span class="number">-2ll</span>),len=(<span class="number">1ll</span>&lt;&lt;n<span class="number">-1ll</span>);</span><br><span class="line"><span class="keyword">auto</span> now=<span class="built_in">sum</span>(n<span class="number">-1</span>,a%block);</span><br><span class="line"><span class="type">int</span> z=a/block,xx=now.first,yy=now.second;</span><br><span class="line"><span class="comment">// 看属于那一块进行特殊处理</span></span><br><span class="line"><span class="keyword">if</span>(z==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">// 关于y=x轴对称</span></span><br><span class="line"><span class="keyword">return</span> &#123;yy,xx&#125;; </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(z==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">// 向右平移len</span></span><br><span class="line"><span class="keyword">return</span> &#123;xx,yy+len&#125;; </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(z==<span class="number">2</span>)&#123;</span><br><span class="line"><span class="comment">// 向右下角平移</span></span><br><span class="line"><span class="keyword">return</span> &#123;xx+len,yy+len&#125;; </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 左下角，关于截距1&lt;&lt;n-1对称,画图注意变化</span></span><br><span class="line"><span class="keyword">return</span> &#123;len*<span class="number">2</span>-yy<span class="number">-1</span>,len-xx<span class="number">-1</span>&#125;; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n,a,b;cin&gt;&gt;n&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="comment">// 每次通过缩减规模从而解决问题,编号从0开始</span></span><br><span class="line"><span class="keyword">auto</span> pa=<span class="built_in">sum</span>(n,a<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">auto</span> pb=<span class="built_in">sum</span>(n,b<span class="number">-1</span>);</span><br><span class="line"><span class="comment">// 最后的距离是坐标平方和sqrt，一个单位是10</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.0lf\n&quot;</span>,<span class="built_in">sqrt</span>((pa.first-pb.first)*(pa.first-pb.first)+(pa.second-pb.second)*(pa.second-pb.second))*<span class="number">10</span>);</span><br><span class="line"><span class="comment">// cout&lt;&lt;(int)(ceil())&lt;&lt;&#x27;\n&#x27;; </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多校训练</title>
      <link href="/2024/05/02/%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83/"/>
      <url>/2024/05/02/%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83/</url>
      
        <content type="html"><![CDATA[<h1 id="多校训练"><a href="#多校训练" class="headerlink" title="多校训练"></a>多校训练</h1><p>牛客多校：1、 2、 3、4、5、6、7（没打、8、9、</p><p>杭电多校：5、6、7、8、9</p><h2 id="一、dp"><a href="#一、dp" class="headerlink" title="一、dp"></a>一、dp</h2><h3 id="1-1-有限制条件的转移"><a href="#1-1-有限制条件的转移" class="headerlink" title="1.1  有限制条件的转移"></a>1.1  有限制条件的转移</h3><p><a href="https://ac.nowcoder.com/acm/contest/57356/K">K-Box_2023牛客暑期多校训练营2 (nowcoder.com)</a></p><p>加限制条件的转移，所有状态的转移</p><h3 id="1-2-树形dp"><a href="#1-2-树形dp" class="headerlink" title="1.2 树形dp"></a>1.2 树形dp</h3><p><a href="https://acm.hdu.edu.cn/contest/problem?cid=1094&pid=1002">1002 City Upgrading (hdu.edu.cn)</a></p><h3 id="1-3-dp，状态的压缩，挺不错的"><a href="#1-3-dp，状态的压缩，挺不错的" class="headerlink" title="1.3 dp，状态的压缩，挺不错的"></a>1.3 dp，状态的压缩，挺不错的</h3><p><a href="https://acm.hdu.edu.cn/contest/problem?cid=1095&pid=1010">1010 Klee likes making friends (hdu.edu.cn)</a></p><p>第一维表示右边界，第二维表示左右边界的距离</p><ol><li>开始m</li><li>中间逐个移动</li><li>最后m个元素，选择ans</li></ol><p>表示左右边界的话，可以直接l和r，但是空间不行的话，可以只记录右边界，然后记录长度</p><p>对于只和上个状态有关的时候，可以使用压缩空间滚动数组的方法。</p><h3 id="1-4滚动数组，前缀和优化（不完全理解"><a href="#1-4滚动数组，前缀和优化（不完全理解" class="headerlink" title="1.4滚动数组，前缀和优化（不完全理解"></a>1.4滚动数组，前缀和优化（不完全理解</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7304">Problem - 7304 (hdu.edu.cn)</a></p><h3 id="1-5-组合数，dp-需再看"><a href="#1-5-组合数，dp-需再看" class="headerlink" title="1.5 组合数，dp 需再看"></a>1.5 组合数，dp 需再看</h3><p><a href="https://ac.nowcoder.com/acm/contest/57357/B">B-Auspiciousness_2023牛客暑期多校训练营3 (nowcoder.com)</a></p><p>初始化组合数、阶乘数、dp数组</p><p>dp[ i ] [ j ] [ 2 ]  &#x2F;&#x2F;i个小的   j个大的   最后一段是小的还是大的</p><p>枚举几个小的，几个大的，以及从哪里转移过来的</p><p>从哪里转移的以及答案记录都要使用组合数</p><h3 id="1-6前缀和优化dp"><a href="#1-6前缀和优化dp" class="headerlink" title="1.6前缀和优化dp"></a>1.6前缀和优化dp</h3><p><a href="https://ac.nowcoder.com/acm/contest/57358/J">J-Qu’est-ce Que C’est?_2023牛客暑期多校训练营4 (nowcoder.com)</a></p><p>长度为n，然后范围在-m到m之间，保证每一段都&gt;&#x3D;0，数字可重复</p><p>dp[i] [j]表示构造了前i个，以j为结尾</p><p>对称的选择，并列的两次循环，并且使用前缀和进行优化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前缀和优化dp</span></span><br><span class="line"><span class="comment">//每个位置都去尝试一遍</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">2</span>*m+<span class="number">1</span>;++j)&#123;<span class="comment">//j要减去m+1</span></span><br><span class="line">    <span class="keyword">if</span>(j&lt;=m)<span class="comment">//1 对应 2*m 只有m可以用，之后只有到m-1、m-2...前缀和</span></span><br><span class="line">       dp[i][j]=(dp[i][j]+sum[<span class="number">2</span>*m+<span class="number">1</span>]-sum[<span class="number">2</span>*m-j+<span class="number">1</span>]+mod)%mod;</span><br><span class="line">        <span class="keyword">else</span>    <span class="comment">//m+1 对应 0 （1-2*m+1）之后（2-2*m+1）...前缀和，只用可以相互抵消的可以用，</span></span><br><span class="line">            dp[i][j]=(dp[i][j]+sum[<span class="number">2</span>*m+<span class="number">1</span>]-sum[j-m<span class="number">-1</span>]+mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">2</span>*m+<span class="number">1</span>;++j)&#123;</span><br><span class="line">        sum[j]=(sum[j<span class="number">-1</span>]+dp[i][j])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-7-dp-i-j-第一维表示第i个口袋，j个体重，求最大价值"><a href="#1-7-dp-i-j-第一维表示第i个口袋，j个体重，求最大价值" class="headerlink" title="1.7 dp[i] [j] 第一维表示第i个口袋，j个体重，求最大价值"></a>1.7 dp[i] [j] 第一维表示第i个口袋，j个体重，求最大价值</h3><p><a href="https://ac.nowcoder.com/acm/contest/57359/H">H-Nazrin the Greeeeeedy Mouse_2023牛客暑期多校训练营5 (nowcoder.com)</a></p><p>对于过程的模拟和状态的转移，</p><p>背包，只不过可以选或者不选，每个操作都需要平方的转移</p><h3 id="1-8-简单dp"><a href="#1-8-简单dp" class="headerlink" title="1.8 简单dp"></a>1.8 简单dp</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7329">Problem - 7329 (hdu.edu.cn)</a></p><p>dp某种意义上在于根据题意设置容器</p><p>状态维数往往代表循环个数</p><p>dp[i] [j] [k]表示当前位置，左袋有j，右袋有k，</p><p>模拟每个操作的处理之后就可以得到答案。</p><p>可以使用up来更新状态，这样更加集中</p><h3 id="1-9-树形dp，树链剖分"><a href="#1-9-树形dp，树链剖分" class="headerlink" title="1.9 树形dp，树链剖分"></a>1.9 树形dp，树链剖分</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7332">Problem - 7332 (hdu.edu.cn)</a></p><p>重儿子、轻儿子</p><p>关键在于对树形式和状态转移以及转移时相关数量的理解很重要，模拟找找规律</p><p>用邻接矩阵建图容易空间过大，导致一些效率问题，其实这个没有卡</p><p>初始化和node开始为1，等号注意个数</p><h3 id="1-10树形dp（待补"><a href="#1-10树形dp（待补" class="headerlink" title="1.10树形dp（待补"></a>1.10树形dp（待补</h3><p><a href="https://ac.nowcoder.com/acm/contest/57360/A">A-Tree_2023牛客暑期多校训练营6 (nowcoder.com)</a></p><h3 id="1-11dp（待补"><a href="#1-11dp（待补" class="headerlink" title="1.11dp（待补"></a>1.11dp（待补</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7368">Problem - 7368 (hdu.edu.cn)</a></p><h3 id="1-12双指针或者dp（待补"><a href="#1-12双指针或者dp（待补" class="headerlink" title="1.12双指针或者dp（待补"></a>1.12双指针或者dp（待补</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7369">Problem - 7369 (hdu.edu.cn)</a></p><h3 id="1-13-状压dp，需要优化（待补"><a href="#1-13-状压dp，需要优化（待补" class="headerlink" title="1.13 状压dp，需要优化（待补"></a>1.13 状压dp，需要优化（待补</h3><p><a href="https://ac.nowcoder.com/acm/contest/57364/F">F-IUPC_“范式杯”2023牛客暑期多校训练营10 (nowcoder.com)</a></p><h2 id="二、博弈"><a href="#二、博弈" class="headerlink" title="二、博弈"></a>二、博弈</h2><h3 id="1-1-sg函数"><a href="#1-1-sg函数" class="headerlink" title="1.1 sg函数"></a>1.1 sg函数</h3><p><a href="https://acm.hdu.edu.cn/contest/problem?cid=1094&pid=1012">1012 Play on Tree (hdu.edu.cn)</a></p><h3 id="1-2nim游戏（待补"><a href="#1-2nim游戏（待补" class="headerlink" title="1.2nim游戏（待补"></a>1.2nim游戏（待补</h3><p><a href="https://acm.hdu.edu.cn/contest/problem?cid=1095&pid=1001">1001 Alice Game (hdu.edu.cn)</a></p><h3 id="1-3（待补"><a href="#1-3（待补" class="headerlink" title="1.3（待补"></a>1.3（待补</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7354">Problem - 7354 (hdu.edu.cn)</a></p><h3 id="1-4-逆序对，先手的人可能发生变化，（不完全理解"><a href="#1-4-逆序对，先手的人可能发生变化，（不完全理解" class="headerlink" title="1.4 逆序对，先手的人可能发生变化，（不完全理解"></a>1.4 逆序对，先手的人可能发生变化，（不完全理解</h3><p><a href="https://ac.nowcoder.com/acm/contest/57362/K">K-Scheming Furry_2023牛客暑期多校训练营8 (nowcoder.com)</a></p><p>好多题都和逆序对有关</p><p>一些结论要猜猜试试</p><h3 id="1-5-博弈-、-sg函数"><a href="#1-5-博弈-、-sg函数" class="headerlink" title="1.5 博弈 、 sg函数"></a>1.5 博弈 、 sg函数</h3><p><a href="https://ac.nowcoder.com/acm/contest/57364/D">D-Agnej_“范式杯”2023牛客暑期多校训练营10 (nowcoder.com)</a></p><p>分情况写sg函数，注意问题的最小规模和逻辑的推导</p><p>题意：每次只能拿一个，拿完一半就废了</p><p>代码核心：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int even(int x,int y)&#123;</span><br><span class="line">    return (x+y)%2;</span><br><span class="line">&#125;</span><br><span class="line">int odd(int l,int mid,int r)&#123;</span><br><span class="line">    if(!mid)return even(l,r);</span><br><span class="line">    if(l&lt;r)swap(l,r);</span><br><span class="line">    if(!r)return l%2;</span><br><span class="line">    if(r==1)return (l%2==0)?3:2;</span><br><span class="line">    return (l+1+r)%2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、图论"><a href="#三、图论" class="headerlink" title="三、图论"></a>三、图论</h2><h3 id="3-1最短路"><a href="#3-1最短路" class="headerlink" title="3.1最短路"></a>3.1最短路</h3><p><a href="https://ac.nowcoder.com/acm/contest/57355/K">K-Subdivision_“范式杯”2023牛客暑期多校训练营1 (nowcoder.com)</a></p><h3 id="3-2bitset优化"><a href="#3-2bitset优化" class="headerlink" title="3.2bitset优化"></a>3.2bitset优化</h3><p><a href="https://acm.hdu.edu.cn/contest/problem?cid=1095&pid=1007">1007 foreverlasting and fried-chicken (hdu.edu.cn)</a></p><p>bitset优化，图的模型，根据度和图的连接情况判断</p><h3 id="3-3dfs，分层图或者并查集（没太看懂），也可以bfs-dfs完成"><a href="#3-3dfs，分层图或者并查集（没太看懂），也可以bfs-dfs完成" class="headerlink" title="3.3dfs，分层图或者并查集（没太看懂），也可以bfs+dfs完成"></a>3.3dfs，分层图或者并查集（没太看懂），也可以bfs+dfs完成</h3><p><a href="https://ac.nowcoder.com/acm/contest/57357/E">E-Koraidon, Miraidon and DFS Shortest Path_2023牛客暑期多校训练营3 (nowcoder.com)</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">void bfs(int x)</span><br><span class="line">&#123;</span><br><span class="line">    queue&lt;int&gt; q;</span><br><span class="line">    q.push(x);</span><br><span class="line">    depth[0] = 0;</span><br><span class="line">    depth[x] = 1;</span><br><span class="line">    while (q.size())</span><br><span class="line">    &#123;</span><br><span class="line">        auto t = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        for (auto lb : graph[t])</span><br><span class="line">        &#123;</span><br><span class="line">            if (!depth[lb])</span><br><span class="line">            &#123;</span><br><span class="line">                depth[lb] = depth[t] + 1;</span><br><span class="line">                q.push(lb);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void dfs(int x, int fa)</span><br><span class="line">&#123;</span><br><span class="line">    dp[x] = 1;</span><br><span class="line">    for (auto lb : graph[x])</span><br><span class="line">    &#123;</span><br><span class="line">        if (dp[lb])</span><br><span class="line">            continue;</span><br><span class="line">        if (depth[lb] != depth[x] + 1)</span><br><span class="line">        &#123;</span><br><span class="line">            flag = false;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(lb, x);</span><br><span class="line">    &#125;</span><br><span class="line">    dp[x] = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-最小环计数，Floyd"><a href="#3-4-最小环计数，Floyd" class="headerlink" title="3.4 最小环计数，Floyd"></a>3.4 最小环计数，Floyd</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7322">Problem - 7322 (hdu.edu.cn)</a></p><h3 id="3-5倍增数组，找规律（待补"><a href="#3-5倍增数组，找规律（待补" class="headerlink" title="3.5倍增数组，找规律（待补"></a>3.5倍增数组，找规律（待补</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7345">Problem - 7345 (hdu.edu.cn)</a></p><h3 id="3-6并查集，联通块"><a href="#3-6并查集，联通块" class="headerlink" title="3.6并查集，联通块"></a>3.6并查集，联通块</h3><p><a href="https://acm.hdu.edu.cn/contest/problem?cid=1101&pid=1007">1007 Solubility (hdu.edu.cn)</a></p><h3 id="3-7-拓扑排序"><a href="#3-7-拓扑排序" class="headerlink" title="3.7 拓扑排序"></a>3.7 拓扑排序</h3><p><a href="https://ac.nowcoder.com/acm/contest/57364/L">L-Grayscale Confusion_“范式杯”2023牛客暑期多校训练营10 (nowcoder.com)</a></p><p>注意0 1点要合并，放到n的位置</p><p>题意可以暂时理解为每个点对于抽象函数的相对顺序</p><p><strong>偏序：</strong></p><p><em>前置条件</em> 2 : 如果 R 是 自反 , 反对称 , 传递的 ;</p><p>① 自反 : 每个元素 自己 和 自己 都有关系 , x R x  ;<br>② 反对称 : 如果 x R y 并且 y R x 则 x &#x3D; y  , 即 x ̸ &#x3D; y  , x R y  和 y R x不能同时存在 ; 可以没有 , 但是一定不能同时出现 ;<br>③ 传递 : 如果 有 x R y  , y R z  , 那么必须有 x R z  , 如果前提不成立 , 那么也勉强称为传递 ;<br><em>结论</em> : 称 R 为 A 上的偏序关系 ;<br><em>应用</em>：在评分标准不能准确标定而又需要进行排序的场合，这时将成员进行两两比较，确定两者之间的好坏关系，是较为容易且准确的一种方法。</p><h2 id="四、数论、二进制、推导公式"><a href="#四、数论、二进制、推导公式" class="headerlink" title="四、数论、二进制、推导公式"></a>四、数论、二进制、推导公式</h2><h3 id="4-1-概率"><a href="#4-1-概率" class="headerlink" title="4.1 概率"></a>4.1 概率</h3><p><a href="https://ac.nowcoder.com/acm/contest/57355/J">J-Roulette_“范式杯”2023牛客暑期多校训练营1 (nowcoder.com)</a></p><h3 id="4-2-exgcd（待补"><a href="#4-2-exgcd（待补" class="headerlink" title="4.2 exgcd（待补"></a>4.2 exgcd（待补</h3><p><a href="https://ac.nowcoder.com/acm/contest/57355/M">M-Water_“范式杯”2023牛客暑期多校训练营1 (nowcoder.com)</a></p><h3 id="4-3-概率、公式推导（有点问题"><a href="#4-3-概率、公式推导（有点问题" class="headerlink" title="4.3 概率、公式推导（有点问题"></a>4.3 概率、公式推导（有点问题</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7297">Problem - 7297 (hdu.edu.cn)</a></p><h3 id="4-4-数论，哥德巴赫猜想"><a href="#4-4-数论，哥德巴赫猜想" class="headerlink" title="4.4 数论，哥德巴赫猜想"></a>4.4 数论，哥德巴赫猜想</h3><p><a href="https://ac.nowcoder.com/acm/contest/57357/H">H-Until the Blue Moon Rises_2023牛客暑期多校训练营3 (nowcoder.com)</a></p><h3 id="4-5（待补，生成函数"><a href="#4-5（待补，生成函数" class="headerlink" title="4.5（待补，生成函数"></a>4.5（待补，生成函数</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7328">Problem - 7328 (hdu.edu.cn)</a></p><h3 id="4-6（待补"><a href="#4-6（待补" class="headerlink" title="4.6（待补"></a>4.6（待补</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7325">Problem - 7325 (hdu.edu.cn)</a></p><h3 id="4-7（待补，难"><a href="#4-7（待补，难" class="headerlink" title="4.7（待补，难"></a>4.7（待补，难</h3><p><a href="https://ac.nowcoder.com/acm/contest/57359/I">I-The Yakumo Family_2023牛客暑期多校训练营5 (nowcoder.com)</a></p><h3 id="4-8-组合数，范德蒙卷积优化"><a href="#4-8-组合数，范德蒙卷积优化" class="headerlink" title="4.8 组合数，范德蒙卷积优化"></a>4.8 组合数，范德蒙卷积优化</h3><p><a href="https://ac.nowcoder.com/acm/contest/57360/B">B-Distance_2023牛客暑期多校训练营6 (nowcoder.com)</a></p><p>每次看si和tj的贡献，左边和右边随便选，用范德蒙卷积优化</p><p>范德蒙卷积：</p><p><a href="https://www.luogu.com.cn/blog/nofind/fan-de-meng-de-juan-ji">范德蒙德卷积 - nofind 的博客 - 洛谷博客 (luogu.com.cn)</a></p><img src="C:\Users\30279\Desktop\个人acm题解\比赛记录\范德蒙卷积.png" alt="范德蒙卷积" style="zoom:80%;" /><h3 id="4-9乘积、因子"><a href="#4-9乘积、因子" class="headerlink" title="4.9乘积、因子"></a>4.9乘积、因子</h3><p><a href="https://ac.nowcoder.com/acm/contest/57360/C">C-idol!!_2023牛客暑期多校训练营6 (nowcoder.com)</a></p><p>乘积、二进制有关的题，往往要分解，乘积往往和因子有关，二进制往往和每一位有关</p><p>乘积来自于5，所以和5的个数有关</p><h3 id="4-10完全平方数的相关规律"><a href="#4-10完全平方数的相关规律" class="headerlink" title="4.10完全平方数的相关规律"></a>4.10完全平方数的相关规律</h3><ul><li>完全平方数差的规律：</li></ul><p>总结：</p><p>（1）3及3以上的所有奇数都可以表示为两个平方数的差。</p><p>（2）8及8以上所有4k形式的偶数都可以表示为两个不同平方数的差。</p><p>（3）除(1)和(2)以外的其他正整数都不可能表示成两平方数的差。</p><ul><li>完全平方数和的规律：</li></ul><p> 说明每个<a href="https://baike.baidu.com/item/%E6%AD%A3%E6%95%B4%E6%95%B0/8461335?fromModule=lemma_inlink">正整数</a>均可表示为4个整数的平方和。</p><p>任何一个数都可以由《&#x3D;4个完全平方数加和得到，代码为sqrt(n)的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 判断是否为完全平方数</span><br><span class="line">   bool isPerfectSquare(int x) &#123;</span><br><span class="line">       int y = sqrt(x);</span><br><span class="line">       return y * y == x;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 判断是否能表示为 4^k*(8m+7)</span><br><span class="line">   bool checkAnswer4(int x) &#123;</span><br><span class="line">       while (x % 4 == 0) &#123;</span><br><span class="line">           x /= 4;</span><br><span class="line">       &#125;</span><br><span class="line">       return x % 8 == 7;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   int numSquares(int n) &#123;</span><br><span class="line">       if (isPerfectSquare(n)) &#123;</span><br><span class="line">           return 1;</span><br><span class="line">       &#125;</span><br><span class="line">       if (checkAnswer4(n)) &#123;</span><br><span class="line">           return 4;</span><br><span class="line">       &#125;</span><br><span class="line">       for (int i = 1; i * i &lt;= n; i++) &#123;</span><br><span class="line">           int j = n - i * i;</span><br><span class="line">           if (isPerfectSquare(j)) &#123;</span><br><span class="line">               return 2;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return 3;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-11-鞅的停时定理，完全随机事件的概率"><a href="#4-11-鞅的停时定理，完全随机事件的概率" class="headerlink" title="4.11 鞅的停时定理，完全随机事件的概率"></a>4.11 鞅的停时定理，完全随机事件的概率</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7378">Problem - 7378 (hdu.edu.cn)</a></p><p>当成模型吧，</p><p>题意：每次随机选两组，互相交换一个，直到只有一组拥有全部</p><p>方法：累乘累加前缀和优化</p><h3 id="4-12-推公式，或者猜结论"><a href="#4-12-推公式，或者猜结论" class="headerlink" title="4.12 推公式，或者猜结论"></a>4.12 推公式，或者猜结论</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7385">Problem - 7385 (hdu.edu.cn)</a></p><p>（n个根）* （（n-1）！个树形 ）*（π(i从2到n)（min(i-1,k)）如何选择互不影响的前导节点）</p><h3 id="4-13-二进制异或和、推导规律，模拟"><a href="#4-13-二进制异或和、推导规律，模拟" class="headerlink" title="4.13 二进制异或和、推导规律，模拟"></a>4.13 二进制异或和、推导规律，模拟</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7390">Problem - 7390 (hdu.edu.cn)</a></p><p>样例造的越合适越容易发现规律</p><p>这个标程其实在反向模拟异或和的过程，每次选最小，每次看组合，而且题意有按顺序选最小的提示。</p><h3 id="4-14-期望、模拟打表找规律（模拟的部分有点问题"><a href="#4-14-期望、模拟打表找规律（模拟的部分有点问题" class="headerlink" title="4.14  期望、模拟打表找规律（模拟的部分有点问题"></a>4.14  期望、模拟打表找规律（模拟的部分有点问题</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7386">Problem - 7386 (hdu.edu.cn)</a></p><p>模拟打出表之后规律很明显</p><h2 id="五、公式、规律、贪心"><a href="#五、公式、规律、贪心" class="headerlink" title="五、公式、规律、贪心"></a>五、公式、规律、贪心</h2><h3 id="5-1结论推导"><a href="#5-1结论推导" class="headerlink" title="5.1结论推导"></a>5.1结论推导</h3><p><a href="https://ac.nowcoder.com/acm/contest/57355/H">H-Matches_“范式杯”2023牛客暑期多校训练营1 (nowcoder.com)</a></p><h3 id="5-2-结论（找规律，贪心、排序题"><a href="#5-2-结论（找规律，贪心、排序题" class="headerlink" title="5.2  结论（找规律，贪心、排序题"></a>5.2  结论（找规律，贪心、排序题</h3><p><a href="https://ac.nowcoder.com/acm/contest/57356/D">D-The Game of Eating_2023牛客暑期多校训练营2 (nowcoder.com)</a></p><h3 id="5-3结论、分类讨论（不完全懂，二分图博弈结论（网络流））"><a href="#5-3结论、分类讨论（不完全懂，二分图博弈结论（网络流））" class="headerlink" title="5.3结论、分类讨论（不完全懂，二分图博弈结论（网络流））"></a>5.3结论、分类讨论（不完全懂，二分图博弈结论（网络流））</h3><p><a href="https://ac.nowcoder.com/acm/contest/57356/F">F-Link with Chess Game_2023牛客暑期多校训练营2 (nowcoder.com)</a></p><h3 id="5-4前缀和，位运算，翻转-1操作"><a href="#5-4前缀和，位运算，翻转-1操作" class="headerlink" title="5.4前缀和，位运算，翻转+1操作"></a>5.4前缀和，位运算，翻转+1操作</h3><p><a href="https://ac.nowcoder.com/acm/contest/57356/H">H-0 and 1 in BIT_2023牛客暑期多校训练营2 (nowcoder.com)</a></p><h3 id="5-5矩阵，二进制，找规律"><a href="#5-5矩阵，二进制，找规律" class="headerlink" title="5.5矩阵，二进制，找规律"></a>5.5矩阵，二进制，找规律</h3><p><a href="https://ac.nowcoder.com/acm/contest/57357/D">D-Ama no Jaku_2023牛客暑期多校训练营3 (nowcoder.com)</a></p><h3 id="5-6构造，签到，实际上是个模拟，不是那种粗暴的规则"><a href="#5-6构造，签到，实际上是个模拟，不是那种粗暴的规则" class="headerlink" title="5.6构造，签到，实际上是个模拟，不是那种粗暴的规则"></a>5.6构造，签到，实际上是个模拟，不是那种粗暴的规则</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7310">Problem - 7310 (hdu.edu.cn)</a></p><h3 id="5-7猜结论，全0或者全1，差个检验"><a href="#5-7猜结论，全0或者全1，差个检验" class="headerlink" title="5.7猜结论，全0或者全1，差个检验"></a>5.7猜结论，全0或者全1，差个检验</h3><p><a href="https://ac.nowcoder.com/acm/contest/57358/A">A-Bobo String Construction_2023牛客暑期多校训练营4 (nowcoder.com)</a></p><p>始终不对</p><p>1，方法错了</p><p>2，差个特判</p><h3 id="5-8（难，待补"><a href="#5-8（难，待补" class="headerlink" title="5.8（难，待补"></a>5.8（难，待补</h3><p><a href="https://ac.nowcoder.com/acm/contest/57359/B">B-Circle of Mistery_2023牛客暑期多校训练营5 (nowcoder.com)</a></p><h3 id="5-9优化、找规律，"><a href="#5-9优化、找规律，" class="headerlink" title="5.9优化、找规律，"></a>5.9优化、找规律，</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7341">Problem - 7341 (hdu.edu.cn)</a></p><p>需要找到数学规律，然后进行优化、暴力</p><h3 id="5-10vector-，找规律（待补"><a href="#5-10vector-，找规律（待补" class="headerlink" title="5.10vector ，找规律（待补"></a>5.10vector ，找规律（待补</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7338">Problem - 7338 (hdu.edu.cn)</a></p><h3 id="5-11-构造，规律，二分"><a href="#5-11-构造，规律，二分" class="headerlink" title="5.11 构造，规律，二分"></a>5.11 构造，规律，二分</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7350">Problem - 7350 (hdu.edu.cn)</a></p><p>反向构造，若答案是B则可以构造出B个1 3 之后加2 2 ，这是2的个数应该小于等于上限B</p><p>根据这个规律，二分查找答案</p><h3 id="5-12-逆序对"><a href="#5-12-逆序对" class="headerlink" title="5.12 逆序对"></a>5.12 逆序对</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7359">Problem - 7359 (hdu.edu.cn)</a></p><p>每个数都和自己原来的位置有关，再加上反转的规律，自然想到逆序对</p><h3 id="5-13利用逆序对反向构造全排列，"><a href="#5-13利用逆序对反向构造全排列，" class="headerlink" title="5.13利用逆序对反向构造全排列，"></a>5.13利用逆序对反向构造全排列，</h3><p><a href="https://ac.nowcoder.com/acm/contest/57359/E">E-Red and Blue and Green_2023牛客暑期多校训练营5 (nowcoder.com)</a></p><h3 id="5-14-构造题，dfs（待补，有个公式死住了"><a href="#5-14-构造题，dfs（待补，有个公式死住了" class="headerlink" title="5.14 构造题，dfs（待补，有个公式死住了"></a>5.14 构造题，dfs（待补，有个公式死住了</h3><p><a href="https://ac.nowcoder.com/acm/contest/57358/H">H-Merge the squares!_2023牛客暑期多校训练营4 (nowcoder.com)</a></p><p><a href="https://ac.nowcoder.com/acm/contest/view-submission?submissionId=63092924">代码查看 (nowcoder.com)</a></p><h3 id="5-15找规律，双指针模拟"><a href="#5-15找规律，双指针模拟" class="headerlink" title="5.15找规律，双指针模拟"></a>5.15找规律，双指针模拟</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7365">Problem - 7365 (hdu.edu.cn)</a></p><p>01**10这种的破解方法在于如果有连续的0那么0就有办法赢，否则如果只有一个11那么平局（没有连续的也行），或者有多个11那么1赢，对于10 * * 10也是同一个道理</p><h3 id="5-16-构造，根据一些模式构造"><a href="#5-16-构造，根据一些模式构造" class="headerlink" title="5.16 构造，根据一些模式构造"></a>5.16 构造，根据一些模式构造</h3><p><a href="https://ac.nowcoder.com/acm/contest/57362/J">J-Permutation and Primes_2023牛客暑期多校训练营8 (nowcoder.com)</a></p><p>给出10个长度的固定模式，然后根据其差值关系来构造</p><h3 id="5-17-利用栈相关stl进行处理的规律题"><a href="#5-17-利用栈相关stl进行处理的规律题" class="headerlink" title="5.17 利用栈相关stl进行处理的规律题"></a>5.17 利用栈相关stl进行处理的规律题</h3><p><a href="https://ac.nowcoder.com/acm/contest/57362/H">H-Insert 1, Insert 2, Insert 3, …_2023牛客暑期多校训练营8 (nowcoder.com)</a></p><h3 id="5-18-双指针、前缀和优化"><a href="#5-18-双指针、前缀和优化" class="headerlink" title="5.18 双指针、前缀和优化"></a>5.18 双指针、前缀和优化</h3><p><a href="https://ac.nowcoder.com/acm/contest/57363/D">D-Non-Puzzle: Error Permutation_2023牛客暑期多校训练营9 (nowcoder.com)</a></p><p>虽然是区间第k小但是没有用到主席树，反而是个贪心思维优化的题</p><p>以每个ai为中心，如果他是对应区间第i位第i小，那么所有涉及的区间全部消失</p><p>最后记录没有被消灭的区间</p><h3 id="5-19-前缀和优化，扫描线，思维贪心"><a href="#5-19-前缀和优化，扫描线，思维贪心" class="headerlink" title="5.19 前缀和优化，扫描线，思维贪心"></a>5.19 前缀和优化，扫描线，思维贪心</h3><p><a href="https://ac.nowcoder.com/acm/contest/57363/I">I-Non-Puzzle: Segment Pair_2023牛客暑期多校训练营9 (nowcoder.com)</a></p><p>前缀和优化是个很重要的知识点</p><p>一维前缀和先算全部，然后减去重复的x-1的位置</p><h3 id="5-20-图上，猜公式相关内容，（没太理解"><a href="#5-20-图上，猜公式相关内容，（没太理解" class="headerlink" title="5.20 图上，猜公式相关内容，（没太理解"></a>5.20 图上，猜公式相关内容，（没太理解</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7382">Problem - 7382 (hdu.edu.cn)</a></p><h2 id="六、树-数据结构"><a href="#六、树-数据结构" class="headerlink" title="六、树+数据结构"></a>六、树+数据结构</h2><h3 id="6-1、数学转化为树，gcd，构造压缩"><a href="#6-1、数学转化为树，gcd，构造压缩" class="headerlink" title="6.1、数学转化为树，gcd，构造压缩"></a>6.1、数学转化为树，gcd，构造压缩</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7311">Problem - 7311 (hdu.edu.cn)</a></p><p>compare函数的书写是难点，i+1和i+2还需要深入观察</p><h3 id="6-2树状数组（待补"><a href="#6-2树状数组（待补" class="headerlink" title="6.2树状数组（待补"></a>6.2树状数组（待补</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7337">Problem - 7337 (hdu.edu.cn)</a></p><h3 id="6-3点分治，dsu（待补"><a href="#6-3点分治，dsu（待补" class="headerlink" title="6.3点分治，dsu（待补"></a>6.3点分治，dsu（待补</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7339">Problem - 7339 (hdu.edu.cn)</a></p><h3 id="6-4记忆化搜索，hashmap记录处理（unordered-map）"><a href="#6-4记忆化搜索，hashmap记录处理（unordered-map）" class="headerlink" title="6.4记忆化搜索，hashmap记录处理（unordered_map）"></a>6.4记忆化搜索，hashmap记录处理（unordered_map）</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7372">Problem - 7372 (hdu.edu.cn)</a></p><h2 id="七、字符串"><a href="#七、字符串" class="headerlink" title="七、字符串"></a>七、字符串</h2><h3 id="7-1马拉车算法、dp、结论"><a href="#7-1马拉车算法、dp、结论" class="headerlink" title="7.1马拉车算法、dp、结论"></a>7.1马拉车算法、dp、结论</h3><p><a href="https://ac.nowcoder.com/acm/contest/57356/G">G-Link with Centrally Symmetric Strings_2023牛客暑期多校训练营2 (nowcoder.com)</a></p><p>能形成中心对称的串，就记录下来是可行的，外层是马拉车的板子</p><p>里边有点区别，初始化不存在的时候是0，而不是1（有点问题</p><p>考虑一个结论：每次左边界小于当前start的时候就更新start为右边界，i跳到右边界继续，从而节省复杂度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(p[i]&gt;1&amp;&amp;i-p[i]+1&lt;=start)&#123;</span><br><span class="line">b[i+p[i]-2] = &#x27;$&#x27;;</span><br><span class="line">start = i+p[i]-1;</span><br><span class="line">i = i+p[i]-2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2马拉车，线段树优化（差点，没补完"><a href="#7-2马拉车，线段树优化（差点，没补完" class="headerlink" title="7.2马拉车，线段树优化（差点，没补完"></a>7.2马拉车，线段树优化（差点，没补完</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7326">Problem - 7326 (hdu.edu.cn)</a></p><h3 id="7-3（待补"><a href="#7-3（待补" class="headerlink" title="7.3（待补"></a>7.3（待补</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7366">Problem - 7366 (hdu.edu.cn)</a></p><h3 id="7-4（待补"><a href="#7-4（待补" class="headerlink" title="7.4（待补"></a>7.4（待补</h3><p><a href="https://ac.nowcoder.com/acm/contest/57362/I">I-Make It Square_2023牛客暑期多校训练营8 (nowcoder.com)</a></p><h3 id="7-5（待补"><a href="#7-5（待补" class="headerlink" title="7.5（待补"></a>7.5（待补</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7391">Problem - 7391 (hdu.edu.cn)</a></p><h2 id="八、计算几何"><a href="#八、计算几何" class="headerlink" title="八、计算几何"></a>八、计算几何</h2><h3 id="8-1-注意精度和常数"><a href="#8-1-注意精度和常数" class="headerlink" title="8.1 注意精度和常数"></a>8.1 注意精度和常数</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7324">Problem - 7324 (hdu.edu.cn)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 训练记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划题</title>
      <link href="/2024/05/02/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%A2%98/"/>
      <url>/2024/05/02/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h1><p>dp的一个特点就是书写递归方程。</p><p>dp其实强调对于集合的划分，策略的安排</p><h2 id="一、整数分块-dp暴力"><a href="#一、整数分块-dp暴力" class="headerlink" title="一、整数分块+dp暴力"></a>一、整数分块+dp暴力</h2><p><a href="https://codeforces.com/gym/104095/problem/B">Problem - B - Codeforces</a></p><p>先开始要找到可以可以转移的人数</p><p>然后开两个数组，pre   和  now    ，表示一定体重下的最大价值，</p><p>最后暴力dp</p><p><img src="C:\Users\30279\AppData\Roaming\Typora\typora-user-images\image-20230212134053435.png" alt="image-20230212134053435"></p><h2 id="二、dp，trie树"><a href="#二、dp，trie树" class="headerlink" title="二、dp，trie树"></a>二、dp，trie树</h2><p><a href="https://codeforces.com/gym/104081/problem/I">Problem - I - Codeforces</a></p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>trie树预处理子串，可以从1或者0开始，建议从1，end可以标记是否是完整串，cnt可以标记子串出现次数，也可以返回层数，或者长度，</p><p>dp[flag] [i]意思是：a或者b在i的位置所需要的最小值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(tt[j].end[p])&#123;</span><br><span class="line">     dp[j][k]=min(dp[!j][i-1]+1,dp[j][k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dfs会超时，dp不会，而且更清楚</p><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>trie树和dp的结合</p><h2 id="三、dp三维背包，滚动数组"><a href="#三、dp三维背包，滚动数组" class="headerlink" title="三、dp三维背包，滚动数组"></a>三、dp三维背包，滚动数组</h2><p><a href="https://codeforces.com/group/Aokqa6Haao/contest/427952/problem/E">Problem - E - Codeforces</a></p><h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><p>这个题是dp</p><p>开始只是暴力所有的情况，很好地利用容量这个问题，最后处理答案，</p><p>有的值的综合减去当前量的总和的一半才是补充的量，最后暴力选择的时候，别超当前容量</p><h3 id="注意：-1"><a href="#注意：-1" class="headerlink" title="注意："></a>注意：</h3><p>输入的方式和数组大小</p><h2 id="四、dp，滚动数组，用multiset动态维护可行的位置更新"><a href="#四、dp，滚动数组，用multiset动态维护可行的位置更新" class="headerlink" title="四、dp，滚动数组，用multiset动态维护可行的位置更新"></a>四、dp，滚动数组，用multiset动态维护可行的位置更新</h2><p><a href="https://codeforces.com/group/Aokqa6Haao/contest/427952/problem/F">Problem - F - Codeforces</a></p><h3 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h3><p>dp[i] [j]表示第i道主菜，第j个菜被用，花费最小</p><p>但是你需要动态的维护需要更新的节点，先删除不可以走的，然后更新dp，选最小的前边的那个，然后添加回之前的</p><p>需要multiset动态维护、记录更新</p><h3 id="注意：-2"><a href="#注意：-2" class="headerlink" title="注意："></a>注意：</h3><p>跟题目的下标含义要一致</p><h2 id="五、dp，滚动数组，"><a href="#五、dp，滚动数组，" class="headerlink" title="五、dp，滚动数组，"></a>五、dp，滚动数组，</h2><p><a href="https://codeforces.com/group/Aokqa6Haao/contest/428602/problem/A">Problem - A - Codeforces</a></p><p>（纯粹暴力很难，但是具备一定规律，这题开始误认为是组合数学，其实不是，因为规律在于过程和递推方程上）</p><h3 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h3><p>开始，dp[i] [j] [p] [q]这么设状态，空间上不允许</p><p>之后，dp[2] [j] [p]这样用滚动数组优化一下，空间上是可以的，0表示之前的状态，1表示现在的状态，j表示列，p表示拥有0的个数，（总数为n+m-1，所以q也就知道了），整体表示情况数</p><h3 id="注意：-3"><a href="#注意：-3" class="headerlink" title="注意："></a>注意：</h3><p>初始化dp[1] [1] [k]的时候要注意a[1] [1]的情况</p><p>还有一个就是i&#x3D;&#x3D;1&amp;&amp;j&#x3D;&#x3D;1特判</p><p>a[i] [j]&#x3D;&#x3D;0是，dp[1] [j] [0]&#x3D;0;此时没有0的情况不成立</p><h2 id="六、dp-汉诺塔问题，待理解"><a href="#六、dp-汉诺塔问题，待理解" class="headerlink" title="六、dp,汉诺塔问题，待理解"></a>六、dp,汉诺塔问题，待理解</h2><p><a href="https://codeforces.com/group/Aokqa6Haao/contest/428602/problem/F">Problem - F - Codeforces</a></p><h3 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h3><p>本身套用三汉诺塔问题的递推方程，ans表示答案，预处理，并且在处理过程中有一个类似最短路径的处理</p><h2 id="七、dp背包，"><a href="#七、dp背包，" class="headerlink" title="七、dp背包，"></a>七、dp背包，</h2><p><a href="https://codeforces.com/group/Aokqa6Haao/contest/432112">Dashboard - CUSTACM 2023 Training 1 - Codeforces</a></p><h3 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h3><p>   但是有个区间的压缩，r[i]记录这个i的位置的最右区间，然后常规dp</p><p>  一维遍历前i的位置，二维遍历选几个区间，内部选和不选，</p><p>选的话 从i-1的位置进入，j-1的位置再选，</p><p>不选的话，从i-1的位置到现在的位置，每次选最大，最后dp【n】【k】即是最后的答案</p><h2 id="八、dp，欧拉筛，线性组合，01背包变形"><a href="#八、dp，欧拉筛，线性组合，01背包变形" class="headerlink" title="八、dp，欧拉筛，线性组合，01背包变形"></a>八、dp，欧拉筛，线性组合，01背包变形</h2><p><a href="https://codeforces.com/contest/1794/problem/D">Problem - D - Codeforces</a></p><h3 id="思路：-6"><a href="#思路：-6" class="headerlink" title="思路："></a>思路：</h3><p>首先预处理fac（mod意义下的前缀积），facinv(前缀积的逆元),预处理欧拉筛</p><p>之后，dp[i] [j]表示前i种质数，选择j种的所有可以的情况的facinv</p><p>最后fac(n)* （所有非质数的全排列的逆元） %mod *dp[cnt] [n]%mod;表示在所有数中选n个不同的质数的全部情况</p><h2 id="九、dp暴力或者贪心都行"><a href="#九、dp暴力或者贪心都行" class="headerlink" title="九、dp暴力或者贪心都行"></a>九、dp暴力或者贪心都行</h2><p><a href="https://codeforces.com/contest/1809/problem/D">Problem - D - Codeforces</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>dp[i] [3]表示到i位置不同情况的集合</p><p>集合划分：</p><p>当前是1：</p><p>前边是1、0或者直接转移，或者删除当前</p><p>当前是0：</p><p>前边是1、0或者删除当前</p><p>最后取最小</p><h2 id="十、多种方法，dp"><a href="#十、多种方法，dp" class="headerlink" title="十、多种方法，dp"></a>十、多种方法，dp</h2><p><a href="https://codeforces.com/gym/104252/problem/E">Problem - E - Codeforces</a></p><h3 id="思路：-7"><a href="#思路：-7" class="headerlink" title="思路："></a>思路：</h3><p>开二维数组</p><p>状态表示：反向开设，dp[ i ] [ j ]指的是左边i和右边j块是否覆盖，</p><p>集合划分：暴力所有块数，不到O（n^3），如果len长度可以就给左边或者右边,维数一个变一个不变，相当于只用一次</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">1</span>;len&lt;=n+<span class="number">1</span>;++len)&#123;</span><br><span class="line"><span class="keyword">if</span>(len==k)<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=l;j&gt;=<span class="number">0</span>;--j)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> z=r;z&gt;=<span class="number">0</span>;--z)&#123;</span><br><span class="line"><span class="keyword">if</span>(len&lt;=j)dp[j][z]|=dp[j-len][z];<span class="comment">//维数一个变一个不变，相当于只用一次</span></span><br><span class="line"><span class="keyword">if</span>(len&lt;=z)dp[j][z]|=dp[j][z-len];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十一、记忆化搜索，树上"><a href="#十一、记忆化搜索，树上" class="headerlink" title="十一、记忆化搜索，树上"></a>十一、记忆化搜索，树上</h2><p><a href="https://codeforces.com/contest/1806/problem/E">Problem - E - Codeforces</a></p><h3 id="思路：-8"><a href="#思路：-8" class="headerlink" title="思路："></a>思路：</h3><p>因为空间开不了2个1e5，所以有个编号cnt，但是cnt《&#x3D;320的时候才记录或者返回，（不太清楚</p><p>记忆化搜索：截止的地方–返回数组–深搜–回溯更新dp数组，这个320还没法处理掉，也就是说一定得推导出320这个边界。</p><h2 id="十二、换根dp（树上的"><a href="#十二、换根dp（树上的" class="headerlink" title="十二、换根dp（树上的"></a>十二、换根dp（树上的</h2><p><a href="https://codeforces.com/contest/1805/problem/D">Problem - D - Codeforces</a></p><h3 id="思路：-9"><a href="#思路：-9" class="headerlink" title="思路："></a>思路：</h3><p> <a href="..%5C%E7%9F%A5%E8%AF%86%E9%9B%86%5C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.md">动态规划.md</a> </p><h2 id="十三、dp，自动取模"><a href="#十三、dp，自动取模" class="headerlink" title="十三、dp，自动取模"></a>十三、dp，自动取模</h2><p><a href="https://codeforces.com/contest/1811/problem/G2">Problem - G2 - Codeforces</a></p><h3 id="思路：-10"><a href="#思路：-10" class="headerlink" title="思路："></a>思路：</h3><p>题意：每一块同颜色，最大块数的前提下最多数量</p><p>策略：明显的是dp但是需要优化，sum记录每一块的最大数量，注意每块（同块内颜色一致）和每块边界的处理</p><p>（可以有不同的颜色，所以重新累加</p><p>状态:dp[i ] [j ]          i表示最后的位置（右边界），j表示颜色，        一维位置，一维颜色      问题的解决决定状态和划分</p><p>划分：分块，处理块间和块中。</p><p>注意：一定注意数组初始化，不初始化数组的话，会混乱掉的。</p><h2 id="十四、线性dp"><a href="#十四、线性dp" class="headerlink" title="十四、线性dp"></a>十四、线性dp</h2><p><a href="https://www.luogu.com.cn/problem/P1280">P1280 尼克的任务 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><h3 id="思路：-11"><a href="#思路：-11" class="headerlink" title="思路："></a>思路：</h3><p>题意：最长空闲时间的选择</p><p>策略：</p><p>dp[i]最大休闲时间，正着走会受到后续的影响，所以倒着走</p><p>用sum记录当前点开始的个数，</p><p>集合划分：</p><p>sum&#x3D;&#x3D;0时，空闲时间+1</p><p>sum！&#x3D;-时，num表示应该运行第几个任务了，然后将长空闲时间转移到当前位置。</p><h2 id="十五、区间dp或者树形dp"><a href="#十五、区间dp或者树形dp" class="headerlink" title="十五、区间dp或者树形dp"></a>十五、区间dp或者树形dp</h2><p>[P1040 <a href="https://www.luogu.com.cn/problem/P1040">NOIP2003 提高组] 加分二叉树 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><h3 id="思路：-12"><a href="#思路：-12" class="headerlink" title="思路："></a>思路：</h3><p>dp是用来处理可重叠问题的，并且具有处理过的状态不会再影响后续状态的特点</p><p>  <strong>题意</strong>：给出二叉树中序遍历的结果，个人感觉是在固定左右关系</p><p>  <strong>策略</strong>：区间dp，分堆类型，并且用root记录根节点，最后前序遍历，要学习这种路径的记载（状态更新的时候，记录更新后的节点，更新后的路径</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r)<span class="keyword">return</span> ;</span><br><span class="line">    cout&lt;&lt;root[l][r]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">print</span>(l,root[l][r]<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">print</span>(root[l][r]+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//30个节点</span></span><br><span class="line">    <span class="comment">//题意：给出二叉树中序遍历的结果，个人感觉是在固定左右关系</span></span><br><span class="line">    <span class="comment">//策略：区间dp，分堆类型，并且用root记录根节点，最后前序遍历</span></span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        cin&gt;&gt;dp[i][i];</span><br><span class="line">        dp[i][i<span class="number">-1</span>]=<span class="number">1</span>;<span class="comment">//左子树应该默认为空，因为这个节点最大</span></span><br><span class="line">        root[i][i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">1</span>;len&lt;=n;++len)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l+len&lt;=n;++l)&#123;</span><br><span class="line">            <span class="type">int</span> r=l+len;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=l;k&lt;r;++k)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[l][r]&lt;dp[l][k<span class="number">-1</span>]*dp[k+<span class="number">1</span>][r]+dp[k][k])&#123;</span><br><span class="line">                    dp[l][r]=dp[l][k<span class="number">-1</span>]*dp[k+<span class="number">1</span>][r]+dp[k][k];</span><br><span class="line">                    root[l][r]=k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[<span class="number">1</span>][n]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>,n);</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h2 id="十六、线性dp"><a href="#十六、线性dp" class="headerlink" title="十六、线性dp"></a>十六、线性dp</h2><p><a href="https://www.luogu.com.cn/problem/P4933">P4933 大师 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><h3 id="思路：-13"><a href="#思路：-13" class="headerlink" title="思路："></a>思路：</h3><p>如何记载子序列不全为空且有次序可缺项的情况的总合，1 2 3  4  ans +1 +2 +3 +4           +1  +1  +1  +1</p><p>题意：子序列构成等差数列的情况的个数，</p><p>策略：线性dp，dp[i ] [ j ]表示以i为结尾，j为公差的情况数     ans记录总合，但是单个次序的记录的方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> h[maxj];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">1100</span>][<span class="number">40010</span>];<span class="comment">//以i为结尾，以j为公差，总共的个数，重复子问题递推的求解。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//n的个数支持立方的操作。</span></span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        cin&gt;&gt;h[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">20000</span>;</span><br><span class="line">    <span class="comment">//转移，集合划分错了，排列组合，逐个求解可以表达所有可能,也就是说  +1 +2 +3 逐个加可以</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        ans++;<span class="comment">//作为单个出现的时候</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=i<span class="number">-1</span>;l&gt;=<span class="number">1</span>;--l)&#123;<span class="comment">//01背包</span></span><br><span class="line">            dp[i][h[i]-h[l]+p]+=dp[l][h[i]-h[l]+p]+<span class="number">1</span>;<span class="comment">//公差可能重复所以需要累加</span></span><br><span class="line">            dp[i][h[i]-h[l]+p]%=mod;</span><br><span class="line">            ans+=dp[l][h[i]-h[l]+p]+<span class="number">1</span>;</span><br><span class="line">            ans%=mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h2 id="十七、线性dp"><a href="#十七、线性dp" class="headerlink" title="十七、线性dp"></a>十七、线性dp</h2><p><a href="https://codeforces.com/group/QJA47ykHfD/contest/437692/problem/E">Problem - E - Codeforces</a></p><p><strong>题意：</strong> 每次只移动左手或者右手，使得成本最小</p><p><strong>策略：</strong> 线性dp，</p><p><strong>集合表示：</strong>dp[ flag ] [ i ] [ j ]  ，一维表示到哪里了，（因为只有i和i-1，所以可以压缩） ，i表示左手哪个位置，j表示右手那个位置。</p><p><strong>集合处理：</strong>预处理距离，初始化dp数组，第一层暴力到那个音符，第二层初始化下个flag  and  左手走（左手和右手都从0到8暴力，并且左手产生新的贡献）  and  右手走（左手和右手都从0到8暴力，并且右手产生新的贡献）</p><p><strong>集合划分：</strong> 左手和右手分别暴力转移。</p><p>因为手放的点数很少，所以可以作为一维，</p><h2 id="十八、01背包"><a href="#十八、01背包" class="headerlink" title="十八、01背包"></a>十八、01背包</h2><p><a href="https://ac.nowcoder.com/acm/contest/57225/G">G-Chevonne’s Necklace_“统信杯” 第十七届黑龙江省大学生程序设计竞赛（正式赛）（重现赛）@yxh03 (nowcoder.com)</a></p><p>不太好想，对赌状态互不影响，对于状态方程而言，确实也是互不影响</p><p>然后用01背包去做，体积上的累加。</p><h2 id="十九、换根dp（未完"><a href="#十九、换根dp（未完" class="headerlink" title="十九、换根dp（未完"></a>十九、换根dp（未完</h2><h2 id="二十、单调队列结合dp"><a href="#二十、单调队列结合dp" class="headerlink" title="二十、单调队列结合dp"></a>二十、单调队列结合dp</h2><p><a href="https://codeforces.com/contest/940/problem/E">Problem - E - Codeforces</a></p><h3 id="思路：-14"><a href="#思路：-14" class="headerlink" title="思路："></a>思路：</h3><p>题意：给定意义下最小和</p><p>  策略：单调队列优化dp，维护单调递减队列</p><p>尽可能细分，尽可能多删，少加大的,多删一点</p><p> 开始c长度区间无法区别，之后c区间的每个可以进行选择</p><h2 id="二十一、dp、拓扑序"><a href="#二十一、dp、拓扑序" class="headerlink" title="二十一、dp、拓扑序"></a>二十一、dp、拓扑序</h2><p><a href="https://codeforces.com/contest/1863/problem/E">https://codeforces.com/contest/1863/problem/E</a></p><h2 id="二十二、dp、一个位置有一种情况"><a href="#二十二、dp、一个位置有一种情况" class="headerlink" title="二十二、dp、一个位置有一种情况"></a>二十二、dp、一个位置有一种情况</h2><p><a href="https://codeforces.com/contest/1875/problem/D">Problem - D - Codeforces</a></p><h2 id="二十三、状压dp-记忆化搜索"><a href="#二十三、状压dp-记忆化搜索" class="headerlink" title="二十三、状压dp+记忆化搜索"></a>二十三、状压dp+记忆化搜索</h2><p><a href="https://codeforces.com/gym/104023/problem/D">Problem - D - Codeforces</a></p><h2 id="二十四、dp"><a href="#二十四、dp" class="headerlink" title="二十四、dp"></a>二十四、dp</h2><p><a href="https://codeforces.com/gym/104022/problem/B">https://codeforces.com/gym/104022/problem/B</a></p><h2 id="二十五、换根dp"><a href="#二十五、换根dp" class="headerlink" title="二十五、换根dp"></a>二十五、换根dp</h2><p><a href="https://codeforces.com/contest/1882/problem/D">https://codeforces.com/contest/1882/problem/D</a></p><h2 id="二十六、换根dp"><a href="#二十六、换根dp" class="headerlink" title="二十六、换根dp"></a>二十六、换根dp</h2><p><a href="https://codeforces.com/gym/104008/problem/G">https://codeforces.com/gym/104008/problem/G</a></p><h2 id="二十七、dp"><a href="#二十七、dp" class="headerlink" title="二十七、dp"></a>二十七、dp</h2><p><a href="https://codeforces.com/gym/104128/problem/B">Problem - B - Codeforces</a></p><h2 id="二十八、树形dp"><a href="#二十八、树形dp" class="headerlink" title="二十八、树形dp"></a>二十八、树形dp</h2><p><a href="https://codeforces.com/contest/1929/problem/D">Problem - D - Codeforces</a></p><h2 id="二十九、四维dp"><a href="#二十九、四维dp" class="headerlink" title="二十九、四维dp"></a>二十九、四维dp</h2><p><a href="https://www.acwing.com/problem/content/description/1214/">1212. 地宫取宝 - AcWing题库</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dp[N][N][N][N];<span class="comment">// 四维dp，主要看影响因素和状态的转移</span></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,k;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;++j)&#123;</span><br><span class="line">            cin&gt;&gt;a[i][j];</span><br><span class="line">            a[i][j]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化，第一个元素拿或者不拿都有一种</span></span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>][a[<span class="number">1</span>][<span class="number">1</span>]]=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// dp[i][j][cnt][k]在i、j位置，要了cnt个，然后重量是k，因为这个值受四个状态影响</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;++j)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> cnt=<span class="number">0</span>;cnt&lt;=k;++cnt)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> kk=<span class="number">0</span>;kk&lt;<span class="number">15</span>;++kk)&#123;</span><br><span class="line">                    <span class="comment">// 这个位置不要，那么个数和值都可满足</span></span><br><span class="line">                    dp[i][j][cnt][kk]=(dp[i][j][cnt][kk]+dp[i<span class="number">-1</span>][j][cnt][kk])%MOD;</span><br><span class="line">                    dp[i][j][cnt][kk]=(dp[i][j][cnt][kk]+dp[i][j<span class="number">-1</span>][cnt][kk])%MOD;</span><br><span class="line">                    <span class="keyword">if</span>(cnt&gt;<span class="number">0</span>&amp;&amp;kk==a[i][j])&#123;</span><br><span class="line">                        <span class="comment">// 多一个需要对第四维大小进行操作</span></span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> ss=<span class="number">0</span>;ss&lt;kk;++ss)&#123; <span class="comment">// 从0开始，要是没有东西咋办</span></span><br><span class="line">                            dp[i][j][cnt][kk]=(dp[i][j][cnt][kk]+dp[i<span class="number">-1</span>][j][cnt<span class="number">-1</span>][ss])%MOD;</span><br><span class="line">                            dp[i][j][cnt][kk]=(dp[i][j][cnt][kk]+dp[i][j<span class="number">-1</span>][cnt<span class="number">-1</span>][ss])%MOD;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for(int i=)</span></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 累加所有可能最大重量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">15</span>;++i)&#123;</span><br><span class="line">        ans=(ans+dp[n][m][k][i])%MOD;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;dp[n][m][k][i]&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三十、单调队列优化dp"><a href="#三十、单调队列优化dp" class="headerlink" title="三十、单调队列优化dp"></a>三十、单调队列优化dp</h2><p>维护区间最值问题</p><p>问题难点：区间长度为d必须有一次跳跃，没办法逐一维护区间的每一个点</p><p>在可行范围内维护最小值，队列记录下标，队列原数组有序从小到大</p><p>注意下标和变量设置</p><p><a href="https://codeforces.com/contest/1941/problem/F">Problem - F - Codeforces</a></p><h2 id="三十一、线性dp，在两行中选择，有数量控制"><a href="#三十一、线性dp，在两行中选择，有数量控制" class="headerlink" title="三十一、线性dp，在两行中选择，有数量控制"></a>三十一、线性dp，在两行中选择，有数量控制</h2><p>问题在于：审错题了，名次在m以内就行，然后可以随便使用操作</p><p><a href="https://codeforces.com/contest/1945/problem/D">Problem - D - Codeforces</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 里边有个规则，可以任意使用操作包括次数</span></span><br><span class="line"><span class="comment">// a的可以随便取，b的前边需要有个a</span></span><br><span class="line"><span class="type">int</span> n,m;cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">cin&gt;&gt;b[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意审题和问题的转换</span></span><br><span class="line"><span class="comment">// 从后往前，只要前边有个a后边可以随便选</span></span><br><span class="line"><span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> ans=inf;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;--i)&#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;=m)&#123;</span><br><span class="line">ans=<span class="built_in">min</span>(ans,sum+a[i]);</span><br><span class="line">&#125;</span><br><span class="line">sum+=<span class="built_in">min</span>(a[i],b[i]);</span><br><span class="line">&#125; </span><br><span class="line">cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三十二、单调队列优化dp，二分"><a href="#三十二、单调队列优化dp，二分" class="headerlink" title="三十二、单调队列优化dp，二分"></a>三十二、单调队列优化dp，二分</h2><p><a href="https://codeforces.com/contest/1918/problem/D">Problem - D - Codeforces</a></p><h2 id="三十三、状压dp"><a href="#三十三、状压dp" class="headerlink" title="三十三、状压dp"></a>三十三、状压dp</h2><p><a href="https://www.acwing.com/problem/content/description/3497/">3494. 国际象棋 - AcWing题库</a></p><p>如何计算二进制中1的个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_count</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        ans++;</span><br><span class="line">        x-=x&amp;-x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对可以状压dp的一维进行状压dp，那些状态影响就要考虑几维</span></span><br><span class="line"><span class="type">int</span> dp[N][M][M][K];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_count</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        ans++;</span><br><span class="line">        x-=x&amp;-x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld %lld&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    <span class="comment">// cout&lt;&lt;get_count(3)&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="comment">// 状态是三列之间的转移，列行的概念不绝对</span></span><br><span class="line">        <span class="comment">// 从深到浅 b a c</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">0</span>;a&lt;(<span class="number">1</span>&lt;&lt;n);++a)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> b=<span class="number">0</span>;b&lt;(<span class="number">1</span>&lt;&lt;n);++b)&#123;</span><br><span class="line">                <span class="comment">// 有就不行所以没有&amp;1</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(((a&lt;&lt;<span class="number">2</span>)&amp;b)||((b&lt;&lt;<span class="number">2</span>)&amp;a))<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> c=<span class="number">0</span>;c&lt;(<span class="number">1</span>&lt;&lt;n);++c)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(((a&lt;&lt;<span class="number">2</span>)&amp;c)||((c&lt;&lt;<span class="number">2</span>)&amp;a))<span class="keyword">continue</span>;</span><br><span class="line">                    <span class="comment">// 这三层相互之间都有影响</span></span><br><span class="line">                    <span class="keyword">if</span>(((b&lt;&lt;<span class="number">1</span>)&amp;c)||((c&lt;&lt;<span class="number">1</span>&amp;b)))<span class="keyword">continue</span>;</span><br><span class="line">                    <span class="comment">// 从i-1转移到i</span></span><br><span class="line">                    <span class="type">int</span> t=<span class="built_in">get_count</span>(b);</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> kk=t;kk&lt;=k;++kk)&#123;</span><br><span class="line">                        <span class="comment">// 更新kk数量，代表上一层转移到当前层</span></span><br><span class="line">                        dp[i][a][b][kk]=(dp[i][a][b][kk]+dp[i<span class="number">-1</span>][c][a][kk-t])%MOD;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;n);++j)&#123;</span><br><span class="line">            <span class="comment">// 我的第一维是列</span></span><br><span class="line">            ans=(ans+dp[m][i][j][k])%MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三十四、状压dp，构造题，mex（待处理"><a href="#三十四、状压dp，构造题，mex（待处理" class="headerlink" title="三十四、状压dp，构造题，mex（待处理"></a>三十四、状压dp，构造题，mex（待处理</h2><p><a href="https://codeforces.com/contest/1956/problem/D">Problem - D - Codeforces</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lca</title>
      <link href="/2024/05/02/lca/"/>
      <url>/2024/05/02/lca/</url>
      
        <content type="html"><![CDATA[<h1 id="Lca"><a href="#Lca" class="headerlink" title="Lca"></a>Lca</h1><h2 id="知识："><a href="#知识：" class="headerlink" title="知识："></a>知识：</h2><p>基本概述：在树上求解最近公共祖先</p><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><p>向上标记法：O(n)很少用</p><h3 id="方法二：倍增"><a href="#方法二：倍增" class="headerlink" title="方法二：倍增"></a>方法二：倍增</h3><p>倍增：O(n*log(n))，在线</p><p>二进制拼凑：可以从高位到低位枚举二进制从而拼凑出任何一个数</p><h4 id="首先预处理："><a href="#首先预处理：" class="headerlink" title="首先预处理："></a>首先预处理：</h4><p>bfs(防止爆栈)或者dfs(求siz)</p><p>fa[i,j]表示从i节点开始，向上走2^j步，所能走到的节点，0&lt;&#x3D;j&lt;&#x3D;logn</p><p>dep[i]表示深度</p><h5 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h5><p>bfs</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(depth, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> depth);</span><br><span class="line">    depth[<span class="number">0</span>] = <span class="number">0</span>, depth[root] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>] = root;</span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++ ];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (depth[j] &gt; depth[t] + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                depth[j] = depth[t] + <span class="number">1</span>;</span><br><span class="line">                q[ ++ tt] = j;</span><br><span class="line">                fa[j][<span class="number">0</span>] = t;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">15</span>; k ++ )</span><br><span class="line">                    fa[j][k] = fa[fa[j][k - <span class="number">1</span>]][k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dfs</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lca是这类问题的核心，注意哨兵的作用 ,把1令成根 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> faa,<span class="type">int</span> de)</span></span>&#123;</span><br><span class="line">siz[u]=<span class="number">1</span>;</span><br><span class="line">dep[u]=de;</span><br><span class="line">fa[u][<span class="number">0</span>]=faa;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">20</span>;++j)&#123;</span><br><span class="line">fa[u][j]=fa[fa[u][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;g[u].<span class="built_in">size</span>();++i)&#123;</span><br><span class="line"><span class="type">int</span> v=g[u][i];</span><br><span class="line"><span class="keyword">if</span>(v==faa)<span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs</span>(v,u,de+<span class="number">1</span>);</span><br><span class="line">siz[u]+=siz[v];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><p>1）首先，让u成为深的一层，让两个点成为同一层</p><p>2）让两个点同时往上跳，一直跳到它们最近公共祖先的下一层，返回fa[u] [0];</p><h5 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (depth[a] &lt; depth[b]) <span class="built_in">swap</span>(a, b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">15</span>; k &gt;= <span class="number">0</span>; k -- )</span><br><span class="line">        <span class="keyword">if</span> (depth[fa[a][k]] &gt;= depth[b])</span><br><span class="line">            a = fa[a][k];</span><br><span class="line">    <span class="keyword">if</span> (a == b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">15</span>; k &gt;= <span class="number">0</span>; k -- )</span><br><span class="line">        <span class="keyword">if</span> (fa[a][k] != fa[b][k])</span><br><span class="line">        &#123;</span><br><span class="line">            a = fa[a][k];</span><br><span class="line">            b = fa[b][k];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[a][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法三："><a href="#方法三：" class="headerlink" title="方法三："></a>方法三：</h3><p> Tarjan:离线算法，线性O(n+m)</p><p>运用并查集</p><p>1）存入询问</p><p>2）搜索暴力</p><p>3）结果在于 正在搜索的 对应于 已经搜索过的点  的合并的点</p><p>分为三大类：</p><p>1、已经遍历过且回溯过的点，2</p><p>2、正在搜索的，1</p><p>3、还未搜索的，0</p><h2 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h2><h3 id="祖孙询问（方法二"><a href="#祖孙询问（方法二" class="headerlink" title="祖孙询问（方法二"></a>祖孙询问（方法二</h3><p><a href="https://www.acwing.com/problem/content/1174/">1172. 祖孙询问 - AcWing题库</a></p><p>板子题：</p><h4 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">40010</span>, M = N * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> depth[N], fa[N][<span class="number">16</span>];</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(depth, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> depth);</span><br><span class="line">    depth[<span class="number">0</span>] = <span class="number">0</span>, depth[root] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>] = root;</span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++ ];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (depth[j] &gt; depth[t] + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                depth[j] = depth[t] + <span class="number">1</span>;</span><br><span class="line">                q[ ++ tt] = j;</span><br><span class="line">                fa[j][<span class="number">0</span>] = t;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">15</span>; k ++ )</span><br><span class="line">                    fa[j][k] = fa[fa[j][k - <span class="number">1</span>]][k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (depth[a] &lt; depth[b]) <span class="built_in">swap</span>(a, b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">15</span>; k &gt;= <span class="number">0</span>; k -- )</span><br><span class="line">        <span class="keyword">if</span> (depth[fa[a][k]] &gt;= depth[b])</span><br><span class="line">            a = fa[a][k];</span><br><span class="line">    <span class="keyword">if</span> (a == b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">15</span>; k &gt;= <span class="number">0</span>; k -- )</span><br><span class="line">        <span class="keyword">if</span> (fa[a][k] != fa[b][k])</span><br><span class="line">        &#123;</span><br><span class="line">            a = fa[a][k];</span><br><span class="line">            b = fa[b][k];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[a][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="type">int</span> root = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">-1</span>) root = a;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">add</span>(a, b), <span class="built_in">add</span>(b, a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bfs</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="type">int</span> p = <span class="built_in">lca</span>(a, b);</span><br><span class="line">        <span class="keyword">if</span> (p == a) <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == b) <span class="built_in">puts</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="距离（方法三"><a href="#距离（方法三" class="headerlink" title="距离（方法三"></a>距离（方法三</h3><p><a href="https://www.acwing.com/problem/content/1173/">1171. 距离 - AcWing题库</a></p><p>两点的距离：两点到根节点的距离-2*lca到根节点的距离</p><h4 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>, M = N * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], w[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="type">int</span> res[M];</span><br><span class="line"><span class="type">int</span> st[N];</span><br><span class="line">vector&lt;PII&gt; query[N];   <span class="comment">// first存查询的另外一个点，second存查询编号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (j == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dist[j] = dist[u] + w[i];</span><br><span class="line">        <span class="built_in">dfs</span>(j, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="comment">//没有搜索和进行搜索回溯合并</span></span><br><span class="line">        <span class="keyword">if</span> (!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(j);</span><br><span class="line">            p[j] = u;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> item : query[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y = item.first, id = item.second;</span><br><span class="line">        <span class="keyword">if</span> (st[y] == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> anc = <span class="built_in">find</span>(y);</span><br><span class="line">            res[id] = dist[u] + dist[y] - dist[anc] * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    st[u] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a, b, c), <span class="built_in">add</span>(b, a, c);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//预处理，存入询问</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">if</span> (a != b)</span><br><span class="line">        &#123;</span><br><span class="line">            query[a].<span class="built_in">push_back</span>(&#123;b, i&#125;);</span><br><span class="line">            query[b].<span class="built_in">push_back</span>(&#123;a, i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//并查集初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">tarjan</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ ) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Alexandria-Library"><a href="#Alexandria-Library" class="headerlink" title="Alexandria Library"></a>Alexandria Library</h3><p>向上跳dep</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">20</span>;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>((dep&gt;&gt;i)&amp;<span class="number">1</span>)x=fa[x][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br></pre></td></tr></table></figure><h4 id="代码：-4"><a href="#代码：-4" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rl rt&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rr rt&lt;&lt;1|1</span></span><br><span class="line"><span class="comment">// #pragma GCC optimize(2)</span></span><br><span class="line"><span class="comment">// #pragma GCC optimize(3,&quot;ofast&quot;,&quot;inline&quot;)</span></span><br><span class="line"><span class="comment">// #define ull unsigned long long</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxj=<span class="number">3e5</span>+<span class="number">100</span>,P=<span class="number">131</span>,mod=<span class="number">998244353</span>,inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,m,n) for(int i=m;i&lt;=n;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">t</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(t &amp;res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    t flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((c = <span class="built_in">getchar</span>()) &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            flag = <span class="number">-1</span>;</span><br><span class="line">    res = c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span> ((c = <span class="built_in">getchar</span>()) &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; c &gt;= <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        res = res * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    res *= flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,q;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;g[maxj];</span><br><span class="line"><span class="type">int</span> siz[maxj],dep[maxj];</span><br><span class="line"><span class="type">int</span> fa[maxj][<span class="number">22</span>];</span><br><span class="line"><span class="comment">//lca是这类问题的核心，注意哨兵的作用 ,把1令成根 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> faa,<span class="type">int</span> de)</span></span>&#123;</span><br><span class="line">siz[u]=<span class="number">1</span>;</span><br><span class="line">dep[u]=de;</span><br><span class="line">fa[u][<span class="number">0</span>]=faa;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">20</span>;++j)&#123;</span><br><span class="line">fa[u][j]=fa[fa[u][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;g[u].<span class="built_in">size</span>();++i)&#123;</span><br><span class="line"><span class="type">int</span> v=g[u][i];</span><br><span class="line"><span class="keyword">if</span>(v==faa)<span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs</span>(v,u,de+<span class="number">1</span>);</span><br><span class="line">siz[u]+=siz[v];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//跳跃到的位置 ,表达跳多高 ,发生差值的跳跃 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">up</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> de)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">20</span>;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>((de&gt;&gt;i)&amp;<span class="number">1</span>)x=fa[x][i];</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="comment">//让y的深度尽可能小</span></span><br><span class="line"><span class="keyword">if</span>(dep[u]&lt;dep[v])<span class="built_in">swap</span>(u,v);</span><br><span class="line"><span class="type">int</span> xx=u,yy=v;</span><br><span class="line"><span class="comment">//需要一个记载他跳跃的步数,具不具备路径相同的点 </span></span><br><span class="line"><span class="type">int</span> sep=<span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> flag=<span class="number">0</span>; </span><br><span class="line"><span class="comment">//跳到同一深度</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">20</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(dep[fa[u][i]]&gt;=dep[v])&#123;</span><br><span class="line">flag=<span class="number">1</span>;</span><br><span class="line">sep-=dep[fa[u][i]]-dep[u];</span><br><span class="line">u=fa[u][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//单只树上的情况 </span></span><br><span class="line"><span class="keyword">if</span>(u==v)&#123;</span><br><span class="line"><span class="keyword">if</span>(sep%<span class="number">2</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> f1=<span class="built_in">up</span>(xx,sep/<span class="number">2</span>);</span><br><span class="line"><span class="type">int</span> f2=<span class="built_in">up</span>(xx,sep/<span class="number">2</span><span class="number">-1</span>);</span><br><span class="line"><span class="keyword">return</span> siz[f1]-siz[f2];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//寻找lca算法 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">20</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line"><span class="keyword">if</span>(fa[u][i]!=fa[v][i])&#123;</span><br><span class="line"><span class="comment">//两个分支都在跳 </span></span><br><span class="line">sep=sep+(-dep[fa[u][i]]+dep[u])-(dep[fa[v][i]]-dep[v]);</span><br><span class="line">u=fa[u][i];</span><br><span class="line">v=fa[v][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//少算了lca点</span></span><br><span class="line">sep+=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(sep%<span class="number">2</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//开始的时候都在同一层次 ,减去树的两个分支 </span></span><br><span class="line"><span class="keyword">if</span>(flag==<span class="number">0</span>)&#123;</span><br><span class="line"> <span class="type">int</span> f1=<span class="built_in">up</span>(xx,sep/<span class="number">2</span><span class="number">-1</span>);</span><br><span class="line"><span class="type">int</span> f2=<span class="built_in">up</span>(yy,sep/<span class="number">2</span><span class="number">-1</span>);</span><br><span class="line"><span class="keyword">return</span> n-siz[f1]-siz[f2];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> f1=<span class="built_in">up</span>(xx,sep/<span class="number">2</span>);</span><br><span class="line"><span class="type">int</span> f2=<span class="built_in">up</span>(xx,sep/<span class="number">2</span><span class="number">-1</span>);</span><br><span class="line"><span class="keyword">return</span> siz[f1]-siz[f2];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)g[i].<span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;++i)&#123;</span><br><span class="line"><span class="type">int</span> u,v;cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">g[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span>(q--)&#123;</span><br><span class="line"><span class="type">int</span> u,v;</span><br><span class="line">cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line"><span class="keyword">if</span>(u==v)&#123;</span><br><span class="line">cout&lt;&lt;n&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> cout&lt;&lt;<span class="built_in">query</span>(u,v)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;   </span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;library.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t;t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 知识讲解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dp</title>
      <link href="/2024/05/02/dp/"/>
      <url>/2024/05/02/dp/</url>
      
        <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>动态规划，有重复子问题，往往有递归方程，这个往往可以演绎出递推方程，</p><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>有 N件物品和一个容量是 V的背包。每件物品只能使用一次。</p><h4 id="状态表示："><a href="#状态表示：" class="headerlink" title="状态表示："></a>状态表示：</h4><p>前i个物品，占用体积v的价值最大</p><h4 id="集合划分："><a href="#集合划分：" class="headerlink" title="集合划分："></a>集合划分：</h4><p>第i个物品可以选（容量减小，价值变大），可以不选（容量价值不变）</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=v[i];j--)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[j]=<span class="built_in">max</span>(dp[j],dp[j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><h4 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h4><p>有 N 种物品和一个容量是 V的背包，每种物品都有无限件可用。</p><h4 id="状态表示：-1"><a href="#状态表示：-1" class="headerlink" title="状态表示："></a>状态表示：</h4><p>前i个物品，占用体积v的价值最大</p><h4 id="集合划分：-1"><a href="#集合划分：-1" class="headerlink" title="集合划分："></a>集合划分：</h4><p>第i个物品可以选（容量减小，价值变大），可以不选（容量价值不变）</p><p>从小到大更新，更新f[i,j],从大到小更新,更新f[i-1,j];</p><p>公式试推导出来的</p><p>f[i,j]&#x3D;f[i,j-v]+w…</p><p>f[i,j-v]&#x3D;f[j-v*2]+w….</p><p>&#x3D;&gt;当前公式</p><h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = v[i]; j &lt;= m; j ++ )</span><br><span class="line">          f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br></pre></td></tr></table></figure><h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3><h4 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h4><p>有 N种物品和一个容量是 V 的背包。</p><p>第 i种物品最多有 si 件，每件体积是 vi，价值是 wi。</p><h4 id="状态表示：-2"><a href="#状态表示：-2" class="headerlink" title="状态表示："></a>状态表示：</h4><p>前i个物品，占用体积v的价值最大</p><h4 id="集合划分：-2"><a href="#集合划分：-2" class="headerlink" title="集合划分："></a>集合划分：</h4><p>第i个物品可以选（容量减小，价值变大），可以不选（容量价值不变）</p><p>注意可以运用区间的可分性，采用倍增来做题。</p><p>通过倍增分组，然后采用01背包来做题</p><h4 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n,v0;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;v0;</span><br><span class="line">    <span class="comment">//多重背包涉及倍增优化，分组的优化,转化成01背包</span></span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="type">int</span> vv,ww,ss;</span><br><span class="line">        cin&gt;&gt;vv&gt;&gt;ww&gt;&gt;ss;</span><br><span class="line">        <span class="type">int</span> now=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(ss&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            now=<span class="built_in">min</span>(ss,now);</span><br><span class="line">            v[++cnt]=vv*now;</span><br><span class="line">            w[cnt]=ww*now;</span><br><span class="line">            ss-=now;</span><br><span class="line">            now*=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ss&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            v[++cnt]=vv*ss;</span><br><span class="line">            w[cnt]=ww*ss;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for(int i=1;i&lt;=cnt;++i)cout&lt;&lt;v[i]&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">    n=cnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=v0;j&gt;=v[i];--j)&#123;</span><br><span class="line">            f[j]=<span class="built_in">max</span>(f[j],f[j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[v0]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h3><h4 id="题目描述：-3"><a href="#题目描述：-3" class="headerlink" title="题目描述："></a>题目描述：</h4><p>有 N组物品和一个容量是 V的背包。</p><p>每组物品有若干个，同一组内的物品最多只能选一个。</p><h4 id="状态表示：-3"><a href="#状态表示：-3" class="headerlink" title="状态表示："></a>状态表示：</h4><p>前i个物品，占用体积v的价值最大</p><h4 id="集合划分：-3"><a href="#集合划分：-3" class="headerlink" title="集合划分："></a>集合划分：</h4><p>第i个物品可以选（容量减小，价值变大），可以不选（容量价值不变）</p><p>第一维第几组</p><p>第二维多大重量，从大到小，采用01背包的打法</p><p>第三维遍历所有情况，拿到最优解</p><h4 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">for(int i=1;i&lt;=n;++i)&#123;</span><br><span class="line">        cin&gt;&gt;x[i];</span><br><span class="line">        for(int j=1;j&lt;=x[i];++j)&#123;</span><br><span class="line">            cin&gt;&gt;v[i][j]&gt;&gt;w[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // f[0]=1;，方向错了，正着完全背包，反着01背包</span><br><span class="line">    for(int i=1;i&lt;=n;++i)&#123;</span><br><span class="line">        for(int j=v0;j&gt;=1;--j)&#123;</span><br><span class="line">            for(int k=1;k&lt;=x[i];++k)&#123;</span><br><span class="line">                if(j&gt;=v[i][k])&#123;</span><br><span class="line">                    f[j]=max(f[j],f[j-v[i][k]]+w[i][k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="线性DP"><a href="#线性DP" class="headerlink" title="线性DP"></a>线性DP</h2><h3 id="lcs（最长公共子序列"><a href="#lcs（最长公共子序列" class="headerlink" title="lcs（最长公共子序列"></a>lcs（最长公共子序列</h3><h4 id="板子："><a href="#板子：" class="headerlink" title="板子："></a>板子：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://www.luogu.com.cn/problem/P1439</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;mp;<span class="comment">//由于a全排列，所以记录每个数在a中的位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        mp[a[i]]=i;</span><br><span class="line">        dp[i]=<span class="number">1e12</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        cin&gt;&gt;b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最长上升子序列+最长公共子序列</span></span><br><span class="line">    <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=len;</span><br><span class="line">        <span class="keyword">if</span>(mp[b[i]]&gt;dp[len])dp[++len]=mp[b[i]];<span class="comment">//如果当前位置靠后，那么就可以添加进这个数，</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">//dp数组满足单调性，所以可以二分更新右边界+1，右边界+1的位置尽可能小，那么才可能加进更多的数</span></span><br><span class="line">            <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">                <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(dp[mid]&gt;mp[b[i]])&#123;</span><br><span class="line">                    r=mid<span class="number">-1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    l=mid+<span class="number">1</span>;</span><br><span class="line">                    ans=mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans++;</span><br><span class="line">            dp[ans]=<span class="built_in">min</span>(dp[ans],mp[b[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;len&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h3 id="Lis（最长上升子序列"><a href="#Lis（最长上升子序列" class="headerlink" title="Lis（最长上升子序列"></a>Lis（最长上升子序列</h3><h4 id="板子"><a href="#板子" class="headerlink" title="板子"></a>板子</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Lcp（最长公共前缀"><a href="#Lcp（最长公共前缀" class="headerlink" title="Lcp（最长公共前缀"></a>Lcp（最长公共前缀</h3><p><a href="https://codeforces.com/contest/611/problem/D">https://codeforces.com/contest/611/problem/D</a></p><h4 id="板子-1"><a href="#板子-1" class="headerlink" title="板子"></a>板子</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//lcp加dp，这个题个人觉得挺难的</span></span><br><span class="line"><span class="type">int</span> dp[<span class="number">5500</span>][<span class="number">5500</span>],sum[<span class="number">5500</span>][<span class="number">5500</span>];</span><br><span class="line"><span class="type">int</span> n;string s;</span><br><span class="line"><span class="type">int</span> lcp[<span class="number">5500</span>][<span class="number">5500</span>];<span class="comment">//字符串长度，第i到最后，和第j到最后的lcp公共长度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getLcp</span><span class="params">()</span> <span class="comment">//最长公共前缀lcp</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt; i; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j]) lcp[i][j] = lcp[i + <span class="number">1</span>][j + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> lcp[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="comment">//长度一样的起始位置</span></span><br><span class="line">    <span class="type">char</span> a1=s[x+lcp[x][y]];</span><br><span class="line">    <span class="type">char</span> a2=s[y+lcp[x][y]];</span><br><span class="line">    <span class="keyword">if</span>(a1&lt;a2)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//主要在解决两个问题，</span></span><br><span class="line">    <span class="comment">//如何节省字符串大小比较的复杂度，---采用lcp来O1的比较</span></span><br><span class="line">    <span class="comment">//dp方程如何设，---dp[i][j]第i个位置，后边j长度的合理答案</span></span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    s=<span class="string">&#x27; &#x27;</span>+s;</span><br><span class="line">    <span class="built_in">getLcp</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;++i)sum[<span class="number">0</span>][i]=<span class="number">1</span>;<span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">1</span>;len&lt;=i;++len)&#123;<span class="comment">//到i位置的长度</span></span><br><span class="line">            <span class="type">int</span> j=i-len+<span class="number">1</span>;<span class="comment">//起始位置</span></span><br><span class="line">            <span class="keyword">if</span>(s[j]==<span class="string">&#x27;0&#x27;</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//长度绝对可控的时候</span></span><br><span class="line">            dp[i][len]=sum[j<span class="number">-1</span>][len<span class="number">-1</span>];<span class="comment">//由前边位置转移过来，前边的个数小</span></span><br><span class="line">            <span class="type">int</span> pre=j-len;<span class="comment">//长度一样的时候的初始位置</span></span><br><span class="line">            <span class="keyword">if</span>(pre&lt;<span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(pre,j)&amp;&amp;lcp[pre][j]&lt;len)&#123;<span class="comment">//</span></span><br><span class="line">                dp[i][len]=(dp[i][len]+ dp[j<span class="number">-1</span>][len])%MOD;<span class="comment">//在长度相等的情况下，由之前的转移过来</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">            sum[i][j]=(sum[i][j<span class="number">-1</span>]+dp[i][j])%MOD;<span class="comment">//累计所有情况,错在，sum--相同结束的地方，然后一定长度下，由上一个长度转移过来</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        ans=(ans+dp[n][i])%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans%MOD&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h2><p>思路比较固定，代码比较板子，状态和集合划分比较简一</p><p>dp[i,j,01]或者dp[i,j]，ij一般表示区间，01一般表示左加还是右加</p><h3 id="P3205-HNOI2010-合唱队-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P3205-HNOI2010-合唱队-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="[P3205 HNOI2010]合唱队 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>[P3205 <a href="https://www.luogu.com.cn/problem/P3205">HNOI2010]合唱队 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h3><h4 id="状态和集合划分"><a href="#状态和集合划分" class="headerlink" title="状态和集合划分"></a>状态和集合划分</h4><p>dp[i,j,01]表示从i到j，在左还是在右添加，注意初始化和价值改变</p><p>在左：</p><p>从左来0</p><p>从右来1</p><p>在右：</p><p>从左来0</p><p>从右来1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> a[maxj];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">2000</span>][<span class="number">2000</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//多少种排列方式使得结果是理想型</span></span><br><span class="line"><span class="comment">//问题的逆向，以理想型为结果，找多少种方式可以到达</span></span><br><span class="line"><span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//区间dp ，区间上可以做到分解合并新增元素 </span></span><br><span class="line"><span class="comment">//初始化,其实就是一个顺序问题 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">dp[i][i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//第一维往往是长度 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">1</span>;len&lt;=n;++len)&#123;</span><br><span class="line"><span class="comment">//第二维往往是左端点 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r=l+len;l&lt;=n&amp;&amp;r&lt;=n;++l,++r)&#123;</span><br><span class="line"><span class="comment">//第三维可能是切块或者左右移动</span></span><br><span class="line"><span class="comment">//向左移动 </span></span><br><span class="line"><span class="keyword">if</span>(a[l]&lt;a[r])dp[l][r][<span class="number">0</span>]=(dp[l][r][<span class="number">0</span>]+dp[l+<span class="number">1</span>][r][<span class="number">1</span>])%mod;</span><br><span class="line"><span class="keyword">if</span>(a[l]&lt;a[l+<span class="number">1</span>])dp[l][r][<span class="number">0</span>]=(dp[l][r][<span class="number">0</span>]+dp[l+<span class="number">1</span>][r][<span class="number">0</span>])%mod;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向右移动</span></span><br><span class="line"><span class="keyword">if</span>(a[r]&gt;a[r<span class="number">-1</span>])dp[l][r][<span class="number">1</span>]=(dp[l][r][<span class="number">1</span>]+dp[l][r<span class="number">-1</span>][<span class="number">1</span>])%mod;</span><br><span class="line"><span class="keyword">if</span>(a[r]&gt;a[l])dp[l][r][<span class="number">1</span>]=(dp[l][r][<span class="number">1</span>]+dp[l][r<span class="number">-1</span>][<span class="number">0</span>])%mod;</span><br><span class="line">dp[l][r][<span class="number">0</span>]%=mod;</span><br><span class="line">dp[l][r][<span class="number">1</span>]%=mod; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;(dp[<span class="number">1</span>][n][<span class="number">0</span>]+dp[<span class="number">1</span>][n][<span class="number">1</span>])%mod&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h3 id="P4170-CQOI2007-涂色-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P4170-CQOI2007-涂色-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="[P4170 CQOI2007]涂色 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>[P4170 <a href="https://www.luogu.com.cn/problem/P4170">CQOI2007]涂色 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h3><h4 id="状态和集合划分-1"><a href="#状态和集合划分-1" class="headerlink" title="状态和集合划分"></a>状态和集合划分</h4><p>因为是涂色，所以可以区间合并，区间添加元素往往是区间dp</p><p>dp[i,j]从i到j涂色的所有搭配数量</p><p>l和r颜色一样，从中间选最小</p><p>不一样，中间选择，合并找到最小，价值增加在于两个区间各自最小的颜色方案数的求和</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[maxj];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">2000</span>][<span class="number">2000</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//区间dp,新增新的元素 </span></span><br><span class="line">string s;cin&gt;&gt;s;</span><br><span class="line"><span class="type">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">s=<span class="string">&#x27; &#x27;</span>+s;</span><br><span class="line"><span class="comment">//基本的板子+集合划分（分堆，区间新增元素的理解</span></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="comment">//因为有最小的选择，所以初始化到最大 </span></span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f3f3f3f</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">dp[i][i]=<span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> len = <span class="number">1</span>;len &lt;= n;++len)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r=l+len;r&lt;=n&amp;&amp;l&lt;=n;++l,++r)&#123;</span><br><span class="line"><span class="comment">//增加元素</span></span><br><span class="line"><span class="keyword">if</span>(s[l]==s[r])&#123;</span><br><span class="line">dp[l][r]=<span class="built_in">min</span>(dp[l][r<span class="number">-1</span>],dp[l+<span class="number">1</span>][r]);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//我理解是最优子结构，由小部分组合成大部分</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=l;k&lt;r;++k)&#123;<span class="comment">//右端点不等，因为需要留一个 </span></span><br><span class="line">dp[l][r]=<span class="built_in">min</span>(dp[l][r],dp[l][k]+dp[k+<span class="number">1</span>][r]);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;    </span><br><span class="line">&#125; </span><br><span class="line">cout&lt;&lt;dp[<span class="number">1</span>][n]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P1220-关路灯-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1220-关路灯-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P1220 关路灯 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a href="https://www.luogu.com.cn/problem/P1220">P1220 关路灯 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h3><h4 id="状态和集合划分-2"><a href="#状态和集合划分-2" class="headerlink" title="状态和集合划分"></a>状态和集合划分</h4><p>区间dp的题很固定，状态往往直接设，循环方程往往是固定的形式，</p><p>向左向右的题，往往开三维，直接设，遍历的去走</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">int</span> dp[<span class="number">100</span>][<span class="number">100</span>][<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> a[<span class="number">100</span>],b[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> sum[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> n,c;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//区间dp，要适当处理调头这一动作</span></span><br><span class="line"><span class="comment">//左右移动和分堆的题和板子没啥区别 </span></span><br><span class="line">cin&gt;&gt;n&gt;&gt;c;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">cin&gt;&gt;a[i]&gt;&gt;b[i];</span><br><span class="line">sum[i]=sum[i<span class="number">-1</span>]+b[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f3f3f3f</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line"><span class="comment">//向两端遍历</span></span><br><span class="line"><span class="comment">//初始化 </span></span><br><span class="line">dp[c][c][<span class="number">0</span>]=dp[c][c][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//第一维是长度 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> len = <span class="number">1</span>;len&lt;=n;++len)&#123;</span><br><span class="line"><span class="comment">//第二维是左端点 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l+len&lt;=n;++l)&#123;</span><br><span class="line"><span class="type">int</span> r=l+len;</span><br><span class="line"><span class="comment">//多增的功率，在于当前和未被关闭得灯的功率*累加的时间 </span></span><br><span class="line"><span class="comment">//从左边转移过来 </span></span><br><span class="line"><span class="keyword">if</span>(l+<span class="number">1</span>&lt;=r)</span><br><span class="line">dp[l][r][<span class="number">0</span>]=<span class="built_in">min</span>(dp[l+<span class="number">1</span>][r][<span class="number">1</span>]+(a[r]-a[l])*(sum[l]+sum[n]-sum[r]),dp[l+<span class="number">1</span>][r][<span class="number">0</span>]+(a[l+<span class="number">1</span>]-a[l])*(sum[l]+sum[n]-sum[r]));</span><br><span class="line"><span class="comment">//dp[l][r][0]=min(dp[l][r][0],);</span></span><br><span class="line"><span class="comment">//从右边转移过来 </span></span><br><span class="line"><span class="keyword">if</span>(l&lt;=r<span class="number">-1</span>)</span><br><span class="line">dp[l][r][<span class="number">1</span>] = <span class="built_in">min</span>(dp[l][r<span class="number">-1</span>][<span class="number">1</span>]+(a[r]-a[r<span class="number">-1</span>])*(sum[l<span class="number">-1</span>]+sum[n]-sum[r<span class="number">-1</span>]),dp[l][r<span class="number">-1</span>][<span class="number">0</span>]+(a[r]-a[l])*(sum[l<span class="number">-1</span>]+sum[n]-sum[r<span class="number">-1</span>]));</span><br><span class="line"><span class="comment">//dp[l][r][1]=min(dp[l][r][1],);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="built_in">min</span>(dp[<span class="number">1</span>][n][<span class="number">0</span>],dp[<span class="number">1</span>][n][<span class="number">1</span>]) &lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Problem-H-Codeforces"><a href="#Problem-H-Codeforces" class="headerlink" title="Problem - H - Codeforces"></a><a href="https://codeforces.com/group/QJA47ykHfD/contest/437692/problem/H">Problem - H - Codeforces</a></h3><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p><img src="C:\Users\30279\AppData\Roaming\Typora\typora-user-images\image-20230410092323837.png" alt="image-20230410092323837"></p><p>区间dp有O(n^3)和O(n^2)两种打法，前者用k分块，后者从区间中间向区间两边进军，后者需要考虑区间两端的变化就可以。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[l][r]=dp[l+<span class="number">1</span>][r<span class="number">-1</span>]+a[r]*b[l]+a[l]*b[r]-a[l]*b[l]-a[r]*b[r];</span><br></pre></td></tr></table></figure><p>dp[l ] [r ]表示l到r  反转后对于答案的贡献，然后对于所有a*b求和，加上最大的dp[l ] [r ]即为答案。</p><h3 id="P1063-NOIP2006-提高组-能量项链-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1063-NOIP2006-提高组-能量项链-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="[P1063 NOIP2006 提高组] 能量项链 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>[P1063 <a href="https://www.luogu.com.cn/problem/P1063">NOIP2006 提高组] 能量项链 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h3><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><p>矩阵连乘问题，多了个循环（多开一倍的空间），</p><p>len上限n，右区间的上限2*n，最后是，dp[i ] [i+n-1]因为长度是n所以必须减1，要不然就多了。</p><p>具体的转移控制下标：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[l][r]=max(dp[l][r],dp[l][k]+dp[k+1][r]+p[l]*p[k+1]*p[r+1]);//拼接</span><br></pre></td></tr></table></figure><h2 id="图上的dp"><a href="#图上的dp" class="headerlink" title="图上的dp"></a>图上的dp</h2><h3 id="P1613-跑路-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1613-跑路-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P1613 跑路 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a href="https://www.luogu.com.cn/problem/P1613">P1613 跑路 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h3><h4 id="状态和集合划分-3"><a href="#状态和集合划分-3" class="headerlink" title="状态和集合划分"></a>状态和集合划分</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;g[<span class="number">100</span>];</span><br><span class="line"><span class="comment">//floyd算法+倍增+dp（Floyd本身就是图上暴力dp的一种</span></span><br><span class="line"><span class="comment">//第三维记载二进制 </span></span><br><span class="line"><span class="type">int</span> dis[<span class="number">100</span>][<span class="number">100</span>][<span class="number">100</span>];<span class="comment">//初始化dp数组使用 </span></span><br><span class="line"><span class="type">int</span> dp[<span class="number">100</span>][<span class="number">100</span>];<span class="comment">//答案数组 </span></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n,m;cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="comment">//输入 </span></span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f3f3f3f</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line"><span class="type">int</span> u,v;cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">dis[u][v][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">dis[v][u][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">dp[u][v]=<span class="number">1</span>;<span class="comment">//这里需要初始化，本身一步就可达 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化dp数组 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">64</span>;++k)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=n;++t)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[i][t][k<span class="number">-1</span>]==<span class="number">1</span>&amp;&amp;dis[t][j][k<span class="number">-1</span>]==<span class="number">1</span>)</span><br><span class="line">dis[i][j][k]=<span class="number">1</span>,dp[i][j]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Floyd算法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=n;++t)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">dp[i][j]=<span class="built_in">min</span>(dp[i][t]+dp[t][j],dp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;dp[<span class="number">1</span>][n]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="状压dp（未完"><a href="#状压dp（未完" class="headerlink" title="状压dp（未完"></a>状压dp（未完</h2><p>最主要的在于二进制枚举子集，在于对状态的枚举和筛选</p><h3 id="类型1：棋盘上的状压dp，"><a href="#类型1：棋盘上的状压dp，" class="headerlink" title="类型1：棋盘上的状压dp，"></a>类型1：棋盘上的状压dp，</h3><p>1）暴力列的所有状态，选择合适的状态（同行间的限制</p><p>2）暴力所有状态的组合，记录不同行间的限制</p><p>3）注意位置的限制，之后进行状态的转移</p><h3 id="类型2：覆盖问题"><a href="#类型2：覆盖问题" class="headerlink" title="类型2：覆盖问题"></a>类型2：覆盖问题</h3><h3 id="小国王（类型1"><a href="#小国王（类型1" class="headerlink" title="小国王（类型1"></a>小国王（类型1</h3><p><a href="https://www.acwing.com/problem/content/1066/">1064. 小国王 - AcWing题库</a></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>注意check函数–同行间的限制</p><p>注意count–行状态的1的个数</p><p>注意状态的转移</p><h4 id="代码：-4"><a href="#代码：-4" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cnt[<span class="number">1200</span>];</span><br><span class="line"><span class="type">int</span> id[<span class="number">1200</span>];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;head[<span class="number">2000</span>];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;state;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//格子不能相邻</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">12</span>;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(((x&gt;&gt;i)&amp;<span class="number">1</span>)&amp;&amp;((x&gt;&gt;(i+<span class="number">1</span>))&amp;<span class="number">1</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">12</span>;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>((x&gt;&gt;i)&amp;<span class="number">1</span>)res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">12</span>][<span class="number">2000</span>][<span class="number">2000</span>];<span class="comment">//第几行多少个国王并且状态是什么。</span></span><br><span class="line"><span class="comment">//一种是按行设变量，一种是按属性类去设变量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,k;cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="comment">//n*n放k个精确覆盖</span></span><br><span class="line">    <span class="comment">//棋盘类型的dp</span></span><br><span class="line">    <span class="comment">//预处理需要暴力的数组,二进制暴力</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(i))&#123;</span><br><span class="line">            state.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">            cnt[i]=<span class="built_in">count</span>(i);</span><br><span class="line">            <span class="comment">// id[i]=state.size()-1;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//暴力i，j选择合适</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">0</span>;i&lt;state.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;state.<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">            <span class="type">int</span> ii=state[i],jj=state[j];</span><br><span class="line">            <span class="keyword">if</span>((ii&amp;jj)==<span class="number">0</span>&amp;&amp;(<span class="built_in">check</span>(ii|jj)))</span><br><span class="line">                <span class="comment">//反了</span></span><br><span class="line">            head[i].<span class="built_in">emplace_back</span>(j);<span class="comment">//说明i可以由j迁移过来,一个i可以由多少个j迁移过来</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;++i)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> kk=<span class="number">0</span>;kk&lt;=k;++kk)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;state.<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">            <span class="comment">//暴力可以到达的所有状态</span></span><br><span class="line">            <span class="comment">// int now=state[j];</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> jj:head[j])&#123;</span><br><span class="line">                <span class="comment">//这里记录的是下标</span></span><br><span class="line">                <span class="comment">//jj和j都只是状态的下标</span></span><br><span class="line">                <span class="type">int</span> c=cnt[state[j]];</span><br><span class="line">                <span class="comment">// cout&lt;&lt;state[j]&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">                <span class="keyword">if</span>(kk&gt;=c)&#123;</span><br><span class="line">                    dp[i][kk][j]+=dp[i<span class="number">-1</span>][kk-c][jj];</span><br><span class="line">                    <span class="comment">// cout&lt;&lt;dp[i][kk][j]&lt;&lt;&#x27; &#x27;; </span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[n+<span class="number">1</span>][k][<span class="number">0</span>]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="炮兵阵地（类型1"><a href="#炮兵阵地（类型1" class="headerlink" title="炮兵阵地（类型1"></a>炮兵阵地（类型1</h3><p><a href="https://www.acwing.com/problem/content/294/">292. 炮兵阵地 - AcWing题库</a></p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>注意check函数–同行间的限制，当前格的右边和右右边都不可以有</p><p>注意count–行状态的1的个数，对应状态的1的个数</p><p>注意状态的转移–dp[2] [pre] [now],now当前行对应状态的下标，pre是上一行对应状态的下标</p><p>注意w【】用于记录不可以放置大炮的位置，所有操作都是通过位运算进行的。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c[<span class="number">120</span>][<span class="number">12</span>];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;state;</span><br><span class="line"><span class="type">int</span> cnt[<span class="number">2000</span>];</span><br><span class="line"><span class="type">int</span> w[<span class="number">120</span>];<span class="comment">//记录当前行的状态，山地在哪一行里有没有</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> state)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">12</span>;++i)&#123;</span><br><span class="line">        <span class="comment">//当前的右边两个都是不可行的,错了</span></span><br><span class="line">        <span class="keyword">if</span> ((state &gt;&gt; i &amp; <span class="number">1</span>) &amp;&amp; ((state &gt;&gt; i + <span class="number">1</span> &amp; <span class="number">1</span>) || (state &gt;&gt; i + <span class="number">2</span> &amp; <span class="number">1</span>)))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// if((x&gt;&gt;i&amp;1)&amp;&amp;((x+1&gt;&gt;i&amp;1)||(x+2&gt;&gt;i&amp;1)))&#123;</span></span><br><span class="line">    <span class="comment">//         return 0;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">12</span>;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>((x&gt;&gt;i)&amp;<span class="number">1</span>)res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">2</span>][<span class="number">2000</span>][<span class="number">2000</span>];</span><br><span class="line"><span class="comment">//所有的有和没有都会采用二进制优化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//需要处理上两行右三列，合理位置处理答案数组</span></span><br><span class="line">    <span class="type">int</span> n,m;cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;++j)&#123;</span><br><span class="line">            cin&gt;&gt;c[i][j];</span><br><span class="line">            <span class="keyword">if</span>(c[i][j]==<span class="string">&#x27;H&#x27;</span>)w[i]|=<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;m);++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(i))&#123;<span class="comment">//筛选合适的子集，并进行子集划分</span></span><br><span class="line">            state.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">            cnt[i]=<span class="built_in">count</span>(i);</span><br><span class="line">            <span class="comment">// cout&lt;&lt;i&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// dp[0][0][0]=1;</span></span><br><span class="line">    <span class="comment">//数组更新的下标是state的位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> id=<span class="number">1</span>;id&lt;=n;++id)<span class="comment">//第几行</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;state.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;state.<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;state.<span class="built_in">size</span>();++k)&#123;</span><br><span class="line">                <span class="type">int</span> a=state[j],b=state[i],c=state[k];</span><br><span class="line">                <span class="comment">// cout&lt;&lt;w[id]&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">                <span class="keyword">if</span>((w[id]&amp;a)||(w[id<span class="number">-1</span>]&amp;b))<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>((a&amp;b)||(b&amp;c)||(a&amp;c))<span class="keyword">continue</span>;</span><br><span class="line">                    <span class="comment">//采用滚动数组进行优化，第一维是滚动数组，第二维是上一行的状态，第三维是当前行的状态</span></span><br><span class="line">                    dp[id&amp;<span class="number">1</span>][i][j]=<span class="built_in">max</span>(dp[id&amp;<span class="number">1</span>][i][j],dp[id<span class="number">-1</span>&amp;<span class="number">1</span>][k][i]+cnt[a]);</span><br><span class="line">                    <span class="comment">// cout&lt;&lt;a&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// for(int i=0;i&lt;=1;++i)&#123;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;state.<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> z=<span class="number">0</span>;z&lt;state.<span class="built_in">size</span>();++z)&#123;</span><br><span class="line">                ans=<span class="built_in">max</span>(ans,dp[n&amp;<span class="number">1</span>][j][z]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="愤怒的小鸟"><a href="#愤怒的小鸟" class="headerlink" title="愤怒的小鸟"></a>愤怒的小鸟</h3><p><a href="https://www.acwing.com/problem/content/526/">524. 愤怒的小鸟 - AcWing题库</a></p><h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><h4 id="代码：-5"><a href="#代码：-5" class="headerlink" title="代码："></a>代码：</h4><h2 id="数位dp"><a href="#数位dp" class="headerlink" title="数位dp"></a>数位dp</h2><p><a href="https://zhuanlan.zhihu.com/p/613107701">算法学习笔记(22)：数位DP（数位动态规划） - 知乎 (zhihu.com)</a></p><p>前缀和的思想很重要，一般涉及的是对于每一个数位的限制。</p><h3 id="板子-2"><a href="#板子-2" class="headerlink" title="板子"></a>板子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">ll dp[<span class="number">20</span>][<span class="number">70</span>][<span class="number">2000</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">ll a[<span class="number">100</span>];</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(ll b<span class="comment">/*进制*/</span>,ll len<span class="comment">/*当前枚举第几位*/</span>,<span class="type">int</span> f<span class="comment">/*是否有前导零*/</span>,ll state<span class="comment">/*对应二进制为各数字状态*/</span>,<span class="type">int</span> limit<span class="comment">/*是否处在边界*/</span>)</span></span>&#123;</span><br><span class="line">ll res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(!len)&#123;</span><br><span class="line"><span class="keyword">return</span> !state;<span class="comment">//各位置都为0,则表示各位置都取了偶数次 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dp[b][len][state][f][limit]!=<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> dp[b][len][state][f][limit];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> top=b<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(limit)&#123;</span><br><span class="line">top=a[len];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=top;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;f)&#123;</span><br><span class="line">res+=<span class="built_in">dfs</span>(b,len<span class="number">-1</span>,<span class="number">1</span>,state,limit&amp;&amp;(i==top));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">res+=<span class="built_in">dfs</span>(b,len<span class="number">-1</span>,<span class="number">0</span>,state^(<span class="number">1</span>&lt;&lt;i),limit&amp;&amp;(i==top));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dp[b][len][state][f][limit]=res;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">cal</span><span class="params">(ll b,ll d)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(d)&#123;</span><br><span class="line">a[++res]=d%b;</span><br><span class="line">d/=b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">dfs</span>(b,res,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*cout&lt;&lt;setiosflags(ios::fixed)&lt;&lt;setprecision(8)&lt;&lt;ans&lt;&lt;endl;//输出ans（float）格式控制为8位小数（不含整数部分）*/</span></span><br><span class="line"><span class="comment">/*cout&lt;&lt;setprecision(8)&lt;&lt;ans&lt;&lt;endl;//输出ans（float）格式控制为8位小数（含整数部分）*/</span></span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);<span class="comment">//同步流</span></span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line">ll b,l,r;</span><br><span class="line">cin&gt;&gt;b&gt;&gt;l&gt;&gt;r;</span><br><span class="line">cout&lt;&lt;<span class="built_in">cal</span>(b,r)-<span class="built_in">cal</span>(b,l<span class="number">-1</span>)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//题目链接：https://codeforces.com/contest/855/problem/E</span></span><br><span class="line"><span class="comment">//（代码参考:）  https://blog.csdn.net/jk211766/article/details/81474632</span></span><br><span class="line"><span class="comment">//(过程讲解参考:)   https://www.cnblogs.com/young-children/articles/11351588.html</span></span><br></pre></td></tr></table></figure><h3 id="一、C-Unlucky-Numbers"><a href="#一、C-Unlucky-Numbers" class="headerlink" title="一、C. Unlucky Numbers"></a>一、C. Unlucky Numbers</h3><p><a href="https://codeforces.com/contest/1808/problem/C">Problem - C - Codeforces</a></p><h4 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h4><p>有的地方可能炸掉了，但是开成ull就可以了</p><p>这个题，枚举暴力每位最大和最小的差值，然后dfs（其实是暴力），之后枚举每位下界，每一位，从上界到下界开是否可行，找到可行的最大数，此时符合条件即可，</p><p>其实就是对于每一位进行有限制的暴力</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//每一位的变化左界</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> nl=<span class="number">0</span>;nl&lt;=<span class="number">9</span>;++nl)&#123;</span><br><span class="line">        <span class="comment">//对于每一位进行枚举暴力</span></span><br><span class="line">        <span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;++i)&#123;</span><br><span class="line">            <span class="type">int</span> nr=<span class="built_in">min</span>((<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> )<span class="number">9</span>,de+nl);</span><br><span class="line">            <span class="comment">//枚举可行的所有情况</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=nr;k&gt;=nl;--k)&#123;</span><br><span class="line">                <span class="type">int</span> las=now*<span class="number">10</span>+k;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=len;++j)&#123;</span><br><span class="line">                    las=las*<span class="number">10</span>+nl;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(las&lt;=r)&#123;</span><br><span class="line">                    now=now*<span class="number">10</span>+k;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,now);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="二、E-Living-Sequence"><a href="#二、E-Living-Sequence" class="headerlink" title="二、E. Living Sequence"></a>二、E. Living Sequence</h3><p><a href="https://codeforces.com/contest/1811/problem/E">Problem - E - Codeforces</a></p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路:"></a>思路:</h4><p>在数位上的题，应该都可以用dp。dp本身就是一种思想。</p><p>二分找到合适的位置，然后进行数位dp，dp[i]表示当前位数符合条件的答案，</p><p>limt表示前一位是否达到上限，注意边界和暴力搜索</p><p>还有种想法–9进制，因为缺1位，所以转化成9进制，取余 ，然后判断是否小于4，不是就加1，因为缺一个4位</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    <span class="comment">//10个数少一个数，因此可以转化成9进制，循环叠加</span></span><br><span class="line">    string s=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        s+=<span class="built_in">char</span>(<span class="string">&#x27;0&#x27;</span>+((n%<span class="number">9</span>)&lt;<span class="number">4</span>?(n%<span class="number">9</span>):(n%<span class="number">9</span>)+<span class="number">1</span>));</span><br><span class="line">        n/=<span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h2 id="换根dp"><a href="#换根dp" class="headerlink" title="换根dp"></a>换根dp</h2><p><a href="https://zhuanlan.zhihu.com/p/348349531">【朝夕的ACM笔记】动态规划-换根DP - 知乎 (zhihu.com)</a></p><ul><li>其相比于一般的树形DP具有以下特点：</li></ul><p>1，以树上的不同点作为根，其解不同。</p><p>2，故为求解答案，不能单求某点的信息，需要求解每个节点的信息。</p><p>3，故无法通过一次搜索完成答案的求解，因为一次搜索只能得到一个节点的答案。</p><ul><li>换根DP的一般套路：</li></ul><p>1，指定某个节点为根节点。</p><p>2，第一次搜索完成预处理（如子树大小等），同时得到该节点的解。</p><p>3，第二次搜索进行换根的动态规划，由已知解的节点推出相连节点的解。</p><h3 id="一、Problem-D-Codeforces"><a href="#一、Problem-D-Codeforces" class="headerlink" title="一、Problem - D - Codeforces"></a>一、<a href="https://codeforces.com/contest/1805/problem/D">Problem - D - Codeforces</a></h3><h4 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h4><p>题意：边长至少为k的联通块的个数</p><p>策略：换根dp，每个节点更新到其它点的最长距离</p><p>这个问题：</p><p>首先更新一个点的最长，回溯更新now</p><p>其次更新其他点，深搜更新v</p><h4 id="代码：-6"><a href="#代码：-6" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//换根dp，比较板子</span><br><span class="line">//题意边长至少为k的联通块的个数</span><br><span class="line">void dfs1(int now,int fa)&#123;//从1开始的最远距离</span><br><span class="line">    for(auto v:g[now])&#123;</span><br><span class="line">        if(v==fa)continue;</span><br><span class="line">        dfs1(v,now);</span><br><span class="line">        int no=dp1[v]+1;</span><br><span class="line">        //更新最大距离和次大距离，回溯更新当前点</span><br><span class="line">        if(no&gt;dp1[now])&#123;</span><br><span class="line">            dp2[now]=dp1[now];</span><br><span class="line">            dp1[now]=no;</span><br><span class="line">        &#125;else if(no&gt;dp2[now])&#123;</span><br><span class="line">            dp2[now]=no;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void dfs2(int now,int fa)&#123;</span><br><span class="line">    dis[now]=dp1[now];</span><br><span class="line">    for(auto v:g[now])&#123;</span><br><span class="line">        if(v==fa)continue;</span><br><span class="line">        //更新每个点的最大，这里有个树的直径，任一点最远距离的一个端点一定是直径的一端</span><br><span class="line">        if(dp1[now]!=dp1[v]+1)&#123;//更新最大，这里指v没有在now到直径端点的路径上</span><br><span class="line">            dp2[v]=dp1[v];</span><br><span class="line">            dp1[v]=dp1[now]+1;//到直径的距离</span><br><span class="line">        &#125;else&#123;//更新相对于now次大的路径,这时v在now到直径端点上</span><br><span class="line">            if(dp2[now]+1&gt;dp1[v])&#123;</span><br><span class="line">                dp2[v]=dp1[v];</span><br><span class="line">                dp1[v]=dp2[now]+1;</span><br><span class="line">            &#125;else if(dp2[now]+1&gt;dp2[v])&#123;</span><br><span class="line">                dp2[v]=dp2[now]+1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs2(v,now);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树上dp"><a href="#树上dp" class="headerlink" title="树上dp"></a>树上dp</h2><p>第一维通常是节点编号，一般先递归在它的每个子节点上进行dp，在回溯时，从子节点向节点x进行状态转移，</p><p><a href="https://www.cnblogs.com/Wednesday-zfz/p/12209729.html">树形DP 学习笔记 - zfz04 - 博客园 (cnblogs.com)</a></p><p>题单：<a href="https://www.luogu.com.cn/training/13994">0x2 树形dp - 题单 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p>有时树上节点物品数量的统计很重要</p><h3 id="一、节点类"><a href="#一、节点类" class="headerlink" title="一、节点类"></a>一、节点类</h3><p><a href="https://www.luogu.com.cn/problem/P1352">P1352 没有上司的舞会 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化的位置</span></span><br><span class="line">    dp[now][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    dp[now][<span class="number">1</span>]=r[now];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:g[now])&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(i,now);</span><br><span class="line">        <span class="comment">//回溯更新所有节点</span></span><br><span class="line">        dp[now][<span class="number">0</span>]+=<span class="built_in">max</span>(dp[i][<span class="number">0</span>],dp[i][<span class="number">1</span>]);<span class="comment">//当前节点不要</span></span><br><span class="line">        dp[now][<span class="number">1</span>]+=dp[i][<span class="number">0</span>];<span class="comment">//当前节点要</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、背包类"><a href="#二、背包类" class="headerlink" title="二、背包类"></a>二、背包类</h3><h4 id="2-1"><a href="#2-1" class="headerlink" title="2.1"></a>2.1</h4><p>[P2014 <a href="https://www.luogu.com.cn/problem/P2014">CTSC1997] 选课 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p>也可以是分组背包：最大容量，每组最多只要一个–分组背包或许更具一般性，可能是树形很适合孩子当成组，回溯选择最优二重循环这种结构了吧</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//背包树形dp，判断容量，在树上进行选与不选</span></span><br><span class="line"><span class="type">int</span> dp[<span class="number">440</span>][<span class="number">440</span>];<span class="comment">//当前节点,容量为j</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化的位置</span></span><br><span class="line">    <span class="comment">// dp[now][m]=1;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:g[now])&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(i,now);</span><br><span class="line">        <span class="comment">//转移的位置，m+1的原因是：0不应该要，但是为了将森林变成树，却要了，多了个状态</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> ii=m+<span class="number">1</span>;ii&gt;=<span class="number">1</span>;--ii)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;ii;++k)&#123;</span><br><span class="line">                dp[now][ii]=<span class="built_in">max</span>(dp[now][ii],dp[i][k]+dp[now][ii-k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2"><a href="#2-2" class="headerlink" title="2.2"></a>2.2</h4><p><a href="https://www.luogu.com.cn/problem/P1273">P1273 有线电视网 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p>分组背包</p><p>首先，状态和状态的转移</p><p>其次，初始化、预处理以及边界的处理</p><p>最后，在于答案的寻找</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;pii&gt;g[<span class="number">3400</span>];</span><br><span class="line"><span class="comment">//背包树形dp，判断容量，在树上进行选与不选,集合的划分</span></span><br><span class="line"><span class="type">int</span> dp[<span class="number">3400</span>][<span class="number">3400</span>];<span class="comment">//节点 当前节点多少用户  花费  换一下维度，题可能简单很多</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[<span class="number">3400</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化的位置</span></span><br><span class="line">    <span class="keyword">if</span>(now&gt;n-m)&#123;<span class="comment">//终端用户</span></span><br><span class="line">        dp[now][<span class="number">1</span>]=a[now];</span><br><span class="line">        <span class="comment">// cout&lt;&lt;dp[now][1]&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:g[now])&#123;</span><br><span class="line">        <span class="keyword">if</span>(i.first==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> t=<span class="built_in">dfs</span>(i.first,now);sum+=t;<span class="comment">//sum记录该点用户数量</span></span><br><span class="line">        <span class="comment">//转移的位置,类似分组背包，暴力所有节点选择与不选择的情况</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> ii=sum;ii&gt;=<span class="number">1</span>;--ii)&#123;<span class="comment">//01背包</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=t;++j)&#123;<span class="comment">//分组背包</span></span><br><span class="line">                <span class="keyword">if</span>(ii&gt;=j)dp[now][ii]=<span class="built_in">max</span>(dp[now][ii],dp[now][ii-j]+dp[i.first][j]-i.second);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//之所以是树，有前后关系</span></span><br><span class="line">    <span class="comment">//之所以是背包，有选不选的问题</span></span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="comment">//dp初始化，很重要，要不然选择时，负的都比0小，所以无法记录负的</span></span><br><span class="line">    <span class="built_in">memset</span>(dp,~<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)dp[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n-m;++i)&#123;</span><br><span class="line">        <span class="type">int</span> k;cin&gt;&gt;k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=k;++j)&#123;</span><br><span class="line">            <span class="type">int</span> a,c;</span><br><span class="line">            cin&gt;&gt;a&gt;&gt;c;</span><br><span class="line">            g[i].<span class="built_in">emplace_back</span>(a,c);</span><br><span class="line">            g[a].<span class="built_in">emplace_back</span>(i,c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n-m+<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=m;i&gt;=<span class="number">1</span>;--i)&#123;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;dp[1][i]&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">        <span class="keyword">if</span>(dp[<span class="number">1</span>][i]&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;i&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、扫描（换根dp"><a href="#三、扫描（换根dp" class="headerlink" title="三、扫描（换根dp"></a>三、扫描（换根dp</h3><p>特点：给定一个树形结构，，需要以每个节点为根进行一系列统计。</p><p>换根dp一般采用二次扫描来求解</p><p>1，第一次扫描时，任选一个节点为根，在有根树上执行一次树形dp，也就是在回溯时发生的、自底向上的状态转移</p><p>2，第二次扫描时，从刚才选出的根出发，对整棵树执行一次深度优先遍历，在每次递归前进行自顶向下的推导，计算出“换根”后的解。</p><h4 id="3-1"><a href="#3-1" class="headerlink" title="3.1"></a>3.1</h4><p>[P2986 <a href="https://www.luogu.com.cn/problem/P2986">USACO10MAR] Great Cow Gathering G - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p>换根的时候，要充分考虑原来的样子以及换根后的影响，考虑第一次扫描的情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">//关注怎么处理距离</span><br><span class="line">//第一次是有根树,注意统计子树的数量</span><br><span class="line">int dfs1(int now,int fa)&#123;</span><br><span class="line">    int tot=0;</span><br><span class="line">    for(auto i:g[now])&#123;</span><br><span class="line">        int v=i.first,w=i.second;</span><br><span class="line">        if(v==fa)continue;</span><br><span class="line">        int s=dfs1(v,now);</span><br><span class="line">        tot+=s;</span><br><span class="line">        //儿子节点的累加，每个儿子</span><br><span class="line">        f1[now]+=s*w+f1[v];</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt[now]=tot+c[now];//记录当前树的牛的数量</span><br><span class="line">&#125;</span><br><span class="line">//第二次需要画图，找变化,儿子节点=旧的儿子节点-从父亲节点退回+从父亲节点进入儿子节点</span><br><span class="line">void dfs2(int now,int fa)&#123;</span><br><span class="line">    for(auto i:g[now])&#123;</span><br><span class="line">        int v=i.first,w=i.second;</span><br><span class="line">        if(v==fa)continue;</span><br><span class="line">        //从now转移 , 水流没有孩子数量的问题,这个假设都先到1号节点，然后进行转移，所以没有旧的数组</span><br><span class="line">        f2[v]=f2[now]-cnt[v]*w+(sum-cnt[v])*w;</span><br><span class="line">        dfs2(v,now);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void solve()</span><br><span class="line">&#123;</span><br><span class="line">    //不确定根，有最优的选择，无法贪心--换根dp</span><br><span class="line">    int n;cin&gt;&gt;n;</span><br><span class="line">    for(int i=1;i&lt;=n;++i)&#123;</span><br><span class="line">        cin&gt;&gt;c[i];</span><br><span class="line">        sum+=c[i];//sum求错了，NM</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1,u,v,w;i&lt;n;++i)&#123;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">        // sum+=w;</span><br><span class="line">        g[u].emplace_back(v,w);</span><br><span class="line">        g[v].emplace_back(u,w);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs1(1,0);</span><br><span class="line">    // f2[1]=f1[1];</span><br><span class="line">    dfs2(1,0);</span><br><span class="line">    int mn=inf;</span><br><span class="line">    for(int i=1;i&lt;=n;++i)&#123;</span><br><span class="line">        if(f2[i]&lt;mn)&#123;</span><br><span class="line">            mn=f2[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //补充起始数组大小</span><br><span class="line">    cout&lt;&lt;mn+f1[1]&lt;&lt;&#x27;\n&#x27;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2有点难，多做一下"><a href="#3-2有点难，多做一下" class="headerlink" title="3.2有点难，多做一下"></a>3.2有点难，多做一下</h4><p><a href="https://codeforces.com/problemset/problem/708/C">Problem - 708C - Codeforces</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不是重心但是可以是重心--有且只有一个节点尺寸》=n/2，让这个节点的尺寸《=n/2字树接到根上，使之符合条件</span></span><br><span class="line"><span class="comment">//因此，转移的时候就是在找是否存在这么个子树的子树，使之成为重心</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;g[maxj];</span><br><span class="line"><span class="type">int</span> ans[maxj];</span><br><span class="line"><span class="type">int</span> f1[maxj][<span class="number">3</span>]; <span class="comment">//节点 0表示第一大 1表示第二大  准确的说是子树的最大尺寸</span></span><br><span class="line"><span class="type">int</span> f2[maxj];    <span class="comment">//换根后子树的最大情况</span></span><br><span class="line"><span class="type">int</span> maxsiz[maxj];</span><br><span class="line"><span class="type">int</span> siz[maxj];</span><br><span class="line"><span class="type">int</span> las[maxj];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    siz[now]=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// maxsiz[now]=1;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:g[now])&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(i,now);</span><br><span class="line">        <span class="comment">//回溯转移</span></span><br><span class="line">        siz[now]+=siz[i];</span><br><span class="line">        <span class="type">int</span> v;</span><br><span class="line">        <span class="comment">//更新最大子树</span></span><br><span class="line">        <span class="keyword">if</span>(siz[i]&gt;siz[maxsiz[now]])maxsiz[now]=i;</span><br><span class="line">        <span class="comment">//更新可行的最大尺寸</span></span><br><span class="line">        <span class="keyword">if</span>(siz[i]&lt;=n/<span class="number">2</span>)v=siz[i];</span><br><span class="line">        <span class="keyword">else</span> v=f1[i][<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//更新最大和最小</span></span><br><span class="line">        <span class="keyword">if</span>(v&gt;f1[now][<span class="number">0</span>])&#123;</span><br><span class="line">            f1[now][<span class="number">1</span>]=f1[now][<span class="number">0</span>];</span><br><span class="line">            f1[now][<span class="number">0</span>]=v;</span><br><span class="line">            las[now]=i;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(v&gt;f1[now][<span class="number">1</span>])f1[now][<span class="number">1</span>]=v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    ans[now]=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//if判断的是不行的情况，然后改变看行不行</span></span><br><span class="line">    <span class="keyword">if</span>(siz[maxsiz[now]]&gt;n/<span class="number">2</span>)ans[now]=(siz[maxsiz[now]]-f1[maxsiz[now]][<span class="number">0</span>]&lt;=n/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n-siz[now]&gt;n/<span class="number">2</span>)ans[now]=(n-siz[now]-f2[now]&lt;=n/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:g[now])&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//递归换根</span></span><br><span class="line">        <span class="type">int</span> v;</span><br><span class="line">        <span class="comment">//一直在找不合适的情况</span></span><br><span class="line">        <span class="keyword">if</span>(n-siz[now]&gt;n/<span class="number">2</span>)v=f2[now];</span><br><span class="line">        <span class="keyword">else</span> v=n-siz[now];<span class="comment">//记录可能是重心的情况</span></span><br><span class="line">        f2[i]=<span class="built_in">max</span>(f2[i],v);</span><br><span class="line">        <span class="comment">//记载相应子树的子树的最大，然后为剪枝做准备</span></span><br><span class="line">        <span class="keyword">if</span>(las[now]==i)&#123;</span><br><span class="line">            f2[i]=<span class="built_in">max</span>(f2[i],f1[now][<span class="number">1</span>]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            f2[i]=<span class="built_in">max</span>(f2[i],f1[now][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs2</span>(i,now);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DDP动态动态规划"><a href="#DDP动态动态规划" class="headerlink" title="DDP动态动态规划"></a>DDP动态动态规划</h2><p>动态规划维护的部分数据是变化的</p><h3 id="一、Problem-E-Codeforces"><a href="#一、Problem-E-Codeforces" class="headerlink" title="一、Problem - E - Codeforces"></a>一、<a href="https://codeforces.com/contest/1814/problem/E">Problem - E - Codeforces</a></h3><p>题解参考：</p><p><a href="https://zhuanlan.zhihu.com/p/620545656">Educational Codeforces Round 146 (Rated for Div. 2) ABCE - 知乎 (zhihu.com)</a></p><p>参考知识：</p><p><a href="https://blog.csdn.net/SSL_hzb/article/details/99360804">【数据结构 数学 线段树 矩阵乘法 动态dp】SP1716 GSS3 Can you answer these queries III_动态dp sp1716_nymph181的博客-CSDN博客</a></p><h4 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h4><p>本身dp，但是一直在维护询问，所以需要动态dp，</p><p>线段树上dp，普通的正解是什么，dp转移的策略是什么</p><p> 动态动态规划&#x3D;矩阵乘法+dp转移+线段树（二叉树）</p><h4 id="矩阵乘法-dp转移板子："><a href="#矩阵乘法-dp转移板子：" class="headerlink" title="矩阵乘法+dp转移板子："></a>矩阵乘法+dp转移板子：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Mat</span> &#123;</span><br><span class="line">    LL a[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    Mat <span class="keyword">operator</span>*(<span class="type">const</span> Mat&amp; T) <span class="type">const</span> &#123;</span><br><span class="line">        Mat res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">                res.a[i][j] = INF;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; k++) &#123;</span><br><span class="line">                    res.a[i][j] = <span class="built_in">min</span>(res.a[i][j], a[i][k] + T.a[k][j]);<span class="comment">//res是答案，a是当前，T是对象</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="单调队列优化dp"><a href="#单调队列优化dp" class="headerlink" title="单调队列优化dp"></a>单调队列优化dp</h2><h3 id="知识："><a href="#知识：" class="headerlink" title="知识："></a>知识：</h3><p>维护区间长度&lt;&#x3D;m的最值，</p><p>有几个要素很重要：</p><p>1，适用：维护区间长度不大于m的最值</p><p>2，结合：dp转移方程，前缀和，二分，二维</p><p>3，注意：hh变化的条件和题意有关，对谁的单调区间（也就是谁和谁的比较使得tt–</p><h3 id="滑动窗口的板子："><a href="#滑动窗口的板子：" class="headerlink" title="滑动窗口的板子："></a>滑动窗口的板子：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define int long long</span><br><span class="line">const int N=1e6+100;</span><br><span class="line">int a[N],q[N];</span><br><span class="line">signed main()&#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    scanf(&quot;%lld %lld&quot;,&amp;n,&amp;m);</span><br><span class="line">    for(int i=1;i&lt;=n;++i)scanf(&quot;%lld&quot;,&amp;a[i]);</span><br><span class="line">    //模拟队列</span><br><span class="line">    int hh=0,tt=-1;</span><br><span class="line">    //先说最小</span><br><span class="line">    for(int i=1;i&lt;=n;++i)&#123;</span><br><span class="line">        if(hh&lt;=tt&amp;&amp;q[hh]&lt;=i-m)hh++;</span><br><span class="line">        while(hh&lt;=tt&amp;&amp;a[q[tt]]&gt;=a[i])tt--;</span><br><span class="line">        q[++tt]=i;</span><br><span class="line">        if(i&gt;=m)printf(&quot;%lld &quot;,a[q[hh]]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;&#x27;\n&#x27;;</span><br><span class="line">    //再说最大</span><br><span class="line">    hh=0,tt=-1;</span><br><span class="line">    for(int i=1;i&lt;=n;++i)&#123;</span><br><span class="line">        if(hh&lt;=tt&amp;&amp;q[hh]&lt;=i-m)hh++;</span><br><span class="line">        while(hh&lt;=tt&amp;&amp;a[q[tt]]&lt;=a[i])tt--;</span><br><span class="line">        q[++tt]=i;</span><br><span class="line">        if(i&gt;=m)printf(&quot;%lld &quot;,a[q[hh]]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;&#x27;\n&#x27;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一、前缀和-单调队列优化dp"><a href="#一、前缀和-单调队列优化dp" class="headerlink" title="一、前缀和+单调队列优化dp"></a>一、前缀和+单调队列优化dp</h3><p><a href="https://www.acwing.com/problem/content/description/137/">135. 最大子序和 - AcWing题库</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">连续子序列，即子串</span><br><span class="line">前缀和+单调队列优化</span><br><span class="line">dp代表最后位置的值，转移方程</span><br><span class="line">s[i]-min(s[j]) s[j]是距离不超过m范围的最小值，然后整体最大</span><br><span class="line">*/</span><br><span class="line">signed main()&#123;</span><br><span class="line">    ios::sync_with_stdio(0);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line">    int n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=1;i&lt;=n;++i)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        s[i]=s[i-1]+a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    int hh=0,tt=0;</span><br><span class="line">    int ans=-1e18;</span><br><span class="line">    //以最后的位置为终点，维护长度为m的最大值,</span><br><span class="line">    for(int i=1;i&lt;=n;++i)&#123;</span><br><span class="line">        //前缀和是l-1</span><br><span class="line">        if(hh&lt;=tt&amp;&amp;q[hh]&lt;i-m)hh++;</span><br><span class="line">        ans=max(ans,s[i]-s[q[hh]]);</span><br><span class="line">        while(hh&lt;=tt&amp;&amp;s[q[tt]]&gt;=s[i])tt--;</span><br><span class="line">        q[++tt]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;&#x27;\n&#x27;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、二分-单调队列优化dp"><a href="#二、二分-单调队列优化dp" class="headerlink" title="二、二分+单调队列优化dp"></a>二、二分+单调队列优化dp</h3><p><a href="https://www.acwing.com/problem/content/1092/">1090. 绿色通道 - AcWing题库</a></p><p>二分的本质在于区间单调，一半区间满足一般区间不满足</p><p>错的七零八落的，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"></span><br><span class="line">题意：在连续代价不大于t的前提下，中间消耗最小</span><br><span class="line">策略：</span><br><span class="line">二分中间消耗时间(答案)，观察t是否可以满足</span><br><span class="line">最长的最小也在提示二分答案</span><br><span class="line"></span><br><span class="line">单调队列维护的区间长度往往是不大于某个值</span><br><span class="line">dp数组维护要当前位的代价和之前不得不要的最小代价</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line">bool check(int mid)&#123;</span><br><span class="line">    for(int i=0;i&lt;=n+1;++i)dp[i]=0;</span><br><span class="line">    int hh=0,tt=0;</span><br><span class="line">    //应该是维护区间最小值，求和不大于t</span><br><span class="line">    for(int i=1;i&lt;=n;++i)&#123;</span><br><span class="line">        //小于临界,m个空，所以是m+1的最小值</span><br><span class="line">        while(hh&lt;=tt&amp;&amp;q[hh]&lt;i-mid-1)hh++;</span><br><span class="line">        //dp值维护累加选择的最小值</span><br><span class="line">        dp[i]=dp[q[hh]]+a[i];</span><br><span class="line">        //维护dp区间必用最小值</span><br><span class="line">        while(hh&lt;=tt&amp;&amp;dp[q[tt]]&gt;=dp[i])tt--;</span><br><span class="line">        q[++tt]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    //空的区间不能大于m</span><br><span class="line">    if(q[hh]&lt;n-mid)hh++;</span><br><span class="line">    return dp[q[hh]]&lt;=t;</span><br><span class="line">&#125;</span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;t;</span><br><span class="line">    for(int i=1;i&lt;=n;++i)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    int l=0,r=n;</span><br><span class="line">    int ans=0;</span><br><span class="line">    while(l&lt;=r)&#123;</span><br><span class="line">        int mid=l+r&gt;&gt;1;</span><br><span class="line">        if(check(mid))&#123;</span><br><span class="line">            ans=mid;</span><br><span class="line">            r=mid-1;</span><br><span class="line">        &#125;else l=mid+1;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;&#x27;\n&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、二维单调队列优化"><a href="#三、二维单调队列优化" class="headerlink" title="三、二维单调队列优化"></a>三、二维单调队列优化</h3><p><a href="https://www.acwing.com/problem/content/description/1093/">1091. 理想的正方形 - AcWing题库</a></p><p>先进行 行 间单调队列优化， 然后进行 列 间单调队列优化</p><p>tt–那里卡了半天，妈的，你不应该用队尾进行比较吗</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">二维单调队列优化</span><br><span class="line">先进行行间最值的选择</span><br><span class="line">后进行列间最值的选择</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line">// 原数组 给谁 大小</span><br><span class="line">void getmax(int a[],int b[],int cnt)&#123;</span><br><span class="line">    int hh=0,tt=0;</span><br><span class="line">    // q[0]=0;</span><br><span class="line">    for(int i=1;i&lt;=cnt;++i)&#123;</span><br><span class="line">        while(hh&lt;=tt&amp;&amp;q[hh]&lt;=i-k)hh++;</span><br><span class="line">        while(hh&lt;=tt&amp;&amp;a[q[tt]]&lt;=a[i])tt--;</span><br><span class="line">        q[++tt]=i;</span><br><span class="line">        b[i]=a[q[hh]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void getmin(int a[],int b[],int cnt)&#123;</span><br><span class="line">    int hh=0,tt=0;</span><br><span class="line">    // q[0]=0;</span><br><span class="line">    for(int i=1;i&lt;=cnt;++i)&#123;</span><br><span class="line">        while(hh&lt;=tt&amp;&amp;q[hh]&lt;=i-k)hh++;</span><br><span class="line">        while(hh&lt;=tt&amp;&amp;a[q[tt]]&gt;=a[i])tt--;</span><br><span class="line">        q[++tt]=i;</span><br><span class="line">        b[i]=a[q[hh]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">    for(int i=1;i&lt;=n;++i)&#123;</span><br><span class="line">        for(int j=1;j&lt;=m;++j)&#123;</span><br><span class="line">            cin&gt;&gt;x[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //行间最小，最大</span><br><span class="line">    for(int i=1;i&lt;=n;++i)&#123;</span><br><span class="line">        getmax(x[i],mx[i],m);</span><br><span class="line">        getmin(x[i],mn[i],m);</span><br><span class="line">    &#125;</span><br><span class="line">    //列间最小，最大</span><br><span class="line">    int ans=1e9;</span><br><span class="line">    for(int i=k;i&lt;=m;++i)&#123;</span><br><span class="line">        //先存起来</span><br><span class="line">        for(int j=1;j&lt;=n;++j)&#123;</span><br><span class="line">            aa[j]=mx[j][i];</span><br><span class="line">            bb[j]=mn[j][i];</span><br><span class="line">        &#125;</span><br><span class="line">        getmax(aa,cc,n);</span><br><span class="line">        getmin(bb,dd,n);</span><br><span class="line">        // for(int j=1;j&lt;=n;++j)&#123;</span><br><span class="line">        //     cout&lt;&lt;cc[j]&lt;&lt;&#x27; &#x27;;</span><br><span class="line">        // &#125;cout&lt;&lt;&#x27;\n&#x27;;</span><br><span class="line">        for(int j=k;j&lt;=n;++j)&#123;</span><br><span class="line">            ans=min(ans,cc[j]-dd[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;&#x27;\n&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a>四、其他</h3><h4 id="4-1顺时针、逆时针分别维护最值"><a href="#4-1顺时针、逆时针分别维护最值" class="headerlink" title="4.1顺时针、逆时针分别维护最值"></a>4.1顺时针、逆时针分别维护最值</h4><p><a href="https://www.acwing.com/problem/content/1090/">1088. 旅行问题 - AcWing题库</a></p><p>成环的解决方案：破环为链</p><p>核心难点：顺时针（逆时针）时o-d的前缀和一致为正</p><p>最好采用相同的思想,s维护差值的前缀和–全部维护后置的最小，但是要下一个位置不大于后边的最小，以下一个位置为定点，遍历n长度前缀最小，保证前缀不负</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">成环问题：破环成链</span><br><span class="line">可以顺时针走或者逆时针走,</span><br><span class="line">最好采用相同的思想,s维护差值的前缀和</span><br><span class="line">*/</span><br><span class="line">void solve()&#123;</span><br><span class="line">    int n;cin&gt;&gt;n;</span><br><span class="line">    for(int i=1;i&lt;=n;++i)&#123;</span><br><span class="line">        cin&gt;&gt;o[i]&gt;&gt;d[i];</span><br><span class="line">        o[n+i]=o[i];</span><br><span class="line">        d[n+i]=d[i];</span><br><span class="line">    &#125;</span><br><span class="line">    //每个点都要统计一遍</span><br><span class="line">    //顺时针走，逆着来够大</span><br><span class="line">    for(int i=1;i&lt;=n;++i)&#123;</span><br><span class="line">        s[i]=s[i+n]=o[i]-d[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=2*n;++i)&#123;</span><br><span class="line">        s[i]+=s[i-1];</span><br><span class="line">    &#125;</span><br><span class="line">    int hh=0,tt=-1;</span><br><span class="line">    // 全部维护后置的最小，但是要下一个位置不大于后边的最小，以下一个位置为定点，遍历n长度前缀最小，保证前缀不负</span><br><span class="line">    for(int i=2*n;i&gt;=1;--i)&#123;</span><br><span class="line">        while(hh&lt;=tt&amp;&amp;q[hh]&gt;=i+n)hh++;</span><br><span class="line">        while(hh&lt;=tt&amp;&amp;s[q[tt]]&gt;=s[i])tt--;</span><br><span class="line">        q[++tt]=i;</span><br><span class="line">        if(i&lt;=n)&#123;</span><br><span class="line">            ans[i]|=(s[i-1]&lt;=s[q[hh]]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //注意下一个距离的变化</span><br><span class="line">    d[0]=d[n];</span><br><span class="line">    for(int i=1;i&lt;=n;++i)&#123;</span><br><span class="line">        s[i]=s[i+n]=o[i]-d[i-1];</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=2*n;i&gt;=1;--i)&#123;</span><br><span class="line">        s[i]+=s[i+1];</span><br><span class="line">    &#125;</span><br><span class="line">    hh=0,tt=-1;</span><br><span class="line">    for(int i=1;i&lt;=2*n;++i)&#123;</span><br><span class="line">        while(hh&lt;=tt&amp;&amp;q[hh]&lt;=i-n)hh++;</span><br><span class="line">        while(hh&lt;=tt&amp;&amp;s[q[tt]]&gt;=s[i])tt--;</span><br><span class="line">        q[++tt]=i;</span><br><span class="line">        if(i&gt;n)&#123;</span><br><span class="line">            ans[i-n]|=(s[i+1]&lt;=s[q[hh]]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=n;++i)&#123;</span><br><span class="line">        if(ans[i])cout&lt;&lt;&quot;TAK\n&quot;;</span><br><span class="line">        else cout&lt;&lt;&quot;NIE\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2待补"><a href="#4-2待补" class="headerlink" title="4.2待补"></a>4.2待补</h4><p><a href="https://www.acwing.com/problem/content/1089/">1087. 修剪草坪 - AcWing题库</a></p><h4 id="4-3待补（洛谷"><a href="#4-3待补（洛谷" class="headerlink" title="4.3待补（洛谷"></a>4.3待补（洛谷</h4><p><a href="https://www.luogu.com.cn/problem/P5858">P5858 「SWTR-03」Golden Sword - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><h4 id="4-4"><a href="#4-4" class="headerlink" title="4.4"></a>4.4</h4><p><a href="https://codeforces.com/gym/104128/problem/B">Problem - B - Codeforces</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 知识讲解 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
