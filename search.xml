<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>部分和位置有关的题</title>
      <link href="/2024/05/02/%E9%83%A8%E5%88%86%E5%92%8C%E4%BD%8D%E7%BD%AE%E6%9C%89%E5%85%B3%E7%9A%84%E9%A2%98/"/>
      <url>/2024/05/02/%E9%83%A8%E5%88%86%E5%92%8C%E4%BD%8D%E7%BD%AE%E6%9C%89%E5%85%B3%E7%9A%84%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="和位置、大小有关的题"><a href="#和位置、大小有关的题" class="headerlink" title="和位置、大小有关的题"></a>和位置、大小有关的题</h1><h2 id="一、采用单调栈-贪心"><a href="#一、采用单调栈-贪心" class="headerlink" title="一、采用单调栈+贪心"></a>一、采用单调栈+贪心</h2><p><a href="https://ac.nowcoder.com/acm/contest/46813/F">F-小沙の串串_2023牛客寒假算法基础集训营5 (nowcoder.com)</a></p><h2 id="二、"><a href="#二、" class="headerlink" title="二、"></a>二、</h2><p><a href="https://codeforces.com/contest/1778/problem/B">Problem - B - Codeforces</a></p><p>太疲劳别打比赛，只是掉分</p><p>注意那个条件是对于所有的i，所以只需要打破其中一个的就可以了，选择最小的</p><h2 id="三、二分，审题，选和不选的全部情况"><a href="#三、二分，审题，选和不选的全部情况" class="headerlink" title="三、二分，审题，选和不选的全部情况"></a>三、二分，审题，选和不选的全部情况</h2><p><a href="https://codeforces.com/contest/1788/problem/D">Problem - D - Codeforces</a></p><p>2的多少次幂预处理，</p><h2 id="四、hash，或者stl"><a href="#四、hash，或者stl" class="headerlink" title="四、hash，或者stl"></a>四、hash，或者stl</h2><p><a href="https://codeforces.com/group/Aokqa6Haao/contest/427952/problem/J">Problem - J - Codeforces</a></p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>需要预处理筛法，快速找到质因子，用hash记录出现情况，map记录对应出现次数，ans统计答案</p><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>质因子的寻找，先预处理，循环外围sqrt，内围while，最后找完判断a[i]&gt;1?  统计答案</p><h2 id="五、二分，前缀和，差分"><a href="#五、二分，前缀和，差分" class="headerlink" title="五、二分，前缀和，差分"></a>五、二分，前缀和，差分</h2><p><a href="https://codeforces.com/contest/1795/problem/C">Problem - C - Codeforces</a></p><h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><p>每一个要逐个被后边做加法、做减法&#x3D;》逐个-二分，加法减法-前缀和</p><p>记录每个被完整加和的次数，并处理其他剩余部分即可</p><h3 id="注意：-1"><a href="#注意：-1" class="headerlink" title="注意："></a>注意：</h3><p>被完整加的次数是核心突破口</p><h2 id="六、位运算，时间戳"><a href="#六、位运算，时间戳" class="headerlink" title="六、位运算，时间戳"></a>六、位运算，时间戳</h2><p><a href="https://ac.nowcoder.com/acm/contest/52244/G">G-A Xor B Problem again_2023年中国高校计算机大赛-团队程序设计天梯赛（GPLT）上海理工大学校内选拔赛（同步赛) (nowcoder.com)</a></p><h3 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h3><p>对当前数记载个数，之后遍历每个数，对应的数是x&#x3D;(1&lt;&lt;17)-1-i,是对应数可有一的位，之后j&#x3D;(j-1)&amp;x,这样的话，就可以遍历所有对应的数，最后加和求答案</p><h3 id="注意：-2"><a href="#注意：-2" class="headerlink" title="注意："></a>注意：</h3><p>能用数组就用数组，要不然会T</p><h2 id="七、相邻位置交换，最小交换次数。"><a href="#七、相邻位置交换，最小交换次数。" class="headerlink" title="七、相邻位置交换，最小交换次数。"></a>七、相邻位置交换，最小交换次数。</h2><p><a href="https://codeforces.com/contest/1828/problem/D1">Problem - D1 - Codeforces</a></p><p>题意：最小操作使之有序，长度从1到n</p><p>优先队列或者栈操作。</p><p>大致思想就是用前边大，跨过小的，从而达到最小的要求。</p><h2 id="八、构造"><a href="#八、构造" class="headerlink" title="八、构造"></a>八、构造</h2><p><a href="https://codeforces.com/contest/1839/problem/C">Problem - C - Codeforces</a></p><h2 id="九、与字符串子串排序有关"><a href="#九、与字符串子串排序有关" class="headerlink" title="九、与字符串子串排序有关"></a>九、与字符串子串排序有关</h2><p><a href="https://codeforces.com/contest/1849/problem/C">Problem - C - Codeforces</a></p><h2 id="十、如何优化字符串部分子串获取问题-双指针，dp转移"><a href="#十、如何优化字符串部分子串获取问题-双指针，dp转移" class="headerlink" title="十、如何优化字符串部分子串获取问题-双指针，dp转移"></a>十、如何优化字符串部分子串获取问题-双指针，dp转移</h2><p><a href="https://codeforces.com/contest/1948/problem/D">Problem - D - Codeforces</a></p><h2 id="十一、二分变形，位置数字大小关系"><a href="#十一、二分变形，位置数字大小关系" class="headerlink" title="十一、二分变形，位置数字大小关系"></a>十一、二分变形，位置数字大小关系</h2><p><a href="https://codeforces.com/contest/1945/problem/E">Problem - E - Codeforces</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n,x;cin&gt;&gt;n&gt;&gt;x;</span><br><span class="line"><span class="type">int</span> pos=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">cin&gt;&gt;p[i];</span><br><span class="line"><span class="keyword">if</span>(p[i]==x)pos=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据二分后的大小关系判断位置 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 核心理解在于二分只比较中间位置 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 模拟流程、举例子、分情况 </span></span><br><span class="line"><span class="type">int</span> l=<span class="number">1</span>,r=n+<span class="number">1</span>;</span><br><span class="line"><span class="type">bool</span> vis=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(l+<span class="number">1</span>&lt;r)&#123;</span><br><span class="line"><span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(p[l]==x)vis=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(p[mid]&lt;=x)l=mid;</span><br><span class="line"><span class="keyword">else</span> r=mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一次搜索可以，输出0</span></span><br><span class="line"><span class="keyword">if</span>(p[l]==x)&#123;</span><br><span class="line">cout&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不影响二分过程（没有使用过，或 大小关系不影响） </span></span><br><span class="line"><span class="comment">// 否则，只能说明l=1，r=2，经过的中间点都大于x，l点换为x即为答案  </span></span><br><span class="line"><span class="comment">//if(!vis||p[l]&lt;=x)&#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">没有l移动，换成l</span></span><br><span class="line"><span class="comment">有r移动，但x不影响l的移动 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">cout&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">cout&lt;&lt;pos&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;l&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="comment">//return ;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十二、数值和位置一致时贡献1"><a href="#十二、数值和位置一致时贡献1" class="headerlink" title="十二、数值和位置一致时贡献1"></a>十二、数值和位置一致时贡献1</h2><p><a href="https://codeforces.com/contest/1917/problem/C">Problem - C - Codeforces</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>部分Acwing</title>
      <link href="/2024/05/02/%E9%83%A8%E5%88%86Acwing/"/>
      <url>/2024/05/02/%E9%83%A8%E5%88%86Acwing/</url>
      
        <content type="html"><![CDATA[<h2 id="一、4993-FEB"><a href="#一、4993-FEB" class="headerlink" title="一、4993.FEB"></a>一、4993.FEB</h2><p><a href="https://www.acwing.com/problem/content/4996/">4993. FEB - AcWing题库</a></p><ul><li><p>先分后和，分类讨论。举特例，数学归纳法</p></li><li><p>第一步，逐段分析</p></li><li><p>第二步，求每段的情况</p></li></ul><p>第一种情况：xxxxx     0 1 2….k-1 -&gt;   全都不一样 …全都一样</p><p>第二种情况：0xxxxx  0 1 …. k     -&gt;  全都不一样 …全都一样</p><p>第三种情况：0xxxxx0  分k的奇偶 -&gt; k 奇 0 2 ….k+1          ;k 偶 1 3 ….k+1    </p><p>第四种情况：0xxxxx1  分k的奇偶 -&gt; k 奇 1 2 ….k+1          ;k 偶 0 3 ….k+1    </p><p>举例子然后分析可以得到每种情况的类型数量</p><ul><li>第三步，合并</li></ul><p>公差2和2合并，公差为2</p><p>公差2和1合并，公差为1</p><p>对应最大值，最小值分别为两个数组最大和最小的和</p><ul><li>第四步，代码</li></ul><p>第一种情况对应特例，第二种情况对应边界，三、四种情况对应中间部分</p><p>至于合并时的最大、最小值，全在于和前边一样不一样</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">string s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="built_in">string</span>(n, <span class="string">&#x27;F&#x27;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (s[l] == <span class="string">&#x27;F&#x27;</span>) l ++ ;</span><br><span class="line">        <span class="keyword">while</span> (s[r] == <span class="string">&#x27;F&#x27;</span>) r -- ;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> low = <span class="number">0</span>, high = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> str = s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i] == <span class="string">&#x27;F&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (str[i - <span class="number">1</span>] == <span class="string">&#x27;B&#x27;</span>) str[i] = <span class="string">&#x27;E&#x27;</span>;</span><br><span class="line">                <span class="keyword">else</span> str[i] = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; l &amp;&amp; str[i] == str[i - <span class="number">1</span>]) low ++ ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        str = s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i] == <span class="string">&#x27;F&#x27;</span>) str[i] = str[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (i &gt; l &amp;&amp; str[i] == str[i - <span class="number">1</span>]) high ++ ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ends = l + n - <span class="number">1</span> - r, d = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (ends) high += ends, d = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; (high - low) / d + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = low; i &lt;= high; i += d)</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、4966-填充"><a href="#二、4966-填充" class="headerlink" title="二、4966.填充"></a>二、4966.填充</h2><p><a href="https://www.acwing.com/problem/content/4969/">4966. 填充 - AcWing题库</a></p><p>贪心，最优解</p><p>贪心问题往往是公式推导，策略选择，方法的证明</p><p>本题，在能配对的前提下，尽可能左配，左配能替代右配或者更优</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i+<span class="number">1</span>&lt;s.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">        <span class="type">char</span> a=s[i],b=s[i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="string">&#x27;?&#x27;</span>||b==<span class="string">&#x27;?&#x27;</span>||a==b)ans++,i++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、5407管道"><a href="#三、5407管道" class="headerlink" title="三、5407管道"></a>三、5407管道</h2><p><a href="https://www.acwing.com/problem/content/5410/">5407. 管道 - AcWing题库</a></p><p>二分答案，check用区间合并</p><p>本题的区间合并又有点不太一样</p><p>区间合并板子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;PII&gt; &amp;segs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;PII&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(), segs.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> st = <span class="number">-2e9</span>, ed = <span class="number">-2e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> seg : segs)</span><br><span class="line">        <span class="keyword">if</span> (ed &lt; seg.first)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line">            st = seg.first, ed = seg.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ed = <span class="built_in">max</span>(ed, seg.second);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line"></span><br><span class="line">    segs = res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本题代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; w[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> mid)</span></span>&#123;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt;p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="type">int</span> l=w[i].first,s=w[i].second;</span><br><span class="line">        <span class="keyword">if</span>(s&lt;=mid)&#123;</span><br><span class="line">            <span class="type">int</span> t=mid-s;</span><br><span class="line">            p.<span class="built_in">push_back</span>(&#123;<span class="built_in">max</span>(<span class="number">1ll</span>,l-t),<span class="built_in">min</span>(m,l+t)&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> st=<span class="number">-1</span>,ed=<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">sort</span>(p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">//本题的区间合并需要考虑加1，因为两点之间没有东西了也叫覆盖</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p[i].first&lt;=ed+<span class="number">1</span>)ed=<span class="built_in">max</span>(ed,p[i].second);</span><br><span class="line">        <span class="keyword">else</span> st=p[i].first,ed=p[i].second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  st==<span class="number">1</span>&amp;&amp;ed==m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//二分+区间合并</span></span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        cin&gt;&gt;w[i].first&gt;&gt;w[i].second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">2e9</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid))r=mid;</span><br><span class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;l&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;r&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、4968-互质数的个数"><a href="#四、4968-互质数的个数" class="headerlink" title="四、4968. 互质数的个数"></a>四、4968. 互质数的个数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">const</span>  <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">100</span>,MOD=<span class="number">998244353</span>,inf=<span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ksm</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)ans=ans*a%MOD;</span><br><span class="line"></span><br><span class="line">        a=a*a%MOD;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans%MOD;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> pri[N],vis[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> a,b;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="comment">// 题意：范围小于给定数，互质数的个数</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        欧拉函数板子题：给定a，函数算出1&lt;=x&lt;=a ,__gcd(x,a)==1 的个数</span></span><br><span class="line"><span class="comment">        a=p1^a1 * p2^a2 * p3^a3 ....pn^an</span></span><br><span class="line"><span class="comment">        结果=a*((p1-1)/p1*(p2-1)/p2*(p3-1)/p3.....)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        本题多一个b次方，除法可以考虑逆序对或者转换公式</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">if</span>(a==<span class="number">1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">// 素数质数  欧式筛快速幂</span></span><br><span class="line">    <span class="type">int</span> res=a,x=a;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i*i&lt;=x;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x%i==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(x%i==<span class="number">0</span>)x/=i;</span><br><span class="line">            res=res/i*(i<span class="number">-1</span>)%MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">1</span>)res=res/x*(x<span class="number">-1</span>)%MOD;</span><br><span class="line">    cout&lt;&lt;<span class="function">res*<span class="title">ksm</span><span class="params">(a,b<span class="number">-1</span>)</span>%MOD</span>;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="五、5406-松散子序列"><a href="#五、5406-松散子序列" class="headerlink" title="五、5406. 松散子序列"></a>五、5406. 松散子序列</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dp[N];<span class="comment">// 当前位置下的最大值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s;cin&gt;&gt;s;</span><br><span class="line">    <span class="type">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">    s=<span class="string">&#x27; &#x27;</span>+s;</span><br><span class="line">    <span class="comment">// 符合条件下的子序列价值最大, 像是策略dp</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">        dp 主要在于状态和如何进行不同状态下的转移</span></span><br><span class="line"><span class="comment">        常见的在于选和不选，   以及不同状态之间转移方案的选择</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   dp[<span class="number">1</span>]=s[<span class="number">1</span>]-<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="comment">// 当前位置不选，前一个位置即为最大</span></span><br><span class="line">        <span class="comment">// 当前位置选，从之前的位置开始，更新当前的值</span></span><br><span class="line">        dp[i]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>],dp[i<span class="number">-2</span>]+s[i]-<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[n]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h2 id="六、5408-保险箱"><a href="#六、5408-保险箱" class="headerlink" title="六、5408. 保险箱"></a>六、5408. 保险箱</h2><p><a href="https://www.acwing.com/problem/content/5411/">5408. 保险箱 - AcWing题库</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dp[N][<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    string x,y;</span><br><span class="line">    cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    <span class="comment">//题意：x通过每一位的改变变成y，求最小修改次数</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        策略在于</span></span><br><span class="line"><span class="comment">          发现变化，当前位的借位或者进位 只会影响高位，不会影响低位</span></span><br><span class="line"><span class="comment">          模拟每一种情况的变化</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    x=<span class="string">&#x27; &#x27;</span>+x;</span><br><span class="line">    y=<span class="string">&#x27; &#x27;</span>+y;</span><br><span class="line">    <span class="comment">// 0当前位正常加减  1表示当前位加减会想左进位  2当前位加减会向左借位</span></span><br><span class="line">    dp[n][<span class="number">0</span>]=<span class="built_in">abs</span>(x[n]-y[n]);</span><br><span class="line">    dp[n][<span class="number">1</span>]=-x[n]+y[n]+<span class="number">10</span>;</span><br><span class="line">    dp[n][<span class="number">2</span>]=x[n]-y[n]+<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;--i)&#123;</span><br><span class="line">        <span class="type">int</span> xx=x[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="type">int</span> yy=y[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="comment">// 0状态的转移</span></span><br><span class="line">        dp[i][<span class="number">0</span>]=<span class="built_in">min</span>(&#123;dp[i+<span class="number">1</span>][<span class="number">0</span>]+<span class="built_in">abs</span>(xx-yy),dp[i+<span class="number">1</span>][<span class="number">1</span>]+<span class="built_in">abs</span>(xx-yy+<span class="number">1</span>),dp[i+<span class="number">1</span>][<span class="number">2</span>]+<span class="built_in">abs</span>(xx<span class="number">-1</span>-yy)&#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1 </span></span><br><span class="line">        dp[i][<span class="number">1</span>]=<span class="built_in">min</span>(&#123;dp[i+<span class="number">1</span>][<span class="number">0</span>]+yy-xx+<span class="number">10</span>,dp[i+<span class="number">1</span>][<span class="number">1</span>]+yy-xx+<span class="number">9</span>,dp[i+<span class="number">1</span>][<span class="number">2</span>]+yy-xx+<span class="number">11</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">        dp[i][<span class="number">2</span>]=<span class="built_in">min</span>(&#123;dp[i+<span class="number">1</span>][<span class="number">0</span>]+xx-yy+<span class="number">10</span>,dp[i+<span class="number">1</span>][<span class="number">1</span>]+xx-yy+<span class="number">11</span>,dp[i+<span class="number">1</span>][<span class="number">2</span>]+xx-yy+<span class="number">9</span>&#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">min</span>(&#123;dp[<span class="number">1</span>][<span class="number">0</span>],dp[<span class="number">1</span>][<span class="number">1</span>],dp[<span class="number">1</span>][<span class="number">2</span>]&#125;)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h2 id="七、4662-因数平方和"><a href="#七、4662-因数平方和" class="headerlink" title="七、4662. 因数平方和"></a>七、4662. 因数平方和</h2><p><a href="https://www.acwing.com/problem/content/4665/">4662. 因数平方和 - AcWing题库</a></p><p><a href="https://www.acwing.com/solution/content/174106/">AcWing 4662. 【数学, 数论分块】因数平方和【蓝桥杯】 - AcWing</a></p><p>数论分块</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1-n 的 i*i 的和， == n*(n+1)*(n*2+1)/6;</span></span><br><span class="line">    <span class="keyword">return</span> n*(n+<span class="number">1ll</span>)%MOD*(<span class="number">2</span>*n%MOD+<span class="number">1ll</span>)%MOD* <span class="number">166666668</span>%MOD; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    <span class="comment">// 数学,公式推导,整除个数</span></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        最开始发现的规律：1-n 每个数是 i*i*(n/i) 然后求和 =》(n/i)可以提示数学分块 </span></span><br><span class="line"><span class="comment">        转换求数学分块和，转换=&gt;(n/i)*(求和l-r((求和1-r)(i*i)-(求和1-（l-1))(i*i)))</span></span><br><span class="line"><span class="comment">        这里运用了，分块和，前缀和，固定公式</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l&lt;=n;)&#123;</span><br><span class="line">        <span class="type">int</span> x=n/l,r=n/x;</span><br><span class="line">        ans=(ans+(<span class="built_in">ask</span>(r)-<span class="built_in">ask</span>(l<span class="number">-1</span>))*x%MOD)%MOD;</span><br><span class="line">        l=r+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;(ans+MOD)%MOD&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h2 id="八、4646-爬树的甲壳虫（需要再看"><a href="#八、4646-爬树的甲壳虫（需要再看" class="headerlink" title="八、4646. 爬树的甲壳虫（需要再看"></a>八、4646. 爬树的甲壳虫（需要再看</h2><p><a href="https://www.acwing.com/problem/content/4649/">4646. 爬树的甲壳虫 - AcWing题库</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        res = (res + <span class="number">1ll</span>) % MOD * y % MOD * <span class="built_in">ksm</span>(y - x, MOD - <span class="number">2ll</span>) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="九、4656、技能提升-：二分"><a href="#九、4656、技能提升-：二分" class="headerlink" title="九、4656、技能提升 ：二分"></a>九、4656、技能提升 ：二分</h2><p><a href="https://www.acwing.com/problem/content/4659/">4656. 技能升级 - AcWing题库</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[N],b[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> r,<span class="type">int</span> cnt,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> l=r-d*(cnt<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> (l+r)*cnt/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 检查到达这个值所需的次数是否可以满足</span></span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;x)&#123;</span><br><span class="line">            cnt+=<span class="built_in">ceil</span>(<span class="number">1.0</span>*(a[i]-x)/b[i]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt&lt;=m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 增加的技能点数会变小</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        等差数列+二分</span></span><br><span class="line"><span class="comment">        二分的是数据下界，</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        cin&gt;&gt;a[i]&gt;&gt;b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">1e6</span>,ans=<span class="number">0</span>,now=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid))&#123;</span><br><span class="line">            r=mid<span class="number">-1</span>;</span><br><span class="line">            ans=mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ass=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;ans)&#123;</span><br><span class="line">            now=<span class="built_in">ceil</span>(<span class="number">1.0</span>*(a[i]-ans)/b[i]); <span class="comment">// ceil使用先转换成浮点型，精度损失</span></span><br><span class="line">            cnt+=now;</span><br><span class="line">            ass+=<span class="built_in">sum</span>(a[i],now,b[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ass+(m-cnt)*ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 之所以会有 (m-cnt)*ans ，反向思维，最后的值不是ans的话cnt个数会变多，所以不合理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十、1225、正则问题-：dfs或者栈"><a href="#十、1225、正则问题-：dfs或者栈" class="headerlink" title="十、1225、正则问题  ：dfs或者栈"></a>十、1225、正则问题  ：dfs或者栈</h2><p><a href="https://www.acwing.com/problem/content/description/1227/">1225. 正则问题 - AcWing题库</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> id;<span class="comment">// 这个id得放外边，不然的话向上回溯的时候id没变化 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="comment">// 对于每种可能的情况进行特判</span></span><br><span class="line"><span class="keyword">while</span>(id&lt;s.<span class="built_in">size</span>())&#123;</span><br><span class="line"><span class="comment">// 代表开始，累加 </span></span><br><span class="line"><span class="keyword">if</span>(s[id]==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">id++;</span><br><span class="line">res += <span class="built_in">dfs</span>();</span><br><span class="line">id++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代表最后，结束 </span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(s[id] == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line"><span class="comment">//cout&lt;&lt;res&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代表左右只能选一个 </span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(s[id] == <span class="string">&#x27;|&#x27;</span>)&#123;</span><br><span class="line">id++;</span><br><span class="line">res=<span class="built_in">max</span>(res, <span class="built_in">dfs</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正常运行计数 </span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">id++;</span><br><span class="line">res++;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// 字符匹配的问题,在括号里找到最长的字符用于字符串匹配 </span></span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line"><span class="comment">// 有层次问题，用dfs递归解决</span></span><br><span class="line">cout&lt;&lt;<span class="built_in">dfs</span>()&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="十一：97、约数之和-：分治法或者公式法"><a href="#十一：97、约数之和-：分治法或者公式法" class="headerlink" title="十一：97、约数之和 ：分治法或者公式法"></a>十一：97、约数之和 ：分治法或者公式法</h2><p><a href="https://www.acwing.com/problem/content/99/">97. 约数之和 - AcWing题库</a></p><h3 id="约数之和公式推导"><a href="#约数之和公式推导" class="headerlink" title="约数之和公式推导"></a>约数之和公式推导</h3><p><img src="/%E7%BA%A6%E6%95%B0%E4%B9%8B%E5%92%8C.png" alt="约数之和"></p><h3 id="质因子分解"><a href="#质因子分解" class="headerlink" title="质因子分解"></a>质因子分解</h3><p>一定要注意最后分解的数是否还有</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i, s ++ ;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 奇数个情况时转换成偶数情况 , +1是因为p^0被特判了 </span></span><br><span class="line"><span class="keyword">if</span>(k%<span class="number">2</span>==<span class="number">0</span>)<span class="keyword">return</span> (p%MOD*<span class="built_in">sum</span>(p,k<span class="number">-1</span>)%MOD+<span class="number">1</span>)%MOD;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">return</span> (<span class="built_in">ksm</span>(p,k/<span class="number">2</span>+<span class="number">1</span>)%MOD+<span class="number">1</span>)%MOD*<span class="built_in">sum</span>(p,k/<span class="number">2</span>)%MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// a的b次方的约数之和 </span></span><br><span class="line"><span class="comment">// 约数之和常见公式结论+快速幂+分治+公式推导 + 质因子分解 </span></span><br><span class="line"><span class="type">int</span> a,b;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=a;++i)&#123;</span><br><span class="line"><span class="comment">// 循环质因子分解</span></span><br><span class="line"><span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(a%i==<span class="number">0</span>)&#123;</span><br><span class="line">a/=i;</span><br><span class="line">s++;</span><br><span class="line">&#125; </span><br><span class="line">res=res*<span class="built_in">sum</span>(i,s*b)%MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a==<span class="number">0</span>)res=<span class="number">0</span>;</span><br><span class="line">cout&lt;&lt;res&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十二、98、分形之城-：坐标变换，递归"><a href="#十二、98、分形之城-：坐标变换，递归" class="headerlink" title="十二、98、分形之城 ：坐标变换，递归"></a>十二、98、分形之城 ：坐标变换，递归</h2><p><a href="https://www.acwing.com/problem/content/100/">98. 分形之城 - AcWing题库</a></p><p>坐标变换：平移，对称，规律</p><p>递归：每次将块数变小 , 注意画图，注意细节，注意1加1ll</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="function">pii <span class="title">sum</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> a)</span></span>&#123;<span class="comment">// 第n级编号为a </span></span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">0</span>)<span class="keyword">return</span> &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">// 缩减到某一块,1/4份的个数，长度 </span></span><br><span class="line"><span class="type">int</span> block=(<span class="number">1ll</span>&lt;&lt;<span class="number">2</span>*n<span class="number">-2ll</span>),len=(<span class="number">1ll</span>&lt;&lt;n<span class="number">-1ll</span>);</span><br><span class="line"><span class="keyword">auto</span> now=<span class="built_in">sum</span>(n<span class="number">-1</span>,a%block);</span><br><span class="line"><span class="type">int</span> z=a/block,xx=now.first,yy=now.second;</span><br><span class="line"><span class="comment">// 看属于那一块进行特殊处理</span></span><br><span class="line"><span class="keyword">if</span>(z==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">// 关于y=x轴对称</span></span><br><span class="line"><span class="keyword">return</span> &#123;yy,xx&#125;; </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(z==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">// 向右平移len</span></span><br><span class="line"><span class="keyword">return</span> &#123;xx,yy+len&#125;; </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(z==<span class="number">2</span>)&#123;</span><br><span class="line"><span class="comment">// 向右下角平移</span></span><br><span class="line"><span class="keyword">return</span> &#123;xx+len,yy+len&#125;; </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 左下角，关于截距1&lt;&lt;n-1对称,画图注意变化</span></span><br><span class="line"><span class="keyword">return</span> &#123;len*<span class="number">2</span>-yy<span class="number">-1</span>,len-xx<span class="number">-1</span>&#125;; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n,a,b;cin&gt;&gt;n&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="comment">// 每次通过缩减规模从而解决问题,编号从0开始</span></span><br><span class="line"><span class="keyword">auto</span> pa=<span class="built_in">sum</span>(n,a<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">auto</span> pb=<span class="built_in">sum</span>(n,b<span class="number">-1</span>);</span><br><span class="line"><span class="comment">// 最后的距离是坐标平方和sqrt，一个单位是10</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.0lf\n&quot;</span>,<span class="built_in">sqrt</span>((pa.first-pb.first)*(pa.first-pb.first)+(pa.second-pb.second)*(pa.second-pb.second))*<span class="number">10</span>);</span><br><span class="line"><span class="comment">// cout&lt;&lt;(int)(ceil())&lt;&lt;&#x27;\n&#x27;; </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多校训练</title>
      <link href="/2024/05/02/%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83/"/>
      <url>/2024/05/02/%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83/</url>
      
        <content type="html"><![CDATA[<h1 id="多校训练"><a href="#多校训练" class="headerlink" title="多校训练"></a>多校训练</h1><p>牛客多校：1、 2、 3、4、5、6、7（没打、8、9、</p><p>杭电多校：5、6、7、8、9</p><h2 id="一、dp"><a href="#一、dp" class="headerlink" title="一、dp"></a>一、dp</h2><h3 id="1-1-有限制条件的转移"><a href="#1-1-有限制条件的转移" class="headerlink" title="1.1  有限制条件的转移"></a>1.1  有限制条件的转移</h3><p><a href="https://ac.nowcoder.com/acm/contest/57356/K">K-Box_2023牛客暑期多校训练营2 (nowcoder.com)</a></p><p>加限制条件的转移，所有状态的转移</p><h3 id="1-2-树形dp"><a href="#1-2-树形dp" class="headerlink" title="1.2 树形dp"></a>1.2 树形dp</h3><p><a href="https://acm.hdu.edu.cn/contest/problem?cid=1094&pid=1002">1002 City Upgrading (hdu.edu.cn)</a></p><h3 id="1-3-dp，状态的压缩，挺不错的"><a href="#1-3-dp，状态的压缩，挺不错的" class="headerlink" title="1.3 dp，状态的压缩，挺不错的"></a>1.3 dp，状态的压缩，挺不错的</h3><p><a href="https://acm.hdu.edu.cn/contest/problem?cid=1095&pid=1010">1010 Klee likes making friends (hdu.edu.cn)</a></p><p>第一维表示右边界，第二维表示左右边界的距离</p><ol><li>开始m</li><li>中间逐个移动</li><li>最后m个元素，选择ans</li></ol><p>表示左右边界的话，可以直接l和r，但是空间不行的话，可以只记录右边界，然后记录长度</p><p>对于只和上个状态有关的时候，可以使用压缩空间滚动数组的方法。</p><h3 id="1-4滚动数组，前缀和优化（不完全理解"><a href="#1-4滚动数组，前缀和优化（不完全理解" class="headerlink" title="1.4滚动数组，前缀和优化（不完全理解"></a>1.4滚动数组，前缀和优化（不完全理解</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7304">Problem - 7304 (hdu.edu.cn)</a></p><h3 id="1-5-组合数，dp-需再看"><a href="#1-5-组合数，dp-需再看" class="headerlink" title="1.5 组合数，dp 需再看"></a>1.5 组合数，dp 需再看</h3><p><a href="https://ac.nowcoder.com/acm/contest/57357/B">B-Auspiciousness_2023牛客暑期多校训练营3 (nowcoder.com)</a></p><p>初始化组合数、阶乘数、dp数组</p><p>dp[ i ] [ j ] [ 2 ]  &#x2F;&#x2F;i个小的   j个大的   最后一段是小的还是大的</p><p>枚举几个小的，几个大的，以及从哪里转移过来的</p><p>从哪里转移的以及答案记录都要使用组合数</p><h3 id="1-6前缀和优化dp"><a href="#1-6前缀和优化dp" class="headerlink" title="1.6前缀和优化dp"></a>1.6前缀和优化dp</h3><p><a href="https://ac.nowcoder.com/acm/contest/57358/J">J-Qu’est-ce Que C’est?_2023牛客暑期多校训练营4 (nowcoder.com)</a></p><p>长度为n，然后范围在-m到m之间，保证每一段都&gt;&#x3D;0，数字可重复</p><p>dp[i] [j]表示构造了前i个，以j为结尾</p><p>对称的选择，并列的两次循环，并且使用前缀和进行优化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前缀和优化dp</span></span><br><span class="line"><span class="comment">//每个位置都去尝试一遍</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">2</span>*m+<span class="number">1</span>;++j)&#123;<span class="comment">//j要减去m+1</span></span><br><span class="line">    <span class="keyword">if</span>(j&lt;=m)<span class="comment">//1 对应 2*m 只有m可以用，之后只有到m-1、m-2...前缀和</span></span><br><span class="line">       dp[i][j]=(dp[i][j]+sum[<span class="number">2</span>*m+<span class="number">1</span>]-sum[<span class="number">2</span>*m-j+<span class="number">1</span>]+mod)%mod;</span><br><span class="line">        <span class="keyword">else</span>    <span class="comment">//m+1 对应 0 （1-2*m+1）之后（2-2*m+1）...前缀和，只用可以相互抵消的可以用，</span></span><br><span class="line">            dp[i][j]=(dp[i][j]+sum[<span class="number">2</span>*m+<span class="number">1</span>]-sum[j-m<span class="number">-1</span>]+mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">2</span>*m+<span class="number">1</span>;++j)&#123;</span><br><span class="line">        sum[j]=(sum[j<span class="number">-1</span>]+dp[i][j])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-7-dp-i-j-第一维表示第i个口袋，j个体重，求最大价值"><a href="#1-7-dp-i-j-第一维表示第i个口袋，j个体重，求最大价值" class="headerlink" title="1.7 dp[i] [j] 第一维表示第i个口袋，j个体重，求最大价值"></a>1.7 dp[i] [j] 第一维表示第i个口袋，j个体重，求最大价值</h3><p><a href="https://ac.nowcoder.com/acm/contest/57359/H">H-Nazrin the Greeeeeedy Mouse_2023牛客暑期多校训练营5 (nowcoder.com)</a></p><p>对于过程的模拟和状态的转移，</p><p>背包，只不过可以选或者不选，每个操作都需要平方的转移</p><h3 id="1-8-简单dp"><a href="#1-8-简单dp" class="headerlink" title="1.8 简单dp"></a>1.8 简单dp</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7329">Problem - 7329 (hdu.edu.cn)</a></p><p>dp某种意义上在于根据题意设置容器</p><p>状态维数往往代表循环个数</p><p>dp[i] [j] [k]表示当前位置，左袋有j，右袋有k，</p><p>模拟每个操作的处理之后就可以得到答案。</p><p>可以使用up来更新状态，这样更加集中</p><h3 id="1-9-树形dp，树链剖分"><a href="#1-9-树形dp，树链剖分" class="headerlink" title="1.9 树形dp，树链剖分"></a>1.9 树形dp，树链剖分</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7332">Problem - 7332 (hdu.edu.cn)</a></p><p>重儿子、轻儿子</p><p>关键在于对树形式和状态转移以及转移时相关数量的理解很重要，模拟找找规律</p><p>用邻接矩阵建图容易空间过大，导致一些效率问题，其实这个没有卡</p><p>初始化和node开始为1，等号注意个数</p><h3 id="1-10树形dp（待补"><a href="#1-10树形dp（待补" class="headerlink" title="1.10树形dp（待补"></a>1.10树形dp（待补</h3><p><a href="https://ac.nowcoder.com/acm/contest/57360/A">A-Tree_2023牛客暑期多校训练营6 (nowcoder.com)</a></p><h3 id="1-11dp（待补"><a href="#1-11dp（待补" class="headerlink" title="1.11dp（待补"></a>1.11dp（待补</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7368">Problem - 7368 (hdu.edu.cn)</a></p><h3 id="1-12双指针或者dp（待补"><a href="#1-12双指针或者dp（待补" class="headerlink" title="1.12双指针或者dp（待补"></a>1.12双指针或者dp（待补</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7369">Problem - 7369 (hdu.edu.cn)</a></p><h3 id="1-13-状压dp，需要优化（待补"><a href="#1-13-状压dp，需要优化（待补" class="headerlink" title="1.13 状压dp，需要优化（待补"></a>1.13 状压dp，需要优化（待补</h3><p><a href="https://ac.nowcoder.com/acm/contest/57364/F">F-IUPC_“范式杯”2023牛客暑期多校训练营10 (nowcoder.com)</a></p><h2 id="二、博弈"><a href="#二、博弈" class="headerlink" title="二、博弈"></a>二、博弈</h2><h3 id="1-1-sg函数"><a href="#1-1-sg函数" class="headerlink" title="1.1 sg函数"></a>1.1 sg函数</h3><p><a href="https://acm.hdu.edu.cn/contest/problem?cid=1094&pid=1012">1012 Play on Tree (hdu.edu.cn)</a></p><h3 id="1-2nim游戏（待补"><a href="#1-2nim游戏（待补" class="headerlink" title="1.2nim游戏（待补"></a>1.2nim游戏（待补</h3><p><a href="https://acm.hdu.edu.cn/contest/problem?cid=1095&pid=1001">1001 Alice Game (hdu.edu.cn)</a></p><h3 id="1-3（待补"><a href="#1-3（待补" class="headerlink" title="1.3（待补"></a>1.3（待补</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7354">Problem - 7354 (hdu.edu.cn)</a></p><h3 id="1-4-逆序对，先手的人可能发生变化，（不完全理解"><a href="#1-4-逆序对，先手的人可能发生变化，（不完全理解" class="headerlink" title="1.4 逆序对，先手的人可能发生变化，（不完全理解"></a>1.4 逆序对，先手的人可能发生变化，（不完全理解</h3><p><a href="https://ac.nowcoder.com/acm/contest/57362/K">K-Scheming Furry_2023牛客暑期多校训练营8 (nowcoder.com)</a></p><p>好多题都和逆序对有关</p><p>一些结论要猜猜试试</p><h3 id="1-5-博弈-、-sg函数"><a href="#1-5-博弈-、-sg函数" class="headerlink" title="1.5 博弈 、 sg函数"></a>1.5 博弈 、 sg函数</h3><p><a href="https://ac.nowcoder.com/acm/contest/57364/D">D-Agnej_“范式杯”2023牛客暑期多校训练营10 (nowcoder.com)</a></p><p>分情况写sg函数，注意问题的最小规模和逻辑的推导</p><p>题意：每次只能拿一个，拿完一半就废了</p><p>代码核心：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int even(int x,int y)&#123;</span><br><span class="line">    return (x+y)%2;</span><br><span class="line">&#125;</span><br><span class="line">int odd(int l,int mid,int r)&#123;</span><br><span class="line">    if(!mid)return even(l,r);</span><br><span class="line">    if(l&lt;r)swap(l,r);</span><br><span class="line">    if(!r)return l%2;</span><br><span class="line">    if(r==1)return (l%2==0)?3:2;</span><br><span class="line">    return (l+1+r)%2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、图论"><a href="#三、图论" class="headerlink" title="三、图论"></a>三、图论</h2><h3 id="3-1最短路"><a href="#3-1最短路" class="headerlink" title="3.1最短路"></a>3.1最短路</h3><p><a href="https://ac.nowcoder.com/acm/contest/57355/K">K-Subdivision_“范式杯”2023牛客暑期多校训练营1 (nowcoder.com)</a></p><h3 id="3-2bitset优化"><a href="#3-2bitset优化" class="headerlink" title="3.2bitset优化"></a>3.2bitset优化</h3><p><a href="https://acm.hdu.edu.cn/contest/problem?cid=1095&pid=1007">1007 foreverlasting and fried-chicken (hdu.edu.cn)</a></p><p>bitset优化，图的模型，根据度和图的连接情况判断</p><h3 id="3-3dfs，分层图或者并查集（没太看懂），也可以bfs-dfs完成"><a href="#3-3dfs，分层图或者并查集（没太看懂），也可以bfs-dfs完成" class="headerlink" title="3.3dfs，分层图或者并查集（没太看懂），也可以bfs+dfs完成"></a>3.3dfs，分层图或者并查集（没太看懂），也可以bfs+dfs完成</h3><p><a href="https://ac.nowcoder.com/acm/contest/57357/E">E-Koraidon, Miraidon and DFS Shortest Path_2023牛客暑期多校训练营3 (nowcoder.com)</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">void bfs(int x)</span><br><span class="line">&#123;</span><br><span class="line">    queue&lt;int&gt; q;</span><br><span class="line">    q.push(x);</span><br><span class="line">    depth[0] = 0;</span><br><span class="line">    depth[x] = 1;</span><br><span class="line">    while (q.size())</span><br><span class="line">    &#123;</span><br><span class="line">        auto t = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        for (auto lb : graph[t])</span><br><span class="line">        &#123;</span><br><span class="line">            if (!depth[lb])</span><br><span class="line">            &#123;</span><br><span class="line">                depth[lb] = depth[t] + 1;</span><br><span class="line">                q.push(lb);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void dfs(int x, int fa)</span><br><span class="line">&#123;</span><br><span class="line">    dp[x] = 1;</span><br><span class="line">    for (auto lb : graph[x])</span><br><span class="line">    &#123;</span><br><span class="line">        if (dp[lb])</span><br><span class="line">            continue;</span><br><span class="line">        if (depth[lb] != depth[x] + 1)</span><br><span class="line">        &#123;</span><br><span class="line">            flag = false;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(lb, x);</span><br><span class="line">    &#125;</span><br><span class="line">    dp[x] = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-最小环计数，Floyd"><a href="#3-4-最小环计数，Floyd" class="headerlink" title="3.4 最小环计数，Floyd"></a>3.4 最小环计数，Floyd</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7322">Problem - 7322 (hdu.edu.cn)</a></p><h3 id="3-5倍增数组，找规律（待补"><a href="#3-5倍增数组，找规律（待补" class="headerlink" title="3.5倍增数组，找规律（待补"></a>3.5倍增数组，找规律（待补</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7345">Problem - 7345 (hdu.edu.cn)</a></p><h3 id="3-6并查集，联通块"><a href="#3-6并查集，联通块" class="headerlink" title="3.6并查集，联通块"></a>3.6并查集，联通块</h3><p><a href="https://acm.hdu.edu.cn/contest/problem?cid=1101&pid=1007">1007 Solubility (hdu.edu.cn)</a></p><h3 id="3-7-拓扑排序"><a href="#3-7-拓扑排序" class="headerlink" title="3.7 拓扑排序"></a>3.7 拓扑排序</h3><p><a href="https://ac.nowcoder.com/acm/contest/57364/L">L-Grayscale Confusion_“范式杯”2023牛客暑期多校训练营10 (nowcoder.com)</a></p><p>注意0 1点要合并，放到n的位置</p><p>题意可以暂时理解为每个点对于抽象函数的相对顺序</p><p><strong>偏序：</strong></p><p><em>前置条件</em> 2 : 如果 R 是 自反 , 反对称 , 传递的 ;</p><p>① 自反 : 每个元素 自己 和 自己 都有关系 , x R x  ;<br>② 反对称 : 如果 x R y 并且 y R x 则 x &#x3D; y  , 即 x ̸ &#x3D; y  , x R y  和 y R x不能同时存在 ; 可以没有 , 但是一定不能同时出现 ;<br>③ 传递 : 如果 有 x R y  , y R z  , 那么必须有 x R z  , 如果前提不成立 , 那么也勉强称为传递 ;<br><em>结论</em> : 称 R 为 A 上的偏序关系 ;<br><em>应用</em>：在评分标准不能准确标定而又需要进行排序的场合，这时将成员进行两两比较，确定两者之间的好坏关系，是较为容易且准确的一种方法。</p><h2 id="四、数论、二进制、推导公式"><a href="#四、数论、二进制、推导公式" class="headerlink" title="四、数论、二进制、推导公式"></a>四、数论、二进制、推导公式</h2><h3 id="4-1-概率"><a href="#4-1-概率" class="headerlink" title="4.1 概率"></a>4.1 概率</h3><p><a href="https://ac.nowcoder.com/acm/contest/57355/J">J-Roulette_“范式杯”2023牛客暑期多校训练营1 (nowcoder.com)</a></p><h3 id="4-2-exgcd（待补"><a href="#4-2-exgcd（待补" class="headerlink" title="4.2 exgcd（待补"></a>4.2 exgcd（待补</h3><p><a href="https://ac.nowcoder.com/acm/contest/57355/M">M-Water_“范式杯”2023牛客暑期多校训练营1 (nowcoder.com)</a></p><h3 id="4-3-概率、公式推导（有点问题"><a href="#4-3-概率、公式推导（有点问题" class="headerlink" title="4.3 概率、公式推导（有点问题"></a>4.3 概率、公式推导（有点问题</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7297">Problem - 7297 (hdu.edu.cn)</a></p><h3 id="4-4-数论，哥德巴赫猜想"><a href="#4-4-数论，哥德巴赫猜想" class="headerlink" title="4.4 数论，哥德巴赫猜想"></a>4.4 数论，哥德巴赫猜想</h3><p><a href="https://ac.nowcoder.com/acm/contest/57357/H">H-Until the Blue Moon Rises_2023牛客暑期多校训练营3 (nowcoder.com)</a></p><h3 id="4-5（待补，生成函数"><a href="#4-5（待补，生成函数" class="headerlink" title="4.5（待补，生成函数"></a>4.5（待补，生成函数</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7328">Problem - 7328 (hdu.edu.cn)</a></p><h3 id="4-6（待补"><a href="#4-6（待补" class="headerlink" title="4.6（待补"></a>4.6（待补</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7325">Problem - 7325 (hdu.edu.cn)</a></p><h3 id="4-7（待补，难"><a href="#4-7（待补，难" class="headerlink" title="4.7（待补，难"></a>4.7（待补，难</h3><p><a href="https://ac.nowcoder.com/acm/contest/57359/I">I-The Yakumo Family_2023牛客暑期多校训练营5 (nowcoder.com)</a></p><h3 id="4-8-组合数，范德蒙卷积优化"><a href="#4-8-组合数，范德蒙卷积优化" class="headerlink" title="4.8 组合数，范德蒙卷积优化"></a>4.8 组合数，范德蒙卷积优化</h3><p><a href="https://ac.nowcoder.com/acm/contest/57360/B">B-Distance_2023牛客暑期多校训练营6 (nowcoder.com)</a></p><p>每次看si和tj的贡献，左边和右边随便选，用范德蒙卷积优化</p><p>范德蒙卷积：</p><p><a href="https://www.luogu.com.cn/blog/nofind/fan-de-meng-de-juan-ji">范德蒙德卷积 - nofind 的博客 - 洛谷博客 (luogu.com.cn)</a></p><img src="C:\Users\30279\Desktop\个人acm题解\比赛记录\范德蒙卷积.png" alt="范德蒙卷积" style="zoom:80%;" /><h3 id="4-9乘积、因子"><a href="#4-9乘积、因子" class="headerlink" title="4.9乘积、因子"></a>4.9乘积、因子</h3><p><a href="https://ac.nowcoder.com/acm/contest/57360/C">C-idol!!_2023牛客暑期多校训练营6 (nowcoder.com)</a></p><p>乘积、二进制有关的题，往往要分解，乘积往往和因子有关，二进制往往和每一位有关</p><p>乘积来自于5，所以和5的个数有关</p><h3 id="4-10完全平方数的相关规律"><a href="#4-10完全平方数的相关规律" class="headerlink" title="4.10完全平方数的相关规律"></a>4.10完全平方数的相关规律</h3><ul><li>完全平方数差的规律：</li></ul><p>总结：</p><p>（1）3及3以上的所有奇数都可以表示为两个平方数的差。</p><p>（2）8及8以上所有4k形式的偶数都可以表示为两个不同平方数的差。</p><p>（3）除(1)和(2)以外的其他正整数都不可能表示成两平方数的差。</p><ul><li>完全平方数和的规律：</li></ul><p> 说明每个<a href="https://baike.baidu.com/item/%E6%AD%A3%E6%95%B4%E6%95%B0/8461335?fromModule=lemma_inlink">正整数</a>均可表示为4个整数的平方和。</p><p>任何一个数都可以由《&#x3D;4个完全平方数加和得到，代码为sqrt(n)的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 判断是否为完全平方数</span><br><span class="line">   bool isPerfectSquare(int x) &#123;</span><br><span class="line">       int y = sqrt(x);</span><br><span class="line">       return y * y == x;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 判断是否能表示为 4^k*(8m+7)</span><br><span class="line">   bool checkAnswer4(int x) &#123;</span><br><span class="line">       while (x % 4 == 0) &#123;</span><br><span class="line">           x /= 4;</span><br><span class="line">       &#125;</span><br><span class="line">       return x % 8 == 7;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   int numSquares(int n) &#123;</span><br><span class="line">       if (isPerfectSquare(n)) &#123;</span><br><span class="line">           return 1;</span><br><span class="line">       &#125;</span><br><span class="line">       if (checkAnswer4(n)) &#123;</span><br><span class="line">           return 4;</span><br><span class="line">       &#125;</span><br><span class="line">       for (int i = 1; i * i &lt;= n; i++) &#123;</span><br><span class="line">           int j = n - i * i;</span><br><span class="line">           if (isPerfectSquare(j)) &#123;</span><br><span class="line">               return 2;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return 3;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-11-鞅的停时定理，完全随机事件的概率"><a href="#4-11-鞅的停时定理，完全随机事件的概率" class="headerlink" title="4.11 鞅的停时定理，完全随机事件的概率"></a>4.11 鞅的停时定理，完全随机事件的概率</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7378">Problem - 7378 (hdu.edu.cn)</a></p><p>当成模型吧，</p><p>题意：每次随机选两组，互相交换一个，直到只有一组拥有全部</p><p>方法：累乘累加前缀和优化</p><h3 id="4-12-推公式，或者猜结论"><a href="#4-12-推公式，或者猜结论" class="headerlink" title="4.12 推公式，或者猜结论"></a>4.12 推公式，或者猜结论</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7385">Problem - 7385 (hdu.edu.cn)</a></p><p>（n个根）* （（n-1）！个树形 ）*（π(i从2到n)（min(i-1,k)）如何选择互不影响的前导节点）</p><h3 id="4-13-二进制异或和、推导规律，模拟"><a href="#4-13-二进制异或和、推导规律，模拟" class="headerlink" title="4.13 二进制异或和、推导规律，模拟"></a>4.13 二进制异或和、推导规律，模拟</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7390">Problem - 7390 (hdu.edu.cn)</a></p><p>样例造的越合适越容易发现规律</p><p>这个标程其实在反向模拟异或和的过程，每次选最小，每次看组合，而且题意有按顺序选最小的提示。</p><h3 id="4-14-期望、模拟打表找规律（模拟的部分有点问题"><a href="#4-14-期望、模拟打表找规律（模拟的部分有点问题" class="headerlink" title="4.14  期望、模拟打表找规律（模拟的部分有点问题"></a>4.14  期望、模拟打表找规律（模拟的部分有点问题</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7386">Problem - 7386 (hdu.edu.cn)</a></p><p>模拟打出表之后规律很明显</p><h2 id="五、公式、规律、贪心"><a href="#五、公式、规律、贪心" class="headerlink" title="五、公式、规律、贪心"></a>五、公式、规律、贪心</h2><h3 id="5-1结论推导"><a href="#5-1结论推导" class="headerlink" title="5.1结论推导"></a>5.1结论推导</h3><p><a href="https://ac.nowcoder.com/acm/contest/57355/H">H-Matches_“范式杯”2023牛客暑期多校训练营1 (nowcoder.com)</a></p><h3 id="5-2-结论（找规律，贪心、排序题"><a href="#5-2-结论（找规律，贪心、排序题" class="headerlink" title="5.2  结论（找规律，贪心、排序题"></a>5.2  结论（找规律，贪心、排序题</h3><p><a href="https://ac.nowcoder.com/acm/contest/57356/D">D-The Game of Eating_2023牛客暑期多校训练营2 (nowcoder.com)</a></p><h3 id="5-3结论、分类讨论（不完全懂，二分图博弈结论（网络流））"><a href="#5-3结论、分类讨论（不完全懂，二分图博弈结论（网络流））" class="headerlink" title="5.3结论、分类讨论（不完全懂，二分图博弈结论（网络流））"></a>5.3结论、分类讨论（不完全懂，二分图博弈结论（网络流））</h3><p><a href="https://ac.nowcoder.com/acm/contest/57356/F">F-Link with Chess Game_2023牛客暑期多校训练营2 (nowcoder.com)</a></p><h3 id="5-4前缀和，位运算，翻转-1操作"><a href="#5-4前缀和，位运算，翻转-1操作" class="headerlink" title="5.4前缀和，位运算，翻转+1操作"></a>5.4前缀和，位运算，翻转+1操作</h3><p><a href="https://ac.nowcoder.com/acm/contest/57356/H">H-0 and 1 in BIT_2023牛客暑期多校训练营2 (nowcoder.com)</a></p><h3 id="5-5矩阵，二进制，找规律"><a href="#5-5矩阵，二进制，找规律" class="headerlink" title="5.5矩阵，二进制，找规律"></a>5.5矩阵，二进制，找规律</h3><p><a href="https://ac.nowcoder.com/acm/contest/57357/D">D-Ama no Jaku_2023牛客暑期多校训练营3 (nowcoder.com)</a></p><h3 id="5-6构造，签到，实际上是个模拟，不是那种粗暴的规则"><a href="#5-6构造，签到，实际上是个模拟，不是那种粗暴的规则" class="headerlink" title="5.6构造，签到，实际上是个模拟，不是那种粗暴的规则"></a>5.6构造，签到，实际上是个模拟，不是那种粗暴的规则</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7310">Problem - 7310 (hdu.edu.cn)</a></p><h3 id="5-7猜结论，全0或者全1，差个检验"><a href="#5-7猜结论，全0或者全1，差个检验" class="headerlink" title="5.7猜结论，全0或者全1，差个检验"></a>5.7猜结论，全0或者全1，差个检验</h3><p><a href="https://ac.nowcoder.com/acm/contest/57358/A">A-Bobo String Construction_2023牛客暑期多校训练营4 (nowcoder.com)</a></p><p>始终不对</p><p>1，方法错了</p><p>2，差个特判</p><h3 id="5-8（难，待补"><a href="#5-8（难，待补" class="headerlink" title="5.8（难，待补"></a>5.8（难，待补</h3><p><a href="https://ac.nowcoder.com/acm/contest/57359/B">B-Circle of Mistery_2023牛客暑期多校训练营5 (nowcoder.com)</a></p><h3 id="5-9优化、找规律，"><a href="#5-9优化、找规律，" class="headerlink" title="5.9优化、找规律，"></a>5.9优化、找规律，</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7341">Problem - 7341 (hdu.edu.cn)</a></p><p>需要找到数学规律，然后进行优化、暴力</p><h3 id="5-10vector-，找规律（待补"><a href="#5-10vector-，找规律（待补" class="headerlink" title="5.10vector ，找规律（待补"></a>5.10vector ，找规律（待补</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7338">Problem - 7338 (hdu.edu.cn)</a></p><h3 id="5-11-构造，规律，二分"><a href="#5-11-构造，规律，二分" class="headerlink" title="5.11 构造，规律，二分"></a>5.11 构造，规律，二分</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7350">Problem - 7350 (hdu.edu.cn)</a></p><p>反向构造，若答案是B则可以构造出B个1 3 之后加2 2 ，这是2的个数应该小于等于上限B</p><p>根据这个规律，二分查找答案</p><h3 id="5-12-逆序对"><a href="#5-12-逆序对" class="headerlink" title="5.12 逆序对"></a>5.12 逆序对</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7359">Problem - 7359 (hdu.edu.cn)</a></p><p>每个数都和自己原来的位置有关，再加上反转的规律，自然想到逆序对</p><h3 id="5-13利用逆序对反向构造全排列，"><a href="#5-13利用逆序对反向构造全排列，" class="headerlink" title="5.13利用逆序对反向构造全排列，"></a>5.13利用逆序对反向构造全排列，</h3><p><a href="https://ac.nowcoder.com/acm/contest/57359/E">E-Red and Blue and Green_2023牛客暑期多校训练营5 (nowcoder.com)</a></p><h3 id="5-14-构造题，dfs（待补，有个公式死住了"><a href="#5-14-构造题，dfs（待补，有个公式死住了" class="headerlink" title="5.14 构造题，dfs（待补，有个公式死住了"></a>5.14 构造题，dfs（待补，有个公式死住了</h3><p><a href="https://ac.nowcoder.com/acm/contest/57358/H">H-Merge the squares!_2023牛客暑期多校训练营4 (nowcoder.com)</a></p><p><a href="https://ac.nowcoder.com/acm/contest/view-submission?submissionId=63092924">代码查看 (nowcoder.com)</a></p><h3 id="5-15找规律，双指针模拟"><a href="#5-15找规律，双指针模拟" class="headerlink" title="5.15找规律，双指针模拟"></a>5.15找规律，双指针模拟</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7365">Problem - 7365 (hdu.edu.cn)</a></p><p>01**10这种的破解方法在于如果有连续的0那么0就有办法赢，否则如果只有一个11那么平局（没有连续的也行），或者有多个11那么1赢，对于10 * * 10也是同一个道理</p><h3 id="5-16-构造，根据一些模式构造"><a href="#5-16-构造，根据一些模式构造" class="headerlink" title="5.16 构造，根据一些模式构造"></a>5.16 构造，根据一些模式构造</h3><p><a href="https://ac.nowcoder.com/acm/contest/57362/J">J-Permutation and Primes_2023牛客暑期多校训练营8 (nowcoder.com)</a></p><p>给出10个长度的固定模式，然后根据其差值关系来构造</p><h3 id="5-17-利用栈相关stl进行处理的规律题"><a href="#5-17-利用栈相关stl进行处理的规律题" class="headerlink" title="5.17 利用栈相关stl进行处理的规律题"></a>5.17 利用栈相关stl进行处理的规律题</h3><p><a href="https://ac.nowcoder.com/acm/contest/57362/H">H-Insert 1, Insert 2, Insert 3, …_2023牛客暑期多校训练营8 (nowcoder.com)</a></p><h3 id="5-18-双指针、前缀和优化"><a href="#5-18-双指针、前缀和优化" class="headerlink" title="5.18 双指针、前缀和优化"></a>5.18 双指针、前缀和优化</h3><p><a href="https://ac.nowcoder.com/acm/contest/57363/D">D-Non-Puzzle: Error Permutation_2023牛客暑期多校训练营9 (nowcoder.com)</a></p><p>虽然是区间第k小但是没有用到主席树，反而是个贪心思维优化的题</p><p>以每个ai为中心，如果他是对应区间第i位第i小，那么所有涉及的区间全部消失</p><p>最后记录没有被消灭的区间</p><h3 id="5-19-前缀和优化，扫描线，思维贪心"><a href="#5-19-前缀和优化，扫描线，思维贪心" class="headerlink" title="5.19 前缀和优化，扫描线，思维贪心"></a>5.19 前缀和优化，扫描线，思维贪心</h3><p><a href="https://ac.nowcoder.com/acm/contest/57363/I">I-Non-Puzzle: Segment Pair_2023牛客暑期多校训练营9 (nowcoder.com)</a></p><p>前缀和优化是个很重要的知识点</p><p>一维前缀和先算全部，然后减去重复的x-1的位置</p><h3 id="5-20-图上，猜公式相关内容，（没太理解"><a href="#5-20-图上，猜公式相关内容，（没太理解" class="headerlink" title="5.20 图上，猜公式相关内容，（没太理解"></a>5.20 图上，猜公式相关内容，（没太理解</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7382">Problem - 7382 (hdu.edu.cn)</a></p><h2 id="六、树-数据结构"><a href="#六、树-数据结构" class="headerlink" title="六、树+数据结构"></a>六、树+数据结构</h2><h3 id="6-1、数学转化为树，gcd，构造压缩"><a href="#6-1、数学转化为树，gcd，构造压缩" class="headerlink" title="6.1、数学转化为树，gcd，构造压缩"></a>6.1、数学转化为树，gcd，构造压缩</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7311">Problem - 7311 (hdu.edu.cn)</a></p><p>compare函数的书写是难点，i+1和i+2还需要深入观察</p><h3 id="6-2树状数组（待补"><a href="#6-2树状数组（待补" class="headerlink" title="6.2树状数组（待补"></a>6.2树状数组（待补</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7337">Problem - 7337 (hdu.edu.cn)</a></p><h3 id="6-3点分治，dsu（待补"><a href="#6-3点分治，dsu（待补" class="headerlink" title="6.3点分治，dsu（待补"></a>6.3点分治，dsu（待补</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7339">Problem - 7339 (hdu.edu.cn)</a></p><h3 id="6-4记忆化搜索，hashmap记录处理（unordered-map）"><a href="#6-4记忆化搜索，hashmap记录处理（unordered-map）" class="headerlink" title="6.4记忆化搜索，hashmap记录处理（unordered_map）"></a>6.4记忆化搜索，hashmap记录处理（unordered_map）</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7372">Problem - 7372 (hdu.edu.cn)</a></p><h2 id="七、字符串"><a href="#七、字符串" class="headerlink" title="七、字符串"></a>七、字符串</h2><h3 id="7-1马拉车算法、dp、结论"><a href="#7-1马拉车算法、dp、结论" class="headerlink" title="7.1马拉车算法、dp、结论"></a>7.1马拉车算法、dp、结论</h3><p><a href="https://ac.nowcoder.com/acm/contest/57356/G">G-Link with Centrally Symmetric Strings_2023牛客暑期多校训练营2 (nowcoder.com)</a></p><p>能形成中心对称的串，就记录下来是可行的，外层是马拉车的板子</p><p>里边有点区别，初始化不存在的时候是0，而不是1（有点问题</p><p>考虑一个结论：每次左边界小于当前start的时候就更新start为右边界，i跳到右边界继续，从而节省复杂度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(p[i]&gt;1&amp;&amp;i-p[i]+1&lt;=start)&#123;</span><br><span class="line">b[i+p[i]-2] = &#x27;$&#x27;;</span><br><span class="line">start = i+p[i]-1;</span><br><span class="line">i = i+p[i]-2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2马拉车，线段树优化（差点，没补完"><a href="#7-2马拉车，线段树优化（差点，没补完" class="headerlink" title="7.2马拉车，线段树优化（差点，没补完"></a>7.2马拉车，线段树优化（差点，没补完</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7326">Problem - 7326 (hdu.edu.cn)</a></p><h3 id="7-3（待补"><a href="#7-3（待补" class="headerlink" title="7.3（待补"></a>7.3（待补</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7366">Problem - 7366 (hdu.edu.cn)</a></p><h3 id="7-4（待补"><a href="#7-4（待补" class="headerlink" title="7.4（待补"></a>7.4（待补</h3><p><a href="https://ac.nowcoder.com/acm/contest/57362/I">I-Make It Square_2023牛客暑期多校训练营8 (nowcoder.com)</a></p><h3 id="7-5（待补"><a href="#7-5（待补" class="headerlink" title="7.5（待补"></a>7.5（待补</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7391">Problem - 7391 (hdu.edu.cn)</a></p><h2 id="八、计算几何"><a href="#八、计算几何" class="headerlink" title="八、计算几何"></a>八、计算几何</h2><h3 id="8-1-注意精度和常数"><a href="#8-1-注意精度和常数" class="headerlink" title="8.1 注意精度和常数"></a>8.1 注意精度和常数</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7324">Problem - 7324 (hdu.edu.cn)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划题</title>
      <link href="/2024/05/02/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%A2%98/"/>
      <url>/2024/05/02/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h1><p>dp的一个特点就是书写递归方程。</p><p>dp其实强调对于集合的划分，策略的安排</p><h2 id="一、整数分块-dp暴力"><a href="#一、整数分块-dp暴力" class="headerlink" title="一、整数分块+dp暴力"></a>一、整数分块+dp暴力</h2><p><a href="https://codeforces.com/gym/104095/problem/B">Problem - B - Codeforces</a></p><p>先开始要找到可以可以转移的人数</p><p>然后开两个数组，pre   和  now    ，表示一定体重下的最大价值，</p><p>最后暴力dp</p><p><img src="C:\Users\30279\AppData\Roaming\Typora\typora-user-images\image-20230212134053435.png" alt="image-20230212134053435"></p><h2 id="二、dp，trie树"><a href="#二、dp，trie树" class="headerlink" title="二、dp，trie树"></a>二、dp，trie树</h2><p><a href="https://codeforces.com/gym/104081/problem/I">Problem - I - Codeforces</a></p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>trie树预处理子串，可以从1或者0开始，建议从1，end可以标记是否是完整串，cnt可以标记子串出现次数，也可以返回层数，或者长度，</p><p>dp[flag] [i]意思是：a或者b在i的位置所需要的最小值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(tt[j].end[p])&#123;</span><br><span class="line">     dp[j][k]=min(dp[!j][i-1]+1,dp[j][k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dfs会超时，dp不会，而且更清楚</p><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>trie树和dp的结合</p><h2 id="三、dp三维背包，滚动数组"><a href="#三、dp三维背包，滚动数组" class="headerlink" title="三、dp三维背包，滚动数组"></a>三、dp三维背包，滚动数组</h2><p><a href="https://codeforces.com/group/Aokqa6Haao/contest/427952/problem/E">Problem - E - Codeforces</a></p><h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><p>这个题是dp</p><p>开始只是暴力所有的情况，很好地利用容量这个问题，最后处理答案，</p><p>有的值的综合减去当前量的总和的一半才是补充的量，最后暴力选择的时候，别超当前容量</p><h3 id="注意：-1"><a href="#注意：-1" class="headerlink" title="注意："></a>注意：</h3><p>输入的方式和数组大小</p><h2 id="四、dp，滚动数组，用multiset动态维护可行的位置更新"><a href="#四、dp，滚动数组，用multiset动态维护可行的位置更新" class="headerlink" title="四、dp，滚动数组，用multiset动态维护可行的位置更新"></a>四、dp，滚动数组，用multiset动态维护可行的位置更新</h2><p><a href="https://codeforces.com/group/Aokqa6Haao/contest/427952/problem/F">Problem - F - Codeforces</a></p><h3 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h3><p>dp[i] [j]表示第i道主菜，第j个菜被用，花费最小</p><p>但是你需要动态的维护需要更新的节点，先删除不可以走的，然后更新dp，选最小的前边的那个，然后添加回之前的</p><p>需要multiset动态维护、记录更新</p><h3 id="注意：-2"><a href="#注意：-2" class="headerlink" title="注意："></a>注意：</h3><p>跟题目的下标含义要一致</p><h2 id="五、dp，滚动数组，"><a href="#五、dp，滚动数组，" class="headerlink" title="五、dp，滚动数组，"></a>五、dp，滚动数组，</h2><p><a href="https://codeforces.com/group/Aokqa6Haao/contest/428602/problem/A">Problem - A - Codeforces</a></p><p>（纯粹暴力很难，但是具备一定规律，这题开始误认为是组合数学，其实不是，因为规律在于过程和递推方程上）</p><h3 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h3><p>开始，dp[i] [j] [p] [q]这么设状态，空间上不允许</p><p>之后，dp[2] [j] [p]这样用滚动数组优化一下，空间上是可以的，0表示之前的状态，1表示现在的状态，j表示列，p表示拥有0的个数，（总数为n+m-1，所以q也就知道了），整体表示情况数</p><h3 id="注意：-3"><a href="#注意：-3" class="headerlink" title="注意："></a>注意：</h3><p>初始化dp[1] [1] [k]的时候要注意a[1] [1]的情况</p><p>还有一个就是i&#x3D;&#x3D;1&amp;&amp;j&#x3D;&#x3D;1特判</p><p>a[i] [j]&#x3D;&#x3D;0是，dp[1] [j] [0]&#x3D;0;此时没有0的情况不成立</p><h2 id="六、dp-汉诺塔问题，待理解"><a href="#六、dp-汉诺塔问题，待理解" class="headerlink" title="六、dp,汉诺塔问题，待理解"></a>六、dp,汉诺塔问题，待理解</h2><p><a href="https://codeforces.com/group/Aokqa6Haao/contest/428602/problem/F">Problem - F - Codeforces</a></p><h3 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h3><p>本身套用三汉诺塔问题的递推方程，ans表示答案，预处理，并且在处理过程中有一个类似最短路径的处理</p><h2 id="七、dp背包，"><a href="#七、dp背包，" class="headerlink" title="七、dp背包，"></a>七、dp背包，</h2><p><a href="https://codeforces.com/group/Aokqa6Haao/contest/432112">Dashboard - CUSTACM 2023 Training 1 - Codeforces</a></p><h3 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h3><p>   但是有个区间的压缩，r[i]记录这个i的位置的最右区间，然后常规dp</p><p>  一维遍历前i的位置，二维遍历选几个区间，内部选和不选，</p><p>选的话 从i-1的位置进入，j-1的位置再选，</p><p>不选的话，从i-1的位置到现在的位置，每次选最大，最后dp【n】【k】即是最后的答案</p><h2 id="八、dp，欧拉筛，线性组合，01背包变形"><a href="#八、dp，欧拉筛，线性组合，01背包变形" class="headerlink" title="八、dp，欧拉筛，线性组合，01背包变形"></a>八、dp，欧拉筛，线性组合，01背包变形</h2><p><a href="https://codeforces.com/contest/1794/problem/D">Problem - D - Codeforces</a></p><h3 id="思路：-6"><a href="#思路：-6" class="headerlink" title="思路："></a>思路：</h3><p>首先预处理fac（mod意义下的前缀积），facinv(前缀积的逆元),预处理欧拉筛</p><p>之后，dp[i] [j]表示前i种质数，选择j种的所有可以的情况的facinv</p><p>最后fac(n)* （所有非质数的全排列的逆元） %mod *dp[cnt] [n]%mod;表示在所有数中选n个不同的质数的全部情况</p><h2 id="九、dp暴力或者贪心都行"><a href="#九、dp暴力或者贪心都行" class="headerlink" title="九、dp暴力或者贪心都行"></a>九、dp暴力或者贪心都行</h2><p><a href="https://codeforces.com/contest/1809/problem/D">Problem - D - Codeforces</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>dp[i] [3]表示到i位置不同情况的集合</p><p>集合划分：</p><p>当前是1：</p><p>前边是1、0或者直接转移，或者删除当前</p><p>当前是0：</p><p>前边是1、0或者删除当前</p><p>最后取最小</p><h2 id="十、多种方法，dp"><a href="#十、多种方法，dp" class="headerlink" title="十、多种方法，dp"></a>十、多种方法，dp</h2><p><a href="https://codeforces.com/gym/104252/problem/E">Problem - E - Codeforces</a></p><h3 id="思路：-7"><a href="#思路：-7" class="headerlink" title="思路："></a>思路：</h3><p>开二维数组</p><p>状态表示：反向开设，dp[ i ] [ j ]指的是左边i和右边j块是否覆盖，</p><p>集合划分：暴力所有块数，不到O（n^3），如果len长度可以就给左边或者右边,维数一个变一个不变，相当于只用一次</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">1</span>;len&lt;=n+<span class="number">1</span>;++len)&#123;</span><br><span class="line"><span class="keyword">if</span>(len==k)<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=l;j&gt;=<span class="number">0</span>;--j)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> z=r;z&gt;=<span class="number">0</span>;--z)&#123;</span><br><span class="line"><span class="keyword">if</span>(len&lt;=j)dp[j][z]|=dp[j-len][z];<span class="comment">//维数一个变一个不变，相当于只用一次</span></span><br><span class="line"><span class="keyword">if</span>(len&lt;=z)dp[j][z]|=dp[j][z-len];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十一、记忆化搜索，树上"><a href="#十一、记忆化搜索，树上" class="headerlink" title="十一、记忆化搜索，树上"></a>十一、记忆化搜索，树上</h2><p><a href="https://codeforces.com/contest/1806/problem/E">Problem - E - Codeforces</a></p><h3 id="思路：-8"><a href="#思路：-8" class="headerlink" title="思路："></a>思路：</h3><p>因为空间开不了2个1e5，所以有个编号cnt，但是cnt《&#x3D;320的时候才记录或者返回，（不太清楚</p><p>记忆化搜索：截止的地方–返回数组–深搜–回溯更新dp数组，这个320还没法处理掉，也就是说一定得推导出320这个边界。</p><h2 id="十二、换根dp（树上的"><a href="#十二、换根dp（树上的" class="headerlink" title="十二、换根dp（树上的"></a>十二、换根dp（树上的</h2><p><a href="https://codeforces.com/contest/1805/problem/D">Problem - D - Codeforces</a></p><h3 id="思路：-9"><a href="#思路：-9" class="headerlink" title="思路："></a>思路：</h3><p> <a href="..%5C%E7%9F%A5%E8%AF%86%E9%9B%86%5C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.md">动态规划.md</a> </p><h2 id="十三、dp，自动取模"><a href="#十三、dp，自动取模" class="headerlink" title="十三、dp，自动取模"></a>十三、dp，自动取模</h2><p><a href="https://codeforces.com/contest/1811/problem/G2">Problem - G2 - Codeforces</a></p><h3 id="思路：-10"><a href="#思路：-10" class="headerlink" title="思路："></a>思路：</h3><p>题意：每一块同颜色，最大块数的前提下最多数量</p><p>策略：明显的是dp但是需要优化，sum记录每一块的最大数量，注意每块（同块内颜色一致）和每块边界的处理</p><p>（可以有不同的颜色，所以重新累加</p><p>状态:dp[i ] [j ]          i表示最后的位置（右边界），j表示颜色，        一维位置，一维颜色      问题的解决决定状态和划分</p><p>划分：分块，处理块间和块中。</p><p>注意：一定注意数组初始化，不初始化数组的话，会混乱掉的。</p><h2 id="十四、线性dp"><a href="#十四、线性dp" class="headerlink" title="十四、线性dp"></a>十四、线性dp</h2><p><a href="https://www.luogu.com.cn/problem/P1280">P1280 尼克的任务 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><h3 id="思路：-11"><a href="#思路：-11" class="headerlink" title="思路："></a>思路：</h3><p>题意：最长空闲时间的选择</p><p>策略：</p><p>dp[i]最大休闲时间，正着走会受到后续的影响，所以倒着走</p><p>用sum记录当前点开始的个数，</p><p>集合划分：</p><p>sum&#x3D;&#x3D;0时，空闲时间+1</p><p>sum！&#x3D;-时，num表示应该运行第几个任务了，然后将长空闲时间转移到当前位置。</p><h2 id="十五、区间dp或者树形dp"><a href="#十五、区间dp或者树形dp" class="headerlink" title="十五、区间dp或者树形dp"></a>十五、区间dp或者树形dp</h2><p>[P1040 <a href="https://www.luogu.com.cn/problem/P1040">NOIP2003 提高组] 加分二叉树 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><h3 id="思路：-12"><a href="#思路：-12" class="headerlink" title="思路："></a>思路：</h3><p>dp是用来处理可重叠问题的，并且具有处理过的状态不会再影响后续状态的特点</p><p>  <strong>题意</strong>：给出二叉树中序遍历的结果，个人感觉是在固定左右关系</p><p>  <strong>策略</strong>：区间dp，分堆类型，并且用root记录根节点，最后前序遍历，要学习这种路径的记载（状态更新的时候，记录更新后的节点，更新后的路径</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r)<span class="keyword">return</span> ;</span><br><span class="line">    cout&lt;&lt;root[l][r]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">print</span>(l,root[l][r]<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">print</span>(root[l][r]+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//30个节点</span></span><br><span class="line">    <span class="comment">//题意：给出二叉树中序遍历的结果，个人感觉是在固定左右关系</span></span><br><span class="line">    <span class="comment">//策略：区间dp，分堆类型，并且用root记录根节点，最后前序遍历</span></span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        cin&gt;&gt;dp[i][i];</span><br><span class="line">        dp[i][i<span class="number">-1</span>]=<span class="number">1</span>;<span class="comment">//左子树应该默认为空，因为这个节点最大</span></span><br><span class="line">        root[i][i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">1</span>;len&lt;=n;++len)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l+len&lt;=n;++l)&#123;</span><br><span class="line">            <span class="type">int</span> r=l+len;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=l;k&lt;r;++k)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[l][r]&lt;dp[l][k<span class="number">-1</span>]*dp[k+<span class="number">1</span>][r]+dp[k][k])&#123;</span><br><span class="line">                    dp[l][r]=dp[l][k<span class="number">-1</span>]*dp[k+<span class="number">1</span>][r]+dp[k][k];</span><br><span class="line">                    root[l][r]=k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[<span class="number">1</span>][n]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>,n);</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h2 id="十六、线性dp"><a href="#十六、线性dp" class="headerlink" title="十六、线性dp"></a>十六、线性dp</h2><p><a href="https://www.luogu.com.cn/problem/P4933">P4933 大师 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><h3 id="思路：-13"><a href="#思路：-13" class="headerlink" title="思路："></a>思路：</h3><p>如何记载子序列不全为空且有次序可缺项的情况的总合，1 2 3  4  ans +1 +2 +3 +4           +1  +1  +1  +1</p><p>题意：子序列构成等差数列的情况的个数，</p><p>策略：线性dp，dp[i ] [ j ]表示以i为结尾，j为公差的情况数     ans记录总合，但是单个次序的记录的方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> h[maxj];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">1100</span>][<span class="number">40010</span>];<span class="comment">//以i为结尾，以j为公差，总共的个数，重复子问题递推的求解。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//n的个数支持立方的操作。</span></span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        cin&gt;&gt;h[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">20000</span>;</span><br><span class="line">    <span class="comment">//转移，集合划分错了，排列组合，逐个求解可以表达所有可能,也就是说  +1 +2 +3 逐个加可以</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        ans++;<span class="comment">//作为单个出现的时候</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=i<span class="number">-1</span>;l&gt;=<span class="number">1</span>;--l)&#123;<span class="comment">//01背包</span></span><br><span class="line">            dp[i][h[i]-h[l]+p]+=dp[l][h[i]-h[l]+p]+<span class="number">1</span>;<span class="comment">//公差可能重复所以需要累加</span></span><br><span class="line">            dp[i][h[i]-h[l]+p]%=mod;</span><br><span class="line">            ans+=dp[l][h[i]-h[l]+p]+<span class="number">1</span>;</span><br><span class="line">            ans%=mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h2 id="十七、线性dp"><a href="#十七、线性dp" class="headerlink" title="十七、线性dp"></a>十七、线性dp</h2><p><a href="https://codeforces.com/group/QJA47ykHfD/contest/437692/problem/E">Problem - E - Codeforces</a></p><p><strong>题意：</strong> 每次只移动左手或者右手，使得成本最小</p><p><strong>策略：</strong> 线性dp，</p><p><strong>集合表示：</strong>dp[ flag ] [ i ] [ j ]  ，一维表示到哪里了，（因为只有i和i-1，所以可以压缩） ，i表示左手哪个位置，j表示右手那个位置。</p><p><strong>集合处理：</strong>预处理距离，初始化dp数组，第一层暴力到那个音符，第二层初始化下个flag  and  左手走（左手和右手都从0到8暴力，并且左手产生新的贡献）  and  右手走（左手和右手都从0到8暴力，并且右手产生新的贡献）</p><p><strong>集合划分：</strong> 左手和右手分别暴力转移。</p><p>因为手放的点数很少，所以可以作为一维，</p><h2 id="十八、01背包"><a href="#十八、01背包" class="headerlink" title="十八、01背包"></a>十八、01背包</h2><p><a href="https://ac.nowcoder.com/acm/contest/57225/G">G-Chevonne’s Necklace_“统信杯” 第十七届黑龙江省大学生程序设计竞赛（正式赛）（重现赛）@yxh03 (nowcoder.com)</a></p><p>不太好想，对赌状态互不影响，对于状态方程而言，确实也是互不影响</p><p>然后用01背包去做，体积上的累加。</p><h2 id="十九、换根dp（未完"><a href="#十九、换根dp（未完" class="headerlink" title="十九、换根dp（未完"></a>十九、换根dp（未完</h2><h2 id="二十、单调队列结合dp"><a href="#二十、单调队列结合dp" class="headerlink" title="二十、单调队列结合dp"></a>二十、单调队列结合dp</h2><p><a href="https://codeforces.com/contest/940/problem/E">Problem - E - Codeforces</a></p><h3 id="思路：-14"><a href="#思路：-14" class="headerlink" title="思路："></a>思路：</h3><p>题意：给定意义下最小和</p><p>  策略：单调队列优化dp，维护单调递减队列</p><p>尽可能细分，尽可能多删，少加大的,多删一点</p><p> 开始c长度区间无法区别，之后c区间的每个可以进行选择</p><h2 id="二十一、dp、拓扑序"><a href="#二十一、dp、拓扑序" class="headerlink" title="二十一、dp、拓扑序"></a>二十一、dp、拓扑序</h2><p><a href="https://codeforces.com/contest/1863/problem/E">https://codeforces.com/contest/1863/problem/E</a></p><h2 id="二十二、dp、一个位置有一种情况"><a href="#二十二、dp、一个位置有一种情况" class="headerlink" title="二十二、dp、一个位置有一种情况"></a>二十二、dp、一个位置有一种情况</h2><p><a href="https://codeforces.com/contest/1875/problem/D">Problem - D - Codeforces</a></p><h2 id="二十三、状压dp-记忆化搜索"><a href="#二十三、状压dp-记忆化搜索" class="headerlink" title="二十三、状压dp+记忆化搜索"></a>二十三、状压dp+记忆化搜索</h2><p><a href="https://codeforces.com/gym/104023/problem/D">Problem - D - Codeforces</a></p><h2 id="二十四、dp"><a href="#二十四、dp" class="headerlink" title="二十四、dp"></a>二十四、dp</h2><p><a href="https://codeforces.com/gym/104022/problem/B">https://codeforces.com/gym/104022/problem/B</a></p><h2 id="二十五、换根dp"><a href="#二十五、换根dp" class="headerlink" title="二十五、换根dp"></a>二十五、换根dp</h2><p><a href="https://codeforces.com/contest/1882/problem/D">https://codeforces.com/contest/1882/problem/D</a></p><h2 id="二十六、换根dp"><a href="#二十六、换根dp" class="headerlink" title="二十六、换根dp"></a>二十六、换根dp</h2><p><a href="https://codeforces.com/gym/104008/problem/G">https://codeforces.com/gym/104008/problem/G</a></p><h2 id="二十七、dp"><a href="#二十七、dp" class="headerlink" title="二十七、dp"></a>二十七、dp</h2><p><a href="https://codeforces.com/gym/104128/problem/B">Problem - B - Codeforces</a></p><h2 id="二十八、树形dp"><a href="#二十八、树形dp" class="headerlink" title="二十八、树形dp"></a>二十八、树形dp</h2><p><a href="https://codeforces.com/contest/1929/problem/D">Problem - D - Codeforces</a></p><h2 id="二十九、四维dp"><a href="#二十九、四维dp" class="headerlink" title="二十九、四维dp"></a>二十九、四维dp</h2><p><a href="https://www.acwing.com/problem/content/description/1214/">1212. 地宫取宝 - AcWing题库</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dp[N][N][N][N];<span class="comment">// 四维dp，主要看影响因素和状态的转移</span></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,k;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;++j)&#123;</span><br><span class="line">            cin&gt;&gt;a[i][j];</span><br><span class="line">            a[i][j]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化，第一个元素拿或者不拿都有一种</span></span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>][a[<span class="number">1</span>][<span class="number">1</span>]]=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// dp[i][j][cnt][k]在i、j位置，要了cnt个，然后重量是k，因为这个值受四个状态影响</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;++j)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> cnt=<span class="number">0</span>;cnt&lt;=k;++cnt)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> kk=<span class="number">0</span>;kk&lt;<span class="number">15</span>;++kk)&#123;</span><br><span class="line">                    <span class="comment">// 这个位置不要，那么个数和值都可满足</span></span><br><span class="line">                    dp[i][j][cnt][kk]=(dp[i][j][cnt][kk]+dp[i<span class="number">-1</span>][j][cnt][kk])%MOD;</span><br><span class="line">                    dp[i][j][cnt][kk]=(dp[i][j][cnt][kk]+dp[i][j<span class="number">-1</span>][cnt][kk])%MOD;</span><br><span class="line">                    <span class="keyword">if</span>(cnt&gt;<span class="number">0</span>&amp;&amp;kk==a[i][j])&#123;</span><br><span class="line">                        <span class="comment">// 多一个需要对第四维大小进行操作</span></span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> ss=<span class="number">0</span>;ss&lt;kk;++ss)&#123; <span class="comment">// 从0开始，要是没有东西咋办</span></span><br><span class="line">                            dp[i][j][cnt][kk]=(dp[i][j][cnt][kk]+dp[i<span class="number">-1</span>][j][cnt<span class="number">-1</span>][ss])%MOD;</span><br><span class="line">                            dp[i][j][cnt][kk]=(dp[i][j][cnt][kk]+dp[i][j<span class="number">-1</span>][cnt<span class="number">-1</span>][ss])%MOD;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for(int i=)</span></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 累加所有可能最大重量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">15</span>;++i)&#123;</span><br><span class="line">        ans=(ans+dp[n][m][k][i])%MOD;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;dp[n][m][k][i]&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三十、单调队列优化dp"><a href="#三十、单调队列优化dp" class="headerlink" title="三十、单调队列优化dp"></a>三十、单调队列优化dp</h2><p>维护区间最值问题</p><p>问题难点：区间长度为d必须有一次跳跃，没办法逐一维护区间的每一个点</p><p>在可行范围内维护最小值，队列记录下标，队列原数组有序从小到大</p><p>注意下标和变量设置</p><p><a href="https://codeforces.com/contest/1941/problem/F">Problem - F - Codeforces</a></p><h2 id="三十一、线性dp，在两行中选择，有数量控制"><a href="#三十一、线性dp，在两行中选择，有数量控制" class="headerlink" title="三十一、线性dp，在两行中选择，有数量控制"></a>三十一、线性dp，在两行中选择，有数量控制</h2><p>问题在于：审错题了，名次在m以内就行，然后可以随便使用操作</p><p><a href="https://codeforces.com/contest/1945/problem/D">Problem - D - Codeforces</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 里边有个规则，可以任意使用操作包括次数</span></span><br><span class="line"><span class="comment">// a的可以随便取，b的前边需要有个a</span></span><br><span class="line"><span class="type">int</span> n,m;cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">cin&gt;&gt;b[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意审题和问题的转换</span></span><br><span class="line"><span class="comment">// 从后往前，只要前边有个a后边可以随便选</span></span><br><span class="line"><span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> ans=inf;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;--i)&#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;=m)&#123;</span><br><span class="line">ans=<span class="built_in">min</span>(ans,sum+a[i]);</span><br><span class="line">&#125;</span><br><span class="line">sum+=<span class="built_in">min</span>(a[i],b[i]);</span><br><span class="line">&#125; </span><br><span class="line">cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三十二、单调队列优化dp，二分"><a href="#三十二、单调队列优化dp，二分" class="headerlink" title="三十二、单调队列优化dp，二分"></a>三十二、单调队列优化dp，二分</h2><p><a href="https://codeforces.com/contest/1918/problem/D">Problem - D - Codeforces</a></p><h2 id="三十三、状压dp"><a href="#三十三、状压dp" class="headerlink" title="三十三、状压dp"></a>三十三、状压dp</h2><p><a href="https://www.acwing.com/problem/content/description/3497/">3494. 国际象棋 - AcWing题库</a></p><p>如何计算二进制中1的个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_count</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        ans++;</span><br><span class="line">        x-=x&amp;-x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对可以状压dp的一维进行状压dp，那些状态影响就要考虑几维</span></span><br><span class="line"><span class="type">int</span> dp[N][M][M][K];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_count</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        ans++;</span><br><span class="line">        x-=x&amp;-x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld %lld&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    <span class="comment">// cout&lt;&lt;get_count(3)&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="comment">// 状态是三列之间的转移，列行的概念不绝对</span></span><br><span class="line">        <span class="comment">// 从深到浅 b a c</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">0</span>;a&lt;(<span class="number">1</span>&lt;&lt;n);++a)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> b=<span class="number">0</span>;b&lt;(<span class="number">1</span>&lt;&lt;n);++b)&#123;</span><br><span class="line">                <span class="comment">// 有就不行所以没有&amp;1</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(((a&lt;&lt;<span class="number">2</span>)&amp;b)||((b&lt;&lt;<span class="number">2</span>)&amp;a))<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> c=<span class="number">0</span>;c&lt;(<span class="number">1</span>&lt;&lt;n);++c)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(((a&lt;&lt;<span class="number">2</span>)&amp;c)||((c&lt;&lt;<span class="number">2</span>)&amp;a))<span class="keyword">continue</span>;</span><br><span class="line">                    <span class="comment">// 这三层相互之间都有影响</span></span><br><span class="line">                    <span class="keyword">if</span>(((b&lt;&lt;<span class="number">1</span>)&amp;c)||((c&lt;&lt;<span class="number">1</span>&amp;b)))<span class="keyword">continue</span>;</span><br><span class="line">                    <span class="comment">// 从i-1转移到i</span></span><br><span class="line">                    <span class="type">int</span> t=<span class="built_in">get_count</span>(b);</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> kk=t;kk&lt;=k;++kk)&#123;</span><br><span class="line">                        <span class="comment">// 更新kk数量，代表上一层转移到当前层</span></span><br><span class="line">                        dp[i][a][b][kk]=(dp[i][a][b][kk]+dp[i<span class="number">-1</span>][c][a][kk-t])%MOD;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;n);++j)&#123;</span><br><span class="line">            <span class="comment">// 我的第一维是列</span></span><br><span class="line">            ans=(ans+dp[m][i][j][k])%MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三十四、状压dp，构造题，mex（待处理"><a href="#三十四、状压dp，构造题，mex（待处理" class="headerlink" title="三十四、状压dp，构造题，mex（待处理"></a>三十四、状压dp，构造题，mex（待处理</h2><p><a href="https://codeforces.com/contest/1956/problem/D">Problem - D - Codeforces</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lca</title>
      <link href="/2024/05/02/lca/"/>
      <url>/2024/05/02/lca/</url>
      
        <content type="html"><![CDATA[<h1 id="Lca"><a href="#Lca" class="headerlink" title="Lca"></a>Lca</h1><h2 id="知识："><a href="#知识：" class="headerlink" title="知识："></a>知识：</h2><p>基本概述：在树上求解最近公共祖先</p><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><p>向上标记法：O(n)很少用</p><h3 id="方法二：倍增"><a href="#方法二：倍增" class="headerlink" title="方法二：倍增"></a>方法二：倍增</h3><p>倍增：O(n*log(n))，在线</p><p>二进制拼凑：可以从高位到低位枚举二进制从而拼凑出任何一个数</p><h4 id="首先预处理："><a href="#首先预处理：" class="headerlink" title="首先预处理："></a>首先预处理：</h4><p>bfs(防止爆栈)或者dfs(求siz)</p><p>fa[i,j]表示从i节点开始，向上走2^j步，所能走到的节点，0&lt;&#x3D;j&lt;&#x3D;logn</p><p>dep[i]表示深度</p><h5 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h5><p>bfs</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(depth, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> depth);</span><br><span class="line">    depth[<span class="number">0</span>] = <span class="number">0</span>, depth[root] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>] = root;</span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++ ];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (depth[j] &gt; depth[t] + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                depth[j] = depth[t] + <span class="number">1</span>;</span><br><span class="line">                q[ ++ tt] = j;</span><br><span class="line">                fa[j][<span class="number">0</span>] = t;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">15</span>; k ++ )</span><br><span class="line">                    fa[j][k] = fa[fa[j][k - <span class="number">1</span>]][k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dfs</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lca是这类问题的核心，注意哨兵的作用 ,把1令成根 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> faa,<span class="type">int</span> de)</span></span>&#123;</span><br><span class="line">siz[u]=<span class="number">1</span>;</span><br><span class="line">dep[u]=de;</span><br><span class="line">fa[u][<span class="number">0</span>]=faa;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">20</span>;++j)&#123;</span><br><span class="line">fa[u][j]=fa[fa[u][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;g[u].<span class="built_in">size</span>();++i)&#123;</span><br><span class="line"><span class="type">int</span> v=g[u][i];</span><br><span class="line"><span class="keyword">if</span>(v==faa)<span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs</span>(v,u,de+<span class="number">1</span>);</span><br><span class="line">siz[u]+=siz[v];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><p>1）首先，让u成为深的一层，让两个点成为同一层</p><p>2）让两个点同时往上跳，一直跳到它们最近公共祖先的下一层，返回fa[u] [0];</p><h5 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (depth[a] &lt; depth[b]) <span class="built_in">swap</span>(a, b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">15</span>; k &gt;= <span class="number">0</span>; k -- )</span><br><span class="line">        <span class="keyword">if</span> (depth[fa[a][k]] &gt;= depth[b])</span><br><span class="line">            a = fa[a][k];</span><br><span class="line">    <span class="keyword">if</span> (a == b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">15</span>; k &gt;= <span class="number">0</span>; k -- )</span><br><span class="line">        <span class="keyword">if</span> (fa[a][k] != fa[b][k])</span><br><span class="line">        &#123;</span><br><span class="line">            a = fa[a][k];</span><br><span class="line">            b = fa[b][k];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[a][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法三："><a href="#方法三：" class="headerlink" title="方法三："></a>方法三：</h3><p> Tarjan:离线算法，线性O(n+m)</p><p>运用并查集</p><p>1）存入询问</p><p>2）搜索暴力</p><p>3）结果在于 正在搜索的 对应于 已经搜索过的点  的合并的点</p><p>分为三大类：</p><p>1、已经遍历过且回溯过的点，2</p><p>2、正在搜索的，1</p><p>3、还未搜索的，0</p><h2 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h2><h3 id="祖孙询问（方法二"><a href="#祖孙询问（方法二" class="headerlink" title="祖孙询问（方法二"></a>祖孙询问（方法二</h3><p><a href="https://www.acwing.com/problem/content/1174/">1172. 祖孙询问 - AcWing题库</a></p><p>板子题：</p><h4 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">40010</span>, M = N * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> depth[N], fa[N][<span class="number">16</span>];</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(depth, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> depth);</span><br><span class="line">    depth[<span class="number">0</span>] = <span class="number">0</span>, depth[root] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>] = root;</span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++ ];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (depth[j] &gt; depth[t] + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                depth[j] = depth[t] + <span class="number">1</span>;</span><br><span class="line">                q[ ++ tt] = j;</span><br><span class="line">                fa[j][<span class="number">0</span>] = t;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">15</span>; k ++ )</span><br><span class="line">                    fa[j][k] = fa[fa[j][k - <span class="number">1</span>]][k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (depth[a] &lt; depth[b]) <span class="built_in">swap</span>(a, b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">15</span>; k &gt;= <span class="number">0</span>; k -- )</span><br><span class="line">        <span class="keyword">if</span> (depth[fa[a][k]] &gt;= depth[b])</span><br><span class="line">            a = fa[a][k];</span><br><span class="line">    <span class="keyword">if</span> (a == b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">15</span>; k &gt;= <span class="number">0</span>; k -- )</span><br><span class="line">        <span class="keyword">if</span> (fa[a][k] != fa[b][k])</span><br><span class="line">        &#123;</span><br><span class="line">            a = fa[a][k];</span><br><span class="line">            b = fa[b][k];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[a][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="type">int</span> root = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">-1</span>) root = a;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">add</span>(a, b), <span class="built_in">add</span>(b, a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bfs</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="type">int</span> p = <span class="built_in">lca</span>(a, b);</span><br><span class="line">        <span class="keyword">if</span> (p == a) <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == b) <span class="built_in">puts</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="距离（方法三"><a href="#距离（方法三" class="headerlink" title="距离（方法三"></a>距离（方法三</h3><p><a href="https://www.acwing.com/problem/content/1173/">1171. 距离 - AcWing题库</a></p><p>两点的距离：两点到根节点的距离-2*lca到根节点的距离</p><h4 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>, M = N * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], w[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="type">int</span> res[M];</span><br><span class="line"><span class="type">int</span> st[N];</span><br><span class="line">vector&lt;PII&gt; query[N];   <span class="comment">// first存查询的另外一个点，second存查询编号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (j == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dist[j] = dist[u] + w[i];</span><br><span class="line">        <span class="built_in">dfs</span>(j, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="comment">//没有搜索和进行搜索回溯合并</span></span><br><span class="line">        <span class="keyword">if</span> (!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(j);</span><br><span class="line">            p[j] = u;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> item : query[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y = item.first, id = item.second;</span><br><span class="line">        <span class="keyword">if</span> (st[y] == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> anc = <span class="built_in">find</span>(y);</span><br><span class="line">            res[id] = dist[u] + dist[y] - dist[anc] * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    st[u] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a, b, c), <span class="built_in">add</span>(b, a, c);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//预处理，存入询问</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">if</span> (a != b)</span><br><span class="line">        &#123;</span><br><span class="line">            query[a].<span class="built_in">push_back</span>(&#123;b, i&#125;);</span><br><span class="line">            query[b].<span class="built_in">push_back</span>(&#123;a, i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//并查集初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">tarjan</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ ) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Alexandria-Library"><a href="#Alexandria-Library" class="headerlink" title="Alexandria Library"></a>Alexandria Library</h3><p>向上跳dep</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">20</span>;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>((dep&gt;&gt;i)&amp;<span class="number">1</span>)x=fa[x][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br></pre></td></tr></table></figure><h4 id="代码：-4"><a href="#代码：-4" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rl rt&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rr rt&lt;&lt;1|1</span></span><br><span class="line"><span class="comment">// #pragma GCC optimize(2)</span></span><br><span class="line"><span class="comment">// #pragma GCC optimize(3,&quot;ofast&quot;,&quot;inline&quot;)</span></span><br><span class="line"><span class="comment">// #define ull unsigned long long</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxj=<span class="number">3e5</span>+<span class="number">100</span>,P=<span class="number">131</span>,mod=<span class="number">998244353</span>,inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,m,n) for(int i=m;i&lt;=n;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">t</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(t &amp;res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    t flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((c = <span class="built_in">getchar</span>()) &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            flag = <span class="number">-1</span>;</span><br><span class="line">    res = c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span> ((c = <span class="built_in">getchar</span>()) &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; c &gt;= <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        res = res * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    res *= flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,q;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;g[maxj];</span><br><span class="line"><span class="type">int</span> siz[maxj],dep[maxj];</span><br><span class="line"><span class="type">int</span> fa[maxj][<span class="number">22</span>];</span><br><span class="line"><span class="comment">//lca是这类问题的核心，注意哨兵的作用 ,把1令成根 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> faa,<span class="type">int</span> de)</span></span>&#123;</span><br><span class="line">siz[u]=<span class="number">1</span>;</span><br><span class="line">dep[u]=de;</span><br><span class="line">fa[u][<span class="number">0</span>]=faa;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">20</span>;++j)&#123;</span><br><span class="line">fa[u][j]=fa[fa[u][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;g[u].<span class="built_in">size</span>();++i)&#123;</span><br><span class="line"><span class="type">int</span> v=g[u][i];</span><br><span class="line"><span class="keyword">if</span>(v==faa)<span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs</span>(v,u,de+<span class="number">1</span>);</span><br><span class="line">siz[u]+=siz[v];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//跳跃到的位置 ,表达跳多高 ,发生差值的跳跃 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">up</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> de)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">20</span>;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>((de&gt;&gt;i)&amp;<span class="number">1</span>)x=fa[x][i];</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="comment">//让y的深度尽可能小</span></span><br><span class="line"><span class="keyword">if</span>(dep[u]&lt;dep[v])<span class="built_in">swap</span>(u,v);</span><br><span class="line"><span class="type">int</span> xx=u,yy=v;</span><br><span class="line"><span class="comment">//需要一个记载他跳跃的步数,具不具备路径相同的点 </span></span><br><span class="line"><span class="type">int</span> sep=<span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> flag=<span class="number">0</span>; </span><br><span class="line"><span class="comment">//跳到同一深度</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">20</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(dep[fa[u][i]]&gt;=dep[v])&#123;</span><br><span class="line">flag=<span class="number">1</span>;</span><br><span class="line">sep-=dep[fa[u][i]]-dep[u];</span><br><span class="line">u=fa[u][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//单只树上的情况 </span></span><br><span class="line"><span class="keyword">if</span>(u==v)&#123;</span><br><span class="line"><span class="keyword">if</span>(sep%<span class="number">2</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> f1=<span class="built_in">up</span>(xx,sep/<span class="number">2</span>);</span><br><span class="line"><span class="type">int</span> f2=<span class="built_in">up</span>(xx,sep/<span class="number">2</span><span class="number">-1</span>);</span><br><span class="line"><span class="keyword">return</span> siz[f1]-siz[f2];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//寻找lca算法 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">20</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line"><span class="keyword">if</span>(fa[u][i]!=fa[v][i])&#123;</span><br><span class="line"><span class="comment">//两个分支都在跳 </span></span><br><span class="line">sep=sep+(-dep[fa[u][i]]+dep[u])-(dep[fa[v][i]]-dep[v]);</span><br><span class="line">u=fa[u][i];</span><br><span class="line">v=fa[v][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//少算了lca点</span></span><br><span class="line">sep+=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(sep%<span class="number">2</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//开始的时候都在同一层次 ,减去树的两个分支 </span></span><br><span class="line"><span class="keyword">if</span>(flag==<span class="number">0</span>)&#123;</span><br><span class="line"> <span class="type">int</span> f1=<span class="built_in">up</span>(xx,sep/<span class="number">2</span><span class="number">-1</span>);</span><br><span class="line"><span class="type">int</span> f2=<span class="built_in">up</span>(yy,sep/<span class="number">2</span><span class="number">-1</span>);</span><br><span class="line"><span class="keyword">return</span> n-siz[f1]-siz[f2];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> f1=<span class="built_in">up</span>(xx,sep/<span class="number">2</span>);</span><br><span class="line"><span class="type">int</span> f2=<span class="built_in">up</span>(xx,sep/<span class="number">2</span><span class="number">-1</span>);</span><br><span class="line"><span class="keyword">return</span> siz[f1]-siz[f2];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)g[i].<span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;++i)&#123;</span><br><span class="line"><span class="type">int</span> u,v;cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">g[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span>(q--)&#123;</span><br><span class="line"><span class="type">int</span> u,v;</span><br><span class="line">cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line"><span class="keyword">if</span>(u==v)&#123;</span><br><span class="line">cout&lt;&lt;n&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> cout&lt;&lt;<span class="built_in">query</span>(u,v)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;   </span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;library.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t;t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dp</title>
      <link href="/2024/05/02/dp/"/>
      <url>/2024/05/02/dp/</url>
      
        <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>动态规划，有重复子问题，往往有递归方程，这个往往可以演绎出递推方程，</p><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>有 N件物品和一个容量是 V的背包。每件物品只能使用一次。</p><h4 id="状态表示："><a href="#状态表示：" class="headerlink" title="状态表示："></a>状态表示：</h4><p>前i个物品，占用体积v的价值最大</p><h4 id="集合划分："><a href="#集合划分：" class="headerlink" title="集合划分："></a>集合划分：</h4><p>第i个物品可以选（容量减小，价值变大），可以不选（容量价值不变）</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=v[i];j--)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[j]=<span class="built_in">max</span>(dp[j],dp[j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><h4 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h4><p>有 N 种物品和一个容量是 V的背包，每种物品都有无限件可用。</p><h4 id="状态表示：-1"><a href="#状态表示：-1" class="headerlink" title="状态表示："></a>状态表示：</h4><p>前i个物品，占用体积v的价值最大</p><h4 id="集合划分：-1"><a href="#集合划分：-1" class="headerlink" title="集合划分："></a>集合划分：</h4><p>第i个物品可以选（容量减小，价值变大），可以不选（容量价值不变）</p><p>从小到大更新，更新f[i,j],从大到小更新,更新f[i-1,j];</p><p>公式试推导出来的</p><p>f[i,j]&#x3D;f[i,j-v]+w…</p><p>f[i,j-v]&#x3D;f[j-v*2]+w….</p><p>&#x3D;&gt;当前公式</p><h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = v[i]; j &lt;= m; j ++ )</span><br><span class="line">          f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br></pre></td></tr></table></figure><h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3><h4 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h4><p>有 N种物品和一个容量是 V 的背包。</p><p>第 i种物品最多有 si 件，每件体积是 vi，价值是 wi。</p><h4 id="状态表示：-2"><a href="#状态表示：-2" class="headerlink" title="状态表示："></a>状态表示：</h4><p>前i个物品，占用体积v的价值最大</p><h4 id="集合划分：-2"><a href="#集合划分：-2" class="headerlink" title="集合划分："></a>集合划分：</h4><p>第i个物品可以选（容量减小，价值变大），可以不选（容量价值不变）</p><p>注意可以运用区间的可分性，采用倍增来做题。</p><p>通过倍增分组，然后采用01背包来做题</p><h4 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n,v0;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;v0;</span><br><span class="line">    <span class="comment">//多重背包涉及倍增优化，分组的优化,转化成01背包</span></span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="type">int</span> vv,ww,ss;</span><br><span class="line">        cin&gt;&gt;vv&gt;&gt;ww&gt;&gt;ss;</span><br><span class="line">        <span class="type">int</span> now=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(ss&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            now=<span class="built_in">min</span>(ss,now);</span><br><span class="line">            v[++cnt]=vv*now;</span><br><span class="line">            w[cnt]=ww*now;</span><br><span class="line">            ss-=now;</span><br><span class="line">            now*=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ss&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            v[++cnt]=vv*ss;</span><br><span class="line">            w[cnt]=ww*ss;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for(int i=1;i&lt;=cnt;++i)cout&lt;&lt;v[i]&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">    n=cnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=v0;j&gt;=v[i];--j)&#123;</span><br><span class="line">            f[j]=<span class="built_in">max</span>(f[j],f[j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[v0]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h3><h4 id="题目描述：-3"><a href="#题目描述：-3" class="headerlink" title="题目描述："></a>题目描述：</h4><p>有 N组物品和一个容量是 V的背包。</p><p>每组物品有若干个，同一组内的物品最多只能选一个。</p><h4 id="状态表示：-3"><a href="#状态表示：-3" class="headerlink" title="状态表示："></a>状态表示：</h4><p>前i个物品，占用体积v的价值最大</p><h4 id="集合划分：-3"><a href="#集合划分：-3" class="headerlink" title="集合划分："></a>集合划分：</h4><p>第i个物品可以选（容量减小，价值变大），可以不选（容量价值不变）</p><p>第一维第几组</p><p>第二维多大重量，从大到小，采用01背包的打法</p><p>第三维遍历所有情况，拿到最优解</p><h4 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">for(int i=1;i&lt;=n;++i)&#123;</span><br><span class="line">        cin&gt;&gt;x[i];</span><br><span class="line">        for(int j=1;j&lt;=x[i];++j)&#123;</span><br><span class="line">            cin&gt;&gt;v[i][j]&gt;&gt;w[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // f[0]=1;，方向错了，正着完全背包，反着01背包</span><br><span class="line">    for(int i=1;i&lt;=n;++i)&#123;</span><br><span class="line">        for(int j=v0;j&gt;=1;--j)&#123;</span><br><span class="line">            for(int k=1;k&lt;=x[i];++k)&#123;</span><br><span class="line">                if(j&gt;=v[i][k])&#123;</span><br><span class="line">                    f[j]=max(f[j],f[j-v[i][k]]+w[i][k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="线性DP"><a href="#线性DP" class="headerlink" title="线性DP"></a>线性DP</h2><h3 id="lcs（最长公共子序列"><a href="#lcs（最长公共子序列" class="headerlink" title="lcs（最长公共子序列"></a>lcs（最长公共子序列</h3><h4 id="板子："><a href="#板子：" class="headerlink" title="板子："></a>板子：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://www.luogu.com.cn/problem/P1439</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;mp;<span class="comment">//由于a全排列，所以记录每个数在a中的位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        mp[a[i]]=i;</span><br><span class="line">        dp[i]=<span class="number">1e12</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        cin&gt;&gt;b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最长上升子序列+最长公共子序列</span></span><br><span class="line">    <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=len;</span><br><span class="line">        <span class="keyword">if</span>(mp[b[i]]&gt;dp[len])dp[++len]=mp[b[i]];<span class="comment">//如果当前位置靠后，那么就可以添加进这个数，</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">//dp数组满足单调性，所以可以二分更新右边界+1，右边界+1的位置尽可能小，那么才可能加进更多的数</span></span><br><span class="line">            <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">                <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(dp[mid]&gt;mp[b[i]])&#123;</span><br><span class="line">                    r=mid<span class="number">-1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    l=mid+<span class="number">1</span>;</span><br><span class="line">                    ans=mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans++;</span><br><span class="line">            dp[ans]=<span class="built_in">min</span>(dp[ans],mp[b[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;len&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h3 id="Lis（最长上升子序列"><a href="#Lis（最长上升子序列" class="headerlink" title="Lis（最长上升子序列"></a>Lis（最长上升子序列</h3><h4 id="板子"><a href="#板子" class="headerlink" title="板子"></a>板子</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Lcp（最长公共前缀"><a href="#Lcp（最长公共前缀" class="headerlink" title="Lcp（最长公共前缀"></a>Lcp（最长公共前缀</h3><p><a href="https://codeforces.com/contest/611/problem/D">https://codeforces.com/contest/611/problem/D</a></p><h4 id="板子-1"><a href="#板子-1" class="headerlink" title="板子"></a>板子</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//lcp加dp，这个题个人觉得挺难的</span></span><br><span class="line"><span class="type">int</span> dp[<span class="number">5500</span>][<span class="number">5500</span>],sum[<span class="number">5500</span>][<span class="number">5500</span>];</span><br><span class="line"><span class="type">int</span> n;string s;</span><br><span class="line"><span class="type">int</span> lcp[<span class="number">5500</span>][<span class="number">5500</span>];<span class="comment">//字符串长度，第i到最后，和第j到最后的lcp公共长度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getLcp</span><span class="params">()</span> <span class="comment">//最长公共前缀lcp</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt; i; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j]) lcp[i][j] = lcp[i + <span class="number">1</span>][j + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> lcp[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="comment">//长度一样的起始位置</span></span><br><span class="line">    <span class="type">char</span> a1=s[x+lcp[x][y]];</span><br><span class="line">    <span class="type">char</span> a2=s[y+lcp[x][y]];</span><br><span class="line">    <span class="keyword">if</span>(a1&lt;a2)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//主要在解决两个问题，</span></span><br><span class="line">    <span class="comment">//如何节省字符串大小比较的复杂度，---采用lcp来O1的比较</span></span><br><span class="line">    <span class="comment">//dp方程如何设，---dp[i][j]第i个位置，后边j长度的合理答案</span></span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    s=<span class="string">&#x27; &#x27;</span>+s;</span><br><span class="line">    <span class="built_in">getLcp</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;++i)sum[<span class="number">0</span>][i]=<span class="number">1</span>;<span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">1</span>;len&lt;=i;++len)&#123;<span class="comment">//到i位置的长度</span></span><br><span class="line">            <span class="type">int</span> j=i-len+<span class="number">1</span>;<span class="comment">//起始位置</span></span><br><span class="line">            <span class="keyword">if</span>(s[j]==<span class="string">&#x27;0&#x27;</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//长度绝对可控的时候</span></span><br><span class="line">            dp[i][len]=sum[j<span class="number">-1</span>][len<span class="number">-1</span>];<span class="comment">//由前边位置转移过来，前边的个数小</span></span><br><span class="line">            <span class="type">int</span> pre=j-len;<span class="comment">//长度一样的时候的初始位置</span></span><br><span class="line">            <span class="keyword">if</span>(pre&lt;<span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(pre,j)&amp;&amp;lcp[pre][j]&lt;len)&#123;<span class="comment">//</span></span><br><span class="line">                dp[i][len]=(dp[i][len]+ dp[j<span class="number">-1</span>][len])%MOD;<span class="comment">//在长度相等的情况下，由之前的转移过来</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">            sum[i][j]=(sum[i][j<span class="number">-1</span>]+dp[i][j])%MOD;<span class="comment">//累计所有情况,错在，sum--相同结束的地方，然后一定长度下，由上一个长度转移过来</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        ans=(ans+dp[n][i])%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans%MOD&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h2><p>思路比较固定，代码比较板子，状态和集合划分比较简一</p><p>dp[i,j,01]或者dp[i,j]，ij一般表示区间，01一般表示左加还是右加</p><h3 id="P3205-HNOI2010-合唱队-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P3205-HNOI2010-合唱队-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="[P3205 HNOI2010]合唱队 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>[P3205 <a href="https://www.luogu.com.cn/problem/P3205">HNOI2010]合唱队 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h3><h4 id="状态和集合划分"><a href="#状态和集合划分" class="headerlink" title="状态和集合划分"></a>状态和集合划分</h4><p>dp[i,j,01]表示从i到j，在左还是在右添加，注意初始化和价值改变</p><p>在左：</p><p>从左来0</p><p>从右来1</p><p>在右：</p><p>从左来0</p><p>从右来1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> a[maxj];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">2000</span>][<span class="number">2000</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//多少种排列方式使得结果是理想型</span></span><br><span class="line"><span class="comment">//问题的逆向，以理想型为结果，找多少种方式可以到达</span></span><br><span class="line"><span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//区间dp ，区间上可以做到分解合并新增元素 </span></span><br><span class="line"><span class="comment">//初始化,其实就是一个顺序问题 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">dp[i][i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//第一维往往是长度 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">1</span>;len&lt;=n;++len)&#123;</span><br><span class="line"><span class="comment">//第二维往往是左端点 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r=l+len;l&lt;=n&amp;&amp;r&lt;=n;++l,++r)&#123;</span><br><span class="line"><span class="comment">//第三维可能是切块或者左右移动</span></span><br><span class="line"><span class="comment">//向左移动 </span></span><br><span class="line"><span class="keyword">if</span>(a[l]&lt;a[r])dp[l][r][<span class="number">0</span>]=(dp[l][r][<span class="number">0</span>]+dp[l+<span class="number">1</span>][r][<span class="number">1</span>])%mod;</span><br><span class="line"><span class="keyword">if</span>(a[l]&lt;a[l+<span class="number">1</span>])dp[l][r][<span class="number">0</span>]=(dp[l][r][<span class="number">0</span>]+dp[l+<span class="number">1</span>][r][<span class="number">0</span>])%mod;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向右移动</span></span><br><span class="line"><span class="keyword">if</span>(a[r]&gt;a[r<span class="number">-1</span>])dp[l][r][<span class="number">1</span>]=(dp[l][r][<span class="number">1</span>]+dp[l][r<span class="number">-1</span>][<span class="number">1</span>])%mod;</span><br><span class="line"><span class="keyword">if</span>(a[r]&gt;a[l])dp[l][r][<span class="number">1</span>]=(dp[l][r][<span class="number">1</span>]+dp[l][r<span class="number">-1</span>][<span class="number">0</span>])%mod;</span><br><span class="line">dp[l][r][<span class="number">0</span>]%=mod;</span><br><span class="line">dp[l][r][<span class="number">1</span>]%=mod; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;(dp[<span class="number">1</span>][n][<span class="number">0</span>]+dp[<span class="number">1</span>][n][<span class="number">1</span>])%mod&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h3 id="P4170-CQOI2007-涂色-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P4170-CQOI2007-涂色-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="[P4170 CQOI2007]涂色 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>[P4170 <a href="https://www.luogu.com.cn/problem/P4170">CQOI2007]涂色 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h3><h4 id="状态和集合划分-1"><a href="#状态和集合划分-1" class="headerlink" title="状态和集合划分"></a>状态和集合划分</h4><p>因为是涂色，所以可以区间合并，区间添加元素往往是区间dp</p><p>dp[i,j]从i到j涂色的所有搭配数量</p><p>l和r颜色一样，从中间选最小</p><p>不一样，中间选择，合并找到最小，价值增加在于两个区间各自最小的颜色方案数的求和</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[maxj];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">2000</span>][<span class="number">2000</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//区间dp,新增新的元素 </span></span><br><span class="line">string s;cin&gt;&gt;s;</span><br><span class="line"><span class="type">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">s=<span class="string">&#x27; &#x27;</span>+s;</span><br><span class="line"><span class="comment">//基本的板子+集合划分（分堆，区间新增元素的理解</span></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="comment">//因为有最小的选择，所以初始化到最大 </span></span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f3f3f3f</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">dp[i][i]=<span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> len = <span class="number">1</span>;len &lt;= n;++len)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r=l+len;r&lt;=n&amp;&amp;l&lt;=n;++l,++r)&#123;</span><br><span class="line"><span class="comment">//增加元素</span></span><br><span class="line"><span class="keyword">if</span>(s[l]==s[r])&#123;</span><br><span class="line">dp[l][r]=<span class="built_in">min</span>(dp[l][r<span class="number">-1</span>],dp[l+<span class="number">1</span>][r]);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//我理解是最优子结构，由小部分组合成大部分</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=l;k&lt;r;++k)&#123;<span class="comment">//右端点不等，因为需要留一个 </span></span><br><span class="line">dp[l][r]=<span class="built_in">min</span>(dp[l][r],dp[l][k]+dp[k+<span class="number">1</span>][r]);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;    </span><br><span class="line">&#125; </span><br><span class="line">cout&lt;&lt;dp[<span class="number">1</span>][n]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P1220-关路灯-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1220-关路灯-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P1220 关路灯 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a href="https://www.luogu.com.cn/problem/P1220">P1220 关路灯 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h3><h4 id="状态和集合划分-2"><a href="#状态和集合划分-2" class="headerlink" title="状态和集合划分"></a>状态和集合划分</h4><p>区间dp的题很固定，状态往往直接设，循环方程往往是固定的形式，</p><p>向左向右的题，往往开三维，直接设，遍历的去走</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">int</span> dp[<span class="number">100</span>][<span class="number">100</span>][<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> a[<span class="number">100</span>],b[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> sum[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> n,c;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//区间dp，要适当处理调头这一动作</span></span><br><span class="line"><span class="comment">//左右移动和分堆的题和板子没啥区别 </span></span><br><span class="line">cin&gt;&gt;n&gt;&gt;c;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">cin&gt;&gt;a[i]&gt;&gt;b[i];</span><br><span class="line">sum[i]=sum[i<span class="number">-1</span>]+b[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f3f3f3f</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line"><span class="comment">//向两端遍历</span></span><br><span class="line"><span class="comment">//初始化 </span></span><br><span class="line">dp[c][c][<span class="number">0</span>]=dp[c][c][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//第一维是长度 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> len = <span class="number">1</span>;len&lt;=n;++len)&#123;</span><br><span class="line"><span class="comment">//第二维是左端点 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l+len&lt;=n;++l)&#123;</span><br><span class="line"><span class="type">int</span> r=l+len;</span><br><span class="line"><span class="comment">//多增的功率，在于当前和未被关闭得灯的功率*累加的时间 </span></span><br><span class="line"><span class="comment">//从左边转移过来 </span></span><br><span class="line"><span class="keyword">if</span>(l+<span class="number">1</span>&lt;=r)</span><br><span class="line">dp[l][r][<span class="number">0</span>]=<span class="built_in">min</span>(dp[l+<span class="number">1</span>][r][<span class="number">1</span>]+(a[r]-a[l])*(sum[l]+sum[n]-sum[r]),dp[l+<span class="number">1</span>][r][<span class="number">0</span>]+(a[l+<span class="number">1</span>]-a[l])*(sum[l]+sum[n]-sum[r]));</span><br><span class="line"><span class="comment">//dp[l][r][0]=min(dp[l][r][0],);</span></span><br><span class="line"><span class="comment">//从右边转移过来 </span></span><br><span class="line"><span class="keyword">if</span>(l&lt;=r<span class="number">-1</span>)</span><br><span class="line">dp[l][r][<span class="number">1</span>] = <span class="built_in">min</span>(dp[l][r<span class="number">-1</span>][<span class="number">1</span>]+(a[r]-a[r<span class="number">-1</span>])*(sum[l<span class="number">-1</span>]+sum[n]-sum[r<span class="number">-1</span>]),dp[l][r<span class="number">-1</span>][<span class="number">0</span>]+(a[r]-a[l])*(sum[l<span class="number">-1</span>]+sum[n]-sum[r<span class="number">-1</span>]));</span><br><span class="line"><span class="comment">//dp[l][r][1]=min(dp[l][r][1],);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="built_in">min</span>(dp[<span class="number">1</span>][n][<span class="number">0</span>],dp[<span class="number">1</span>][n][<span class="number">1</span>]) &lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Problem-H-Codeforces"><a href="#Problem-H-Codeforces" class="headerlink" title="Problem - H - Codeforces"></a><a href="https://codeforces.com/group/QJA47ykHfD/contest/437692/problem/H">Problem - H - Codeforces</a></h3><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p><img src="C:\Users\30279\AppData\Roaming\Typora\typora-user-images\image-20230410092323837.png" alt="image-20230410092323837"></p><p>区间dp有O(n^3)和O(n^2)两种打法，前者用k分块，后者从区间中间向区间两边进军，后者需要考虑区间两端的变化就可以。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[l][r]=dp[l+<span class="number">1</span>][r<span class="number">-1</span>]+a[r]*b[l]+a[l]*b[r]-a[l]*b[l]-a[r]*b[r];</span><br></pre></td></tr></table></figure><p>dp[l ] [r ]表示l到r  反转后对于答案的贡献，然后对于所有a*b求和，加上最大的dp[l ] [r ]即为答案。</p><h3 id="P1063-NOIP2006-提高组-能量项链-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1063-NOIP2006-提高组-能量项链-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="[P1063 NOIP2006 提高组] 能量项链 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>[P1063 <a href="https://www.luogu.com.cn/problem/P1063">NOIP2006 提高组] 能量项链 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h3><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><p>矩阵连乘问题，多了个循环（多开一倍的空间），</p><p>len上限n，右区间的上限2*n，最后是，dp[i ] [i+n-1]因为长度是n所以必须减1，要不然就多了。</p><p>具体的转移控制下标：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[l][r]=max(dp[l][r],dp[l][k]+dp[k+1][r]+p[l]*p[k+1]*p[r+1]);//拼接</span><br></pre></td></tr></table></figure><h2 id="图上的dp"><a href="#图上的dp" class="headerlink" title="图上的dp"></a>图上的dp</h2><h3 id="P1613-跑路-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1613-跑路-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P1613 跑路 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a href="https://www.luogu.com.cn/problem/P1613">P1613 跑路 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h3><h4 id="状态和集合划分-3"><a href="#状态和集合划分-3" class="headerlink" title="状态和集合划分"></a>状态和集合划分</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;g[<span class="number">100</span>];</span><br><span class="line"><span class="comment">//floyd算法+倍增+dp（Floyd本身就是图上暴力dp的一种</span></span><br><span class="line"><span class="comment">//第三维记载二进制 </span></span><br><span class="line"><span class="type">int</span> dis[<span class="number">100</span>][<span class="number">100</span>][<span class="number">100</span>];<span class="comment">//初始化dp数组使用 </span></span><br><span class="line"><span class="type">int</span> dp[<span class="number">100</span>][<span class="number">100</span>];<span class="comment">//答案数组 </span></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n,m;cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="comment">//输入 </span></span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f3f3f3f</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line"><span class="type">int</span> u,v;cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">dis[u][v][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">dis[v][u][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">dp[u][v]=<span class="number">1</span>;<span class="comment">//这里需要初始化，本身一步就可达 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化dp数组 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">64</span>;++k)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=n;++t)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[i][t][k<span class="number">-1</span>]==<span class="number">1</span>&amp;&amp;dis[t][j][k<span class="number">-1</span>]==<span class="number">1</span>)</span><br><span class="line">dis[i][j][k]=<span class="number">1</span>,dp[i][j]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Floyd算法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=n;++t)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">dp[i][j]=<span class="built_in">min</span>(dp[i][t]+dp[t][j],dp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;dp[<span class="number">1</span>][n]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="状压dp（未完"><a href="#状压dp（未完" class="headerlink" title="状压dp（未完"></a>状压dp（未完</h2><p>最主要的在于二进制枚举子集，在于对状态的枚举和筛选</p><h3 id="类型1：棋盘上的状压dp，"><a href="#类型1：棋盘上的状压dp，" class="headerlink" title="类型1：棋盘上的状压dp，"></a>类型1：棋盘上的状压dp，</h3><p>1）暴力列的所有状态，选择合适的状态（同行间的限制</p><p>2）暴力所有状态的组合，记录不同行间的限制</p><p>3）注意位置的限制，之后进行状态的转移</p><h3 id="类型2：覆盖问题"><a href="#类型2：覆盖问题" class="headerlink" title="类型2：覆盖问题"></a>类型2：覆盖问题</h3><h3 id="小国王（类型1"><a href="#小国王（类型1" class="headerlink" title="小国王（类型1"></a>小国王（类型1</h3><p><a href="https://www.acwing.com/problem/content/1066/">1064. 小国王 - AcWing题库</a></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>注意check函数–同行间的限制</p><p>注意count–行状态的1的个数</p><p>注意状态的转移</p><h4 id="代码：-4"><a href="#代码：-4" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cnt[<span class="number">1200</span>];</span><br><span class="line"><span class="type">int</span> id[<span class="number">1200</span>];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;head[<span class="number">2000</span>];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;state;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//格子不能相邻</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">12</span>;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(((x&gt;&gt;i)&amp;<span class="number">1</span>)&amp;&amp;((x&gt;&gt;(i+<span class="number">1</span>))&amp;<span class="number">1</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">12</span>;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>((x&gt;&gt;i)&amp;<span class="number">1</span>)res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">12</span>][<span class="number">2000</span>][<span class="number">2000</span>];<span class="comment">//第几行多少个国王并且状态是什么。</span></span><br><span class="line"><span class="comment">//一种是按行设变量，一种是按属性类去设变量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,k;cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="comment">//n*n放k个精确覆盖</span></span><br><span class="line">    <span class="comment">//棋盘类型的dp</span></span><br><span class="line">    <span class="comment">//预处理需要暴力的数组,二进制暴力</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(i))&#123;</span><br><span class="line">            state.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">            cnt[i]=<span class="built_in">count</span>(i);</span><br><span class="line">            <span class="comment">// id[i]=state.size()-1;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//暴力i，j选择合适</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">0</span>;i&lt;state.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;state.<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">            <span class="type">int</span> ii=state[i],jj=state[j];</span><br><span class="line">            <span class="keyword">if</span>((ii&amp;jj)==<span class="number">0</span>&amp;&amp;(<span class="built_in">check</span>(ii|jj)))</span><br><span class="line">                <span class="comment">//反了</span></span><br><span class="line">            head[i].<span class="built_in">emplace_back</span>(j);<span class="comment">//说明i可以由j迁移过来,一个i可以由多少个j迁移过来</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;++i)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> kk=<span class="number">0</span>;kk&lt;=k;++kk)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;state.<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">            <span class="comment">//暴力可以到达的所有状态</span></span><br><span class="line">            <span class="comment">// int now=state[j];</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> jj:head[j])&#123;</span><br><span class="line">                <span class="comment">//这里记录的是下标</span></span><br><span class="line">                <span class="comment">//jj和j都只是状态的下标</span></span><br><span class="line">                <span class="type">int</span> c=cnt[state[j]];</span><br><span class="line">                <span class="comment">// cout&lt;&lt;state[j]&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">                <span class="keyword">if</span>(kk&gt;=c)&#123;</span><br><span class="line">                    dp[i][kk][j]+=dp[i<span class="number">-1</span>][kk-c][jj];</span><br><span class="line">                    <span class="comment">// cout&lt;&lt;dp[i][kk][j]&lt;&lt;&#x27; &#x27;; </span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[n+<span class="number">1</span>][k][<span class="number">0</span>]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="炮兵阵地（类型1"><a href="#炮兵阵地（类型1" class="headerlink" title="炮兵阵地（类型1"></a>炮兵阵地（类型1</h3><p><a href="https://www.acwing.com/problem/content/294/">292. 炮兵阵地 - AcWing题库</a></p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>注意check函数–同行间的限制，当前格的右边和右右边都不可以有</p><p>注意count–行状态的1的个数，对应状态的1的个数</p><p>注意状态的转移–dp[2] [pre] [now],now当前行对应状态的下标，pre是上一行对应状态的下标</p><p>注意w【】用于记录不可以放置大炮的位置，所有操作都是通过位运算进行的。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c[<span class="number">120</span>][<span class="number">12</span>];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;state;</span><br><span class="line"><span class="type">int</span> cnt[<span class="number">2000</span>];</span><br><span class="line"><span class="type">int</span> w[<span class="number">120</span>];<span class="comment">//记录当前行的状态，山地在哪一行里有没有</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> state)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">12</span>;++i)&#123;</span><br><span class="line">        <span class="comment">//当前的右边两个都是不可行的,错了</span></span><br><span class="line">        <span class="keyword">if</span> ((state &gt;&gt; i &amp; <span class="number">1</span>) &amp;&amp; ((state &gt;&gt; i + <span class="number">1</span> &amp; <span class="number">1</span>) || (state &gt;&gt; i + <span class="number">2</span> &amp; <span class="number">1</span>)))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// if((x&gt;&gt;i&amp;1)&amp;&amp;((x+1&gt;&gt;i&amp;1)||(x+2&gt;&gt;i&amp;1)))&#123;</span></span><br><span class="line">    <span class="comment">//         return 0;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">12</span>;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>((x&gt;&gt;i)&amp;<span class="number">1</span>)res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">2</span>][<span class="number">2000</span>][<span class="number">2000</span>];</span><br><span class="line"><span class="comment">//所有的有和没有都会采用二进制优化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//需要处理上两行右三列，合理位置处理答案数组</span></span><br><span class="line">    <span class="type">int</span> n,m;cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;++j)&#123;</span><br><span class="line">            cin&gt;&gt;c[i][j];</span><br><span class="line">            <span class="keyword">if</span>(c[i][j]==<span class="string">&#x27;H&#x27;</span>)w[i]|=<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;m);++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(i))&#123;<span class="comment">//筛选合适的子集，并进行子集划分</span></span><br><span class="line">            state.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">            cnt[i]=<span class="built_in">count</span>(i);</span><br><span class="line">            <span class="comment">// cout&lt;&lt;i&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// dp[0][0][0]=1;</span></span><br><span class="line">    <span class="comment">//数组更新的下标是state的位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> id=<span class="number">1</span>;id&lt;=n;++id)<span class="comment">//第几行</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;state.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;state.<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;state.<span class="built_in">size</span>();++k)&#123;</span><br><span class="line">                <span class="type">int</span> a=state[j],b=state[i],c=state[k];</span><br><span class="line">                <span class="comment">// cout&lt;&lt;w[id]&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">                <span class="keyword">if</span>((w[id]&amp;a)||(w[id<span class="number">-1</span>]&amp;b))<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>((a&amp;b)||(b&amp;c)||(a&amp;c))<span class="keyword">continue</span>;</span><br><span class="line">                    <span class="comment">//采用滚动数组进行优化，第一维是滚动数组，第二维是上一行的状态，第三维是当前行的状态</span></span><br><span class="line">                    dp[id&amp;<span class="number">1</span>][i][j]=<span class="built_in">max</span>(dp[id&amp;<span class="number">1</span>][i][j],dp[id<span class="number">-1</span>&amp;<span class="number">1</span>][k][i]+cnt[a]);</span><br><span class="line">                    <span class="comment">// cout&lt;&lt;a&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// for(int i=0;i&lt;=1;++i)&#123;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;state.<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> z=<span class="number">0</span>;z&lt;state.<span class="built_in">size</span>();++z)&#123;</span><br><span class="line">                ans=<span class="built_in">max</span>(ans,dp[n&amp;<span class="number">1</span>][j][z]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="愤怒的小鸟"><a href="#愤怒的小鸟" class="headerlink" title="愤怒的小鸟"></a>愤怒的小鸟</h3><p><a href="https://www.acwing.com/problem/content/526/">524. 愤怒的小鸟 - AcWing题库</a></p><h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><h4 id="代码：-5"><a href="#代码：-5" class="headerlink" title="代码："></a>代码：</h4><h2 id="数位dp"><a href="#数位dp" class="headerlink" title="数位dp"></a>数位dp</h2><p><a href="https://zhuanlan.zhihu.com/p/613107701">算法学习笔记(22)：数位DP（数位动态规划） - 知乎 (zhihu.com)</a></p><p>前缀和的思想很重要，一般涉及的是对于每一个数位的限制。</p><h3 id="板子-2"><a href="#板子-2" class="headerlink" title="板子"></a>板子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">ll dp[<span class="number">20</span>][<span class="number">70</span>][<span class="number">2000</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">ll a[<span class="number">100</span>];</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(ll b<span class="comment">/*进制*/</span>,ll len<span class="comment">/*当前枚举第几位*/</span>,<span class="type">int</span> f<span class="comment">/*是否有前导零*/</span>,ll state<span class="comment">/*对应二进制为各数字状态*/</span>,<span class="type">int</span> limit<span class="comment">/*是否处在边界*/</span>)</span></span>&#123;</span><br><span class="line">ll res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(!len)&#123;</span><br><span class="line"><span class="keyword">return</span> !state;<span class="comment">//各位置都为0,则表示各位置都取了偶数次 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dp[b][len][state][f][limit]!=<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> dp[b][len][state][f][limit];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> top=b<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(limit)&#123;</span><br><span class="line">top=a[len];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=top;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;f)&#123;</span><br><span class="line">res+=<span class="built_in">dfs</span>(b,len<span class="number">-1</span>,<span class="number">1</span>,state,limit&amp;&amp;(i==top));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">res+=<span class="built_in">dfs</span>(b,len<span class="number">-1</span>,<span class="number">0</span>,state^(<span class="number">1</span>&lt;&lt;i),limit&amp;&amp;(i==top));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dp[b][len][state][f][limit]=res;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">cal</span><span class="params">(ll b,ll d)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(d)&#123;</span><br><span class="line">a[++res]=d%b;</span><br><span class="line">d/=b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">dfs</span>(b,res,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*cout&lt;&lt;setiosflags(ios::fixed)&lt;&lt;setprecision(8)&lt;&lt;ans&lt;&lt;endl;//输出ans（float）格式控制为8位小数（不含整数部分）*/</span></span><br><span class="line"><span class="comment">/*cout&lt;&lt;setprecision(8)&lt;&lt;ans&lt;&lt;endl;//输出ans（float）格式控制为8位小数（含整数部分）*/</span></span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);<span class="comment">//同步流</span></span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line">ll b,l,r;</span><br><span class="line">cin&gt;&gt;b&gt;&gt;l&gt;&gt;r;</span><br><span class="line">cout&lt;&lt;<span class="built_in">cal</span>(b,r)-<span class="built_in">cal</span>(b,l<span class="number">-1</span>)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//题目链接：https://codeforces.com/contest/855/problem/E</span></span><br><span class="line"><span class="comment">//（代码参考:）  https://blog.csdn.net/jk211766/article/details/81474632</span></span><br><span class="line"><span class="comment">//(过程讲解参考:)   https://www.cnblogs.com/young-children/articles/11351588.html</span></span><br></pre></td></tr></table></figure><h3 id="一、C-Unlucky-Numbers"><a href="#一、C-Unlucky-Numbers" class="headerlink" title="一、C. Unlucky Numbers"></a>一、C. Unlucky Numbers</h3><p><a href="https://codeforces.com/contest/1808/problem/C">Problem - C - Codeforces</a></p><h4 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h4><p>有的地方可能炸掉了，但是开成ull就可以了</p><p>这个题，枚举暴力每位最大和最小的差值，然后dfs（其实是暴力），之后枚举每位下界，每一位，从上界到下界开是否可行，找到可行的最大数，此时符合条件即可，</p><p>其实就是对于每一位进行有限制的暴力</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//每一位的变化左界</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> nl=<span class="number">0</span>;nl&lt;=<span class="number">9</span>;++nl)&#123;</span><br><span class="line">        <span class="comment">//对于每一位进行枚举暴力</span></span><br><span class="line">        <span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;++i)&#123;</span><br><span class="line">            <span class="type">int</span> nr=<span class="built_in">min</span>((<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> )<span class="number">9</span>,de+nl);</span><br><span class="line">            <span class="comment">//枚举可行的所有情况</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=nr;k&gt;=nl;--k)&#123;</span><br><span class="line">                <span class="type">int</span> las=now*<span class="number">10</span>+k;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=len;++j)&#123;</span><br><span class="line">                    las=las*<span class="number">10</span>+nl;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(las&lt;=r)&#123;</span><br><span class="line">                    now=now*<span class="number">10</span>+k;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,now);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="二、E-Living-Sequence"><a href="#二、E-Living-Sequence" class="headerlink" title="二、E. Living Sequence"></a>二、E. Living Sequence</h3><p><a href="https://codeforces.com/contest/1811/problem/E">Problem - E - Codeforces</a></p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路:"></a>思路:</h4><p>在数位上的题，应该都可以用dp。dp本身就是一种思想。</p><p>二分找到合适的位置，然后进行数位dp，dp[i]表示当前位数符合条件的答案，</p><p>limt表示前一位是否达到上限，注意边界和暴力搜索</p><p>还有种想法–9进制，因为缺1位，所以转化成9进制，取余 ，然后判断是否小于4，不是就加1，因为缺一个4位</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    <span class="comment">//10个数少一个数，因此可以转化成9进制，循环叠加</span></span><br><span class="line">    string s=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        s+=<span class="built_in">char</span>(<span class="string">&#x27;0&#x27;</span>+((n%<span class="number">9</span>)&lt;<span class="number">4</span>?(n%<span class="number">9</span>):(n%<span class="number">9</span>)+<span class="number">1</span>));</span><br><span class="line">        n/=<span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h2 id="换根dp"><a href="#换根dp" class="headerlink" title="换根dp"></a>换根dp</h2><p><a href="https://zhuanlan.zhihu.com/p/348349531">【朝夕的ACM笔记】动态规划-换根DP - 知乎 (zhihu.com)</a></p><ul><li>其相比于一般的树形DP具有以下特点：</li></ul><p>1，以树上的不同点作为根，其解不同。</p><p>2，故为求解答案，不能单求某点的信息，需要求解每个节点的信息。</p><p>3，故无法通过一次搜索完成答案的求解，因为一次搜索只能得到一个节点的答案。</p><ul><li>换根DP的一般套路：</li></ul><p>1，指定某个节点为根节点。</p><p>2，第一次搜索完成预处理（如子树大小等），同时得到该节点的解。</p><p>3，第二次搜索进行换根的动态规划，由已知解的节点推出相连节点的解。</p><h3 id="一、Problem-D-Codeforces"><a href="#一、Problem-D-Codeforces" class="headerlink" title="一、Problem - D - Codeforces"></a>一、<a href="https://codeforces.com/contest/1805/problem/D">Problem - D - Codeforces</a></h3><h4 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h4><p>题意：边长至少为k的联通块的个数</p><p>策略：换根dp，每个节点更新到其它点的最长距离</p><p>这个问题：</p><p>首先更新一个点的最长，回溯更新now</p><p>其次更新其他点，深搜更新v</p><h4 id="代码：-6"><a href="#代码：-6" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//换根dp，比较板子</span><br><span class="line">//题意边长至少为k的联通块的个数</span><br><span class="line">void dfs1(int now,int fa)&#123;//从1开始的最远距离</span><br><span class="line">    for(auto v:g[now])&#123;</span><br><span class="line">        if(v==fa)continue;</span><br><span class="line">        dfs1(v,now);</span><br><span class="line">        int no=dp1[v]+1;</span><br><span class="line">        //更新最大距离和次大距离，回溯更新当前点</span><br><span class="line">        if(no&gt;dp1[now])&#123;</span><br><span class="line">            dp2[now]=dp1[now];</span><br><span class="line">            dp1[now]=no;</span><br><span class="line">        &#125;else if(no&gt;dp2[now])&#123;</span><br><span class="line">            dp2[now]=no;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void dfs2(int now,int fa)&#123;</span><br><span class="line">    dis[now]=dp1[now];</span><br><span class="line">    for(auto v:g[now])&#123;</span><br><span class="line">        if(v==fa)continue;</span><br><span class="line">        //更新每个点的最大，这里有个树的直径，任一点最远距离的一个端点一定是直径的一端</span><br><span class="line">        if(dp1[now]!=dp1[v]+1)&#123;//更新最大，这里指v没有在now到直径端点的路径上</span><br><span class="line">            dp2[v]=dp1[v];</span><br><span class="line">            dp1[v]=dp1[now]+1;//到直径的距离</span><br><span class="line">        &#125;else&#123;//更新相对于now次大的路径,这时v在now到直径端点上</span><br><span class="line">            if(dp2[now]+1&gt;dp1[v])&#123;</span><br><span class="line">                dp2[v]=dp1[v];</span><br><span class="line">                dp1[v]=dp2[now]+1;</span><br><span class="line">            &#125;else if(dp2[now]+1&gt;dp2[v])&#123;</span><br><span class="line">                dp2[v]=dp2[now]+1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs2(v,now);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树上dp"><a href="#树上dp" class="headerlink" title="树上dp"></a>树上dp</h2><p>第一维通常是节点编号，一般先递归在它的每个子节点上进行dp，在回溯时，从子节点向节点x进行状态转移，</p><p><a href="https://www.cnblogs.com/Wednesday-zfz/p/12209729.html">树形DP 学习笔记 - zfz04 - 博客园 (cnblogs.com)</a></p><p>题单：<a href="https://www.luogu.com.cn/training/13994">0x2 树形dp - 题单 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p>有时树上节点物品数量的统计很重要</p><h3 id="一、节点类"><a href="#一、节点类" class="headerlink" title="一、节点类"></a>一、节点类</h3><p><a href="https://www.luogu.com.cn/problem/P1352">P1352 没有上司的舞会 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化的位置</span></span><br><span class="line">    dp[now][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    dp[now][<span class="number">1</span>]=r[now];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:g[now])&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(i,now);</span><br><span class="line">        <span class="comment">//回溯更新所有节点</span></span><br><span class="line">        dp[now][<span class="number">0</span>]+=<span class="built_in">max</span>(dp[i][<span class="number">0</span>],dp[i][<span class="number">1</span>]);<span class="comment">//当前节点不要</span></span><br><span class="line">        dp[now][<span class="number">1</span>]+=dp[i][<span class="number">0</span>];<span class="comment">//当前节点要</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、背包类"><a href="#二、背包类" class="headerlink" title="二、背包类"></a>二、背包类</h3><h4 id="2-1"><a href="#2-1" class="headerlink" title="2.1"></a>2.1</h4><p>[P2014 <a href="https://www.luogu.com.cn/problem/P2014">CTSC1997] 选课 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p>也可以是分组背包：最大容量，每组最多只要一个–分组背包或许更具一般性，可能是树形很适合孩子当成组，回溯选择最优二重循环这种结构了吧</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//背包树形dp，判断容量，在树上进行选与不选</span></span><br><span class="line"><span class="type">int</span> dp[<span class="number">440</span>][<span class="number">440</span>];<span class="comment">//当前节点,容量为j</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化的位置</span></span><br><span class="line">    <span class="comment">// dp[now][m]=1;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:g[now])&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(i,now);</span><br><span class="line">        <span class="comment">//转移的位置，m+1的原因是：0不应该要，但是为了将森林变成树，却要了，多了个状态</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> ii=m+<span class="number">1</span>;ii&gt;=<span class="number">1</span>;--ii)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;ii;++k)&#123;</span><br><span class="line">                dp[now][ii]=<span class="built_in">max</span>(dp[now][ii],dp[i][k]+dp[now][ii-k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2"><a href="#2-2" class="headerlink" title="2.2"></a>2.2</h4><p><a href="https://www.luogu.com.cn/problem/P1273">P1273 有线电视网 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p>分组背包</p><p>首先，状态和状态的转移</p><p>其次，初始化、预处理以及边界的处理</p><p>最后，在于答案的寻找</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;pii&gt;g[<span class="number">3400</span>];</span><br><span class="line"><span class="comment">//背包树形dp，判断容量，在树上进行选与不选,集合的划分</span></span><br><span class="line"><span class="type">int</span> dp[<span class="number">3400</span>][<span class="number">3400</span>];<span class="comment">//节点 当前节点多少用户  花费  换一下维度，题可能简单很多</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[<span class="number">3400</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化的位置</span></span><br><span class="line">    <span class="keyword">if</span>(now&gt;n-m)&#123;<span class="comment">//终端用户</span></span><br><span class="line">        dp[now][<span class="number">1</span>]=a[now];</span><br><span class="line">        <span class="comment">// cout&lt;&lt;dp[now][1]&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:g[now])&#123;</span><br><span class="line">        <span class="keyword">if</span>(i.first==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> t=<span class="built_in">dfs</span>(i.first,now);sum+=t;<span class="comment">//sum记录该点用户数量</span></span><br><span class="line">        <span class="comment">//转移的位置,类似分组背包，暴力所有节点选择与不选择的情况</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> ii=sum;ii&gt;=<span class="number">1</span>;--ii)&#123;<span class="comment">//01背包</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=t;++j)&#123;<span class="comment">//分组背包</span></span><br><span class="line">                <span class="keyword">if</span>(ii&gt;=j)dp[now][ii]=<span class="built_in">max</span>(dp[now][ii],dp[now][ii-j]+dp[i.first][j]-i.second);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//之所以是树，有前后关系</span></span><br><span class="line">    <span class="comment">//之所以是背包，有选不选的问题</span></span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="comment">//dp初始化，很重要，要不然选择时，负的都比0小，所以无法记录负的</span></span><br><span class="line">    <span class="built_in">memset</span>(dp,~<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)dp[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n-m;++i)&#123;</span><br><span class="line">        <span class="type">int</span> k;cin&gt;&gt;k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=k;++j)&#123;</span><br><span class="line">            <span class="type">int</span> a,c;</span><br><span class="line">            cin&gt;&gt;a&gt;&gt;c;</span><br><span class="line">            g[i].<span class="built_in">emplace_back</span>(a,c);</span><br><span class="line">            g[a].<span class="built_in">emplace_back</span>(i,c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n-m+<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=m;i&gt;=<span class="number">1</span>;--i)&#123;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;dp[1][i]&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">        <span class="keyword">if</span>(dp[<span class="number">1</span>][i]&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;i&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、扫描（换根dp"><a href="#三、扫描（换根dp" class="headerlink" title="三、扫描（换根dp"></a>三、扫描（换根dp</h3><p>特点：给定一个树形结构，，需要以每个节点为根进行一系列统计。</p><p>换根dp一般采用二次扫描来求解</p><p>1，第一次扫描时，任选一个节点为根，在有根树上执行一次树形dp，也就是在回溯时发生的、自底向上的状态转移</p><p>2，第二次扫描时，从刚才选出的根出发，对整棵树执行一次深度优先遍历，在每次递归前进行自顶向下的推导，计算出“换根”后的解。</p><h4 id="3-1"><a href="#3-1" class="headerlink" title="3.1"></a>3.1</h4><p>[P2986 <a href="https://www.luogu.com.cn/problem/P2986">USACO10MAR] Great Cow Gathering G - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p>换根的时候，要充分考虑原来的样子以及换根后的影响，考虑第一次扫描的情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">//关注怎么处理距离</span><br><span class="line">//第一次是有根树,注意统计子树的数量</span><br><span class="line">int dfs1(int now,int fa)&#123;</span><br><span class="line">    int tot=0;</span><br><span class="line">    for(auto i:g[now])&#123;</span><br><span class="line">        int v=i.first,w=i.second;</span><br><span class="line">        if(v==fa)continue;</span><br><span class="line">        int s=dfs1(v,now);</span><br><span class="line">        tot+=s;</span><br><span class="line">        //儿子节点的累加，每个儿子</span><br><span class="line">        f1[now]+=s*w+f1[v];</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt[now]=tot+c[now];//记录当前树的牛的数量</span><br><span class="line">&#125;</span><br><span class="line">//第二次需要画图，找变化,儿子节点=旧的儿子节点-从父亲节点退回+从父亲节点进入儿子节点</span><br><span class="line">void dfs2(int now,int fa)&#123;</span><br><span class="line">    for(auto i:g[now])&#123;</span><br><span class="line">        int v=i.first,w=i.second;</span><br><span class="line">        if(v==fa)continue;</span><br><span class="line">        //从now转移 , 水流没有孩子数量的问题,这个假设都先到1号节点，然后进行转移，所以没有旧的数组</span><br><span class="line">        f2[v]=f2[now]-cnt[v]*w+(sum-cnt[v])*w;</span><br><span class="line">        dfs2(v,now);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void solve()</span><br><span class="line">&#123;</span><br><span class="line">    //不确定根，有最优的选择，无法贪心--换根dp</span><br><span class="line">    int n;cin&gt;&gt;n;</span><br><span class="line">    for(int i=1;i&lt;=n;++i)&#123;</span><br><span class="line">        cin&gt;&gt;c[i];</span><br><span class="line">        sum+=c[i];//sum求错了，NM</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1,u,v,w;i&lt;n;++i)&#123;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">        // sum+=w;</span><br><span class="line">        g[u].emplace_back(v,w);</span><br><span class="line">        g[v].emplace_back(u,w);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs1(1,0);</span><br><span class="line">    // f2[1]=f1[1];</span><br><span class="line">    dfs2(1,0);</span><br><span class="line">    int mn=inf;</span><br><span class="line">    for(int i=1;i&lt;=n;++i)&#123;</span><br><span class="line">        if(f2[i]&lt;mn)&#123;</span><br><span class="line">            mn=f2[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //补充起始数组大小</span><br><span class="line">    cout&lt;&lt;mn+f1[1]&lt;&lt;&#x27;\n&#x27;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2有点难，多做一下"><a href="#3-2有点难，多做一下" class="headerlink" title="3.2有点难，多做一下"></a>3.2有点难，多做一下</h4><p><a href="https://codeforces.com/problemset/problem/708/C">Problem - 708C - Codeforces</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不是重心但是可以是重心--有且只有一个节点尺寸》=n/2，让这个节点的尺寸《=n/2字树接到根上，使之符合条件</span></span><br><span class="line"><span class="comment">//因此，转移的时候就是在找是否存在这么个子树的子树，使之成为重心</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;g[maxj];</span><br><span class="line"><span class="type">int</span> ans[maxj];</span><br><span class="line"><span class="type">int</span> f1[maxj][<span class="number">3</span>]; <span class="comment">//节点 0表示第一大 1表示第二大  准确的说是子树的最大尺寸</span></span><br><span class="line"><span class="type">int</span> f2[maxj];    <span class="comment">//换根后子树的最大情况</span></span><br><span class="line"><span class="type">int</span> maxsiz[maxj];</span><br><span class="line"><span class="type">int</span> siz[maxj];</span><br><span class="line"><span class="type">int</span> las[maxj];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    siz[now]=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// maxsiz[now]=1;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:g[now])&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(i,now);</span><br><span class="line">        <span class="comment">//回溯转移</span></span><br><span class="line">        siz[now]+=siz[i];</span><br><span class="line">        <span class="type">int</span> v;</span><br><span class="line">        <span class="comment">//更新最大子树</span></span><br><span class="line">        <span class="keyword">if</span>(siz[i]&gt;siz[maxsiz[now]])maxsiz[now]=i;</span><br><span class="line">        <span class="comment">//更新可行的最大尺寸</span></span><br><span class="line">        <span class="keyword">if</span>(siz[i]&lt;=n/<span class="number">2</span>)v=siz[i];</span><br><span class="line">        <span class="keyword">else</span> v=f1[i][<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//更新最大和最小</span></span><br><span class="line">        <span class="keyword">if</span>(v&gt;f1[now][<span class="number">0</span>])&#123;</span><br><span class="line">            f1[now][<span class="number">1</span>]=f1[now][<span class="number">0</span>];</span><br><span class="line">            f1[now][<span class="number">0</span>]=v;</span><br><span class="line">            las[now]=i;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(v&gt;f1[now][<span class="number">1</span>])f1[now][<span class="number">1</span>]=v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    ans[now]=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//if判断的是不行的情况，然后改变看行不行</span></span><br><span class="line">    <span class="keyword">if</span>(siz[maxsiz[now]]&gt;n/<span class="number">2</span>)ans[now]=(siz[maxsiz[now]]-f1[maxsiz[now]][<span class="number">0</span>]&lt;=n/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n-siz[now]&gt;n/<span class="number">2</span>)ans[now]=(n-siz[now]-f2[now]&lt;=n/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:g[now])&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//递归换根</span></span><br><span class="line">        <span class="type">int</span> v;</span><br><span class="line">        <span class="comment">//一直在找不合适的情况</span></span><br><span class="line">        <span class="keyword">if</span>(n-siz[now]&gt;n/<span class="number">2</span>)v=f2[now];</span><br><span class="line">        <span class="keyword">else</span> v=n-siz[now];<span class="comment">//记录可能是重心的情况</span></span><br><span class="line">        f2[i]=<span class="built_in">max</span>(f2[i],v);</span><br><span class="line">        <span class="comment">//记载相应子树的子树的最大，然后为剪枝做准备</span></span><br><span class="line">        <span class="keyword">if</span>(las[now]==i)&#123;</span><br><span class="line">            f2[i]=<span class="built_in">max</span>(f2[i],f1[now][<span class="number">1</span>]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            f2[i]=<span class="built_in">max</span>(f2[i],f1[now][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs2</span>(i,now);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DDP动态动态规划"><a href="#DDP动态动态规划" class="headerlink" title="DDP动态动态规划"></a>DDP动态动态规划</h2><p>动态规划维护的部分数据是变化的</p><h3 id="一、Problem-E-Codeforces"><a href="#一、Problem-E-Codeforces" class="headerlink" title="一、Problem - E - Codeforces"></a>一、<a href="https://codeforces.com/contest/1814/problem/E">Problem - E - Codeforces</a></h3><p>题解参考：</p><p><a href="https://zhuanlan.zhihu.com/p/620545656">Educational Codeforces Round 146 (Rated for Div. 2) ABCE - 知乎 (zhihu.com)</a></p><p>参考知识：</p><p><a href="https://blog.csdn.net/SSL_hzb/article/details/99360804">【数据结构 数学 线段树 矩阵乘法 动态dp】SP1716 GSS3 Can you answer these queries III_动态dp sp1716_nymph181的博客-CSDN博客</a></p><h4 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h4><p>本身dp，但是一直在维护询问，所以需要动态dp，</p><p>线段树上dp，普通的正解是什么，dp转移的策略是什么</p><p> 动态动态规划&#x3D;矩阵乘法+dp转移+线段树（二叉树）</p><h4 id="矩阵乘法-dp转移板子："><a href="#矩阵乘法-dp转移板子：" class="headerlink" title="矩阵乘法+dp转移板子："></a>矩阵乘法+dp转移板子：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Mat</span> &#123;</span><br><span class="line">    LL a[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    Mat <span class="keyword">operator</span>*(<span class="type">const</span> Mat&amp; T) <span class="type">const</span> &#123;</span><br><span class="line">        Mat res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">                res.a[i][j] = INF;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; k++) &#123;</span><br><span class="line">                    res.a[i][j] = <span class="built_in">min</span>(res.a[i][j], a[i][k] + T.a[k][j]);<span class="comment">//res是答案，a是当前，T是对象</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="单调队列优化dp"><a href="#单调队列优化dp" class="headerlink" title="单调队列优化dp"></a>单调队列优化dp</h2><h3 id="知识："><a href="#知识：" class="headerlink" title="知识："></a>知识：</h3><p>维护区间长度&lt;&#x3D;m的最值，</p><p>有几个要素很重要：</p><p>1，适用：维护区间长度不大于m的最值</p><p>2，结合：dp转移方程，前缀和，二分，二维</p><p>3，注意：hh变化的条件和题意有关，对谁的单调区间（也就是谁和谁的比较使得tt–</p><h3 id="滑动窗口的板子："><a href="#滑动窗口的板子：" class="headerlink" title="滑动窗口的板子："></a>滑动窗口的板子：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define int long long</span><br><span class="line">const int N=1e6+100;</span><br><span class="line">int a[N],q[N];</span><br><span class="line">signed main()&#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    scanf(&quot;%lld %lld&quot;,&amp;n,&amp;m);</span><br><span class="line">    for(int i=1;i&lt;=n;++i)scanf(&quot;%lld&quot;,&amp;a[i]);</span><br><span class="line">    //模拟队列</span><br><span class="line">    int hh=0,tt=-1;</span><br><span class="line">    //先说最小</span><br><span class="line">    for(int i=1;i&lt;=n;++i)&#123;</span><br><span class="line">        if(hh&lt;=tt&amp;&amp;q[hh]&lt;=i-m)hh++;</span><br><span class="line">        while(hh&lt;=tt&amp;&amp;a[q[tt]]&gt;=a[i])tt--;</span><br><span class="line">        q[++tt]=i;</span><br><span class="line">        if(i&gt;=m)printf(&quot;%lld &quot;,a[q[hh]]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;&#x27;\n&#x27;;</span><br><span class="line">    //再说最大</span><br><span class="line">    hh=0,tt=-1;</span><br><span class="line">    for(int i=1;i&lt;=n;++i)&#123;</span><br><span class="line">        if(hh&lt;=tt&amp;&amp;q[hh]&lt;=i-m)hh++;</span><br><span class="line">        while(hh&lt;=tt&amp;&amp;a[q[tt]]&lt;=a[i])tt--;</span><br><span class="line">        q[++tt]=i;</span><br><span class="line">        if(i&gt;=m)printf(&quot;%lld &quot;,a[q[hh]]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;&#x27;\n&#x27;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一、前缀和-单调队列优化dp"><a href="#一、前缀和-单调队列优化dp" class="headerlink" title="一、前缀和+单调队列优化dp"></a>一、前缀和+单调队列优化dp</h3><p><a href="https://www.acwing.com/problem/content/description/137/">135. 最大子序和 - AcWing题库</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">连续子序列，即子串</span><br><span class="line">前缀和+单调队列优化</span><br><span class="line">dp代表最后位置的值，转移方程</span><br><span class="line">s[i]-min(s[j]) s[j]是距离不超过m范围的最小值，然后整体最大</span><br><span class="line">*/</span><br><span class="line">signed main()&#123;</span><br><span class="line">    ios::sync_with_stdio(0);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line">    int n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=1;i&lt;=n;++i)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        s[i]=s[i-1]+a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    int hh=0,tt=0;</span><br><span class="line">    int ans=-1e18;</span><br><span class="line">    //以最后的位置为终点，维护长度为m的最大值,</span><br><span class="line">    for(int i=1;i&lt;=n;++i)&#123;</span><br><span class="line">        //前缀和是l-1</span><br><span class="line">        if(hh&lt;=tt&amp;&amp;q[hh]&lt;i-m)hh++;</span><br><span class="line">        ans=max(ans,s[i]-s[q[hh]]);</span><br><span class="line">        while(hh&lt;=tt&amp;&amp;s[q[tt]]&gt;=s[i])tt--;</span><br><span class="line">        q[++tt]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;&#x27;\n&#x27;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、二分-单调队列优化dp"><a href="#二、二分-单调队列优化dp" class="headerlink" title="二、二分+单调队列优化dp"></a>二、二分+单调队列优化dp</h3><p><a href="https://www.acwing.com/problem/content/1092/">1090. 绿色通道 - AcWing题库</a></p><p>二分的本质在于区间单调，一半区间满足一般区间不满足</p><p>错的七零八落的，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"></span><br><span class="line">题意：在连续代价不大于t的前提下，中间消耗最小</span><br><span class="line">策略：</span><br><span class="line">二分中间消耗时间(答案)，观察t是否可以满足</span><br><span class="line">最长的最小也在提示二分答案</span><br><span class="line"></span><br><span class="line">单调队列维护的区间长度往往是不大于某个值</span><br><span class="line">dp数组维护要当前位的代价和之前不得不要的最小代价</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line">bool check(int mid)&#123;</span><br><span class="line">    for(int i=0;i&lt;=n+1;++i)dp[i]=0;</span><br><span class="line">    int hh=0,tt=0;</span><br><span class="line">    //应该是维护区间最小值，求和不大于t</span><br><span class="line">    for(int i=1;i&lt;=n;++i)&#123;</span><br><span class="line">        //小于临界,m个空，所以是m+1的最小值</span><br><span class="line">        while(hh&lt;=tt&amp;&amp;q[hh]&lt;i-mid-1)hh++;</span><br><span class="line">        //dp值维护累加选择的最小值</span><br><span class="line">        dp[i]=dp[q[hh]]+a[i];</span><br><span class="line">        //维护dp区间必用最小值</span><br><span class="line">        while(hh&lt;=tt&amp;&amp;dp[q[tt]]&gt;=dp[i])tt--;</span><br><span class="line">        q[++tt]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    //空的区间不能大于m</span><br><span class="line">    if(q[hh]&lt;n-mid)hh++;</span><br><span class="line">    return dp[q[hh]]&lt;=t;</span><br><span class="line">&#125;</span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;t;</span><br><span class="line">    for(int i=1;i&lt;=n;++i)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    int l=0,r=n;</span><br><span class="line">    int ans=0;</span><br><span class="line">    while(l&lt;=r)&#123;</span><br><span class="line">        int mid=l+r&gt;&gt;1;</span><br><span class="line">        if(check(mid))&#123;</span><br><span class="line">            ans=mid;</span><br><span class="line">            r=mid-1;</span><br><span class="line">        &#125;else l=mid+1;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;&#x27;\n&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、二维单调队列优化"><a href="#三、二维单调队列优化" class="headerlink" title="三、二维单调队列优化"></a>三、二维单调队列优化</h3><p><a href="https://www.acwing.com/problem/content/description/1093/">1091. 理想的正方形 - AcWing题库</a></p><p>先进行 行 间单调队列优化， 然后进行 列 间单调队列优化</p><p>tt–那里卡了半天，妈的，你不应该用队尾进行比较吗</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">二维单调队列优化</span><br><span class="line">先进行行间最值的选择</span><br><span class="line">后进行列间最值的选择</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line">// 原数组 给谁 大小</span><br><span class="line">void getmax(int a[],int b[],int cnt)&#123;</span><br><span class="line">    int hh=0,tt=0;</span><br><span class="line">    // q[0]=0;</span><br><span class="line">    for(int i=1;i&lt;=cnt;++i)&#123;</span><br><span class="line">        while(hh&lt;=tt&amp;&amp;q[hh]&lt;=i-k)hh++;</span><br><span class="line">        while(hh&lt;=tt&amp;&amp;a[q[tt]]&lt;=a[i])tt--;</span><br><span class="line">        q[++tt]=i;</span><br><span class="line">        b[i]=a[q[hh]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void getmin(int a[],int b[],int cnt)&#123;</span><br><span class="line">    int hh=0,tt=0;</span><br><span class="line">    // q[0]=0;</span><br><span class="line">    for(int i=1;i&lt;=cnt;++i)&#123;</span><br><span class="line">        while(hh&lt;=tt&amp;&amp;q[hh]&lt;=i-k)hh++;</span><br><span class="line">        while(hh&lt;=tt&amp;&amp;a[q[tt]]&gt;=a[i])tt--;</span><br><span class="line">        q[++tt]=i;</span><br><span class="line">        b[i]=a[q[hh]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">    for(int i=1;i&lt;=n;++i)&#123;</span><br><span class="line">        for(int j=1;j&lt;=m;++j)&#123;</span><br><span class="line">            cin&gt;&gt;x[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //行间最小，最大</span><br><span class="line">    for(int i=1;i&lt;=n;++i)&#123;</span><br><span class="line">        getmax(x[i],mx[i],m);</span><br><span class="line">        getmin(x[i],mn[i],m);</span><br><span class="line">    &#125;</span><br><span class="line">    //列间最小，最大</span><br><span class="line">    int ans=1e9;</span><br><span class="line">    for(int i=k;i&lt;=m;++i)&#123;</span><br><span class="line">        //先存起来</span><br><span class="line">        for(int j=1;j&lt;=n;++j)&#123;</span><br><span class="line">            aa[j]=mx[j][i];</span><br><span class="line">            bb[j]=mn[j][i];</span><br><span class="line">        &#125;</span><br><span class="line">        getmax(aa,cc,n);</span><br><span class="line">        getmin(bb,dd,n);</span><br><span class="line">        // for(int j=1;j&lt;=n;++j)&#123;</span><br><span class="line">        //     cout&lt;&lt;cc[j]&lt;&lt;&#x27; &#x27;;</span><br><span class="line">        // &#125;cout&lt;&lt;&#x27;\n&#x27;;</span><br><span class="line">        for(int j=k;j&lt;=n;++j)&#123;</span><br><span class="line">            ans=min(ans,cc[j]-dd[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;&#x27;\n&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a>四、其他</h3><h4 id="4-1顺时针、逆时针分别维护最值"><a href="#4-1顺时针、逆时针分别维护最值" class="headerlink" title="4.1顺时针、逆时针分别维护最值"></a>4.1顺时针、逆时针分别维护最值</h4><p><a href="https://www.acwing.com/problem/content/1090/">1088. 旅行问题 - AcWing题库</a></p><p>成环的解决方案：破环为链</p><p>核心难点：顺时针（逆时针）时o-d的前缀和一致为正</p><p>最好采用相同的思想,s维护差值的前缀和–全部维护后置的最小，但是要下一个位置不大于后边的最小，以下一个位置为定点，遍历n长度前缀最小，保证前缀不负</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">成环问题：破环成链</span><br><span class="line">可以顺时针走或者逆时针走,</span><br><span class="line">最好采用相同的思想,s维护差值的前缀和</span><br><span class="line">*/</span><br><span class="line">void solve()&#123;</span><br><span class="line">    int n;cin&gt;&gt;n;</span><br><span class="line">    for(int i=1;i&lt;=n;++i)&#123;</span><br><span class="line">        cin&gt;&gt;o[i]&gt;&gt;d[i];</span><br><span class="line">        o[n+i]=o[i];</span><br><span class="line">        d[n+i]=d[i];</span><br><span class="line">    &#125;</span><br><span class="line">    //每个点都要统计一遍</span><br><span class="line">    //顺时针走，逆着来够大</span><br><span class="line">    for(int i=1;i&lt;=n;++i)&#123;</span><br><span class="line">        s[i]=s[i+n]=o[i]-d[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=2*n;++i)&#123;</span><br><span class="line">        s[i]+=s[i-1];</span><br><span class="line">    &#125;</span><br><span class="line">    int hh=0,tt=-1;</span><br><span class="line">    // 全部维护后置的最小，但是要下一个位置不大于后边的最小，以下一个位置为定点，遍历n长度前缀最小，保证前缀不负</span><br><span class="line">    for(int i=2*n;i&gt;=1;--i)&#123;</span><br><span class="line">        while(hh&lt;=tt&amp;&amp;q[hh]&gt;=i+n)hh++;</span><br><span class="line">        while(hh&lt;=tt&amp;&amp;s[q[tt]]&gt;=s[i])tt--;</span><br><span class="line">        q[++tt]=i;</span><br><span class="line">        if(i&lt;=n)&#123;</span><br><span class="line">            ans[i]|=(s[i-1]&lt;=s[q[hh]]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //注意下一个距离的变化</span><br><span class="line">    d[0]=d[n];</span><br><span class="line">    for(int i=1;i&lt;=n;++i)&#123;</span><br><span class="line">        s[i]=s[i+n]=o[i]-d[i-1];</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=2*n;i&gt;=1;--i)&#123;</span><br><span class="line">        s[i]+=s[i+1];</span><br><span class="line">    &#125;</span><br><span class="line">    hh=0,tt=-1;</span><br><span class="line">    for(int i=1;i&lt;=2*n;++i)&#123;</span><br><span class="line">        while(hh&lt;=tt&amp;&amp;q[hh]&lt;=i-n)hh++;</span><br><span class="line">        while(hh&lt;=tt&amp;&amp;s[q[tt]]&gt;=s[i])tt--;</span><br><span class="line">        q[++tt]=i;</span><br><span class="line">        if(i&gt;n)&#123;</span><br><span class="line">            ans[i-n]|=(s[i+1]&lt;=s[q[hh]]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=n;++i)&#123;</span><br><span class="line">        if(ans[i])cout&lt;&lt;&quot;TAK\n&quot;;</span><br><span class="line">        else cout&lt;&lt;&quot;NIE\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2待补"><a href="#4-2待补" class="headerlink" title="4.2待补"></a>4.2待补</h4><p><a href="https://www.acwing.com/problem/content/1089/">1087. 修剪草坪 - AcWing题库</a></p><h4 id="4-3待补（洛谷"><a href="#4-3待补（洛谷" class="headerlink" title="4.3待补（洛谷"></a>4.3待补（洛谷</h4><p><a href="https://www.luogu.com.cn/problem/P5858">P5858 「SWTR-03」Golden Sword - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><h4 id="4-4"><a href="#4-4" class="headerlink" title="4.4"></a>4.4</h4><p><a href="https://codeforces.com/gym/104128/problem/B">Problem - B - Codeforces</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇文章</title>
      <link href="/2024/05/01/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2024/05/01/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="你好"><a href="#你好" class="headerlink" title="你好"></a>你好</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 213 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/05/01/hello-world/"/>
      <url>/2024/05/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
